本次课程是
线下教学
请现场的同学们：
打开雨课堂，点击页面右下角喇叭
按钮调至静音状态
THSS 44100593 2024 / 6A216
Principles of Assembly 
and Compilation
汇编与编译原理
44100593
王朝坤
THSS@Tsinghua
2
THSS 44100593 2024 / 6A216
教学内容
• 针对软件工程学科对汇编语言与编译原理的培养需求，围
绕计算机高级程序设计语言的具体实现过程，
《汇编与编译原理》讲解的主要知识点包括：
• 程序设计语言概述
• 语言翻译系统
• 汇编级机器组织
• ……
• 教学目标：
–编译器的基本原理及组织
–汇编语言程序设计的基本方法
• 为学生掌握设计与实现高级程序设计语言的能力打下
良好基础。
3
THSS 44100593 2024 / 6A216
Virtual Machines
• Tanenbaum: Virtual machine concept
• Programming Language analogy:
• Each computer has a native machine language (language Li
) 
that runs directly on its hardware
• A more human-friendly language is usually constructed 
above machine language, called Language Li+1
• Programs written in Li+1
• should be converted to programs run in Li
.
• How to construct the converters?
4
THSS 44100593 2024 / 6A216
Translating Languages
5
English: Display the sum of A times B plus C.
C++: cout << (A * B + C);
Assembly Language:
mov eax,A
mul B
add eax,C
call WriteInt
Intel Machine Language:
A1 00000000
F7 25 00000004
03 05 00000008
E8 00500000
one to many
one 
to 
one
SE, LLM, ?
THSS 44100593 2024 / 6A216
Specific Machine Levels
6
(descriptions of individual levels follow . . . )
THSS 44100593 2024 / 6A216
High-Level Language
• Level 4
• Application-oriented languages
– C++, Java, Pascal, Visual Basic . . .
• Programs compile into assembly language 
(Level 4) 
7
C++: cout << (A * B + C);
THSS 44100593 2024 / 6A216
Assembly Language
• Level 3
• Instruction mnemonics (助记符) that have a 
one-to-one correspondence to machine 
language
• Programs are translated into Instruction Set 
Architecture Level - machine language 
(Level 2)
8
Assembly Language:
mov eax,A
mul B
add eax,C
call WriteInt
THSS 44100593 2024 / 6A216
Instruction Set Architecture (ISA)
• Level 2
• Also known as conventional machine 
language
• Executed by Level 1 (Digital Logic)
9
Intel Machine Language:
A1 00000000
F7 25 00000004
03 05 00000008
E8 00500000
THSS 44100593 2024 / 6A216
Digital Logic
• Level 1
• CPU, constructed from digital logic gates
• System bus
• Memory
• Implemented using bipolar transistors
10
THSS 44100593 2024 / 6A216
Aim of this Course
11
THSS 44100593 2024 / 6A216
语言翻译系统
重点讲述编译器的设计原理和
常用实现技术。
讲授内容：
1. 编译器的理论框架；
2. 编译方法及核心算法；
3. 常用编译开发工具；
4. 开发实例：设计与实现一个
较为完整的编译器。
12
THSS 44100593 2024 / 6A216
汇编语言程序设计
重点讲述汇编语言程序设计的
基本方法。
讲授内容：
1. 汇编语言的基本构成；
2. 汇编程序设计的基本方法；
3. 汇编语言程序设计专题；
4. 开发实例：小游戏设计等。
13
THSS 44100593 2024 / 6A216
General Information
Instructor: 王朝坤 (62795393, chaokun@tsinghua...)
Office: 东配楼-11-405
Office Hour: Tuesday, 15:30—16:30
TA: 冯昊 (18801007786, fh20@mails.tsinghua...)
张子谦 (18801179321, zhangzq22@mails...)
张航 (18810216282, zhanghang24@mails...)
Office: 东配楼-11-421
Course web page: http://learn.tsinghua.edu.cn/
WeChat group: later
14
THSS 44100593 2024 / 6A216
15
Course Requirements (Pending)
• Presentation (5%).
– Selected topics in each week (slides or demonstration)
• Homework (25%)
– Coding or writing
• Programming project (30%).
– lexical analysis
– parsing
– semantic analysis
– compiler
• teams
• Final exam (40%).
– closed-book and closed-notes
THSS 44100593 2024 / 6A216
AI-assisted Learning (智能自助学习)
16
THSS 44100593 2024 / 6A216
Syllabus (Autumn, 2024. pending)
17
W01 09/10 课程简介、编译的基本概念与发展历程、程
序设计语言分类
Chap.1
W02 09/17 Holiday
W03 09/24 编译器实例、形式语言简顾 Chap.2
W04 09/29 词法分析、词法分析器的自动生成 Chap.3
W05 10/08 语法分析概述、自顶向下语法分析 Chap.4
W06 10/15 文法变换、自底向上语法分析 Chap.4
W07 10/22 SLR(1)分析与LALR(1)分析、语法分析器的
自动生成
Chap.4
W08 10/29 语义处理、运行时存储组织 Chap.5, 7
THSS 44100593 2024 / 6A216
Syllabus (Autumn, 2024. pending)
18
W09 11/05 语法制导翻译 Chap.5
W10 11/12 中间代码生成及优化、目标代码生成 Chap.6, 8
W11 11/19 过程内和过程间优化 Chap.9-12
W12 11/26 汇编语言基本程序结构 Chap.1-4
W13 12/03 子程序结构、输入/输出程序设计 Chap.5-10
W14 12/10 Win32/64汇编语言技术 Chap.11
W15 12/17 BIOS和DOS中断 Chap.14,16
W16 12/24 汇编程序设计专题 Chap.13,15
THSS 44100593 2024 / 6A216
Part I: Principles of 
Compilation
王朝坤
IISE@Tsinghua
19
THSS 44100593 2024 / 6A216
Chap. 1 Introduction
Chaokun Wang
IISE@Tsinghua
THSS 44100593 2024 / 6A216
21
Outline
• What*
– 什么是编译和编译器
• Why
• How
– Info. of this Part
• PL**
– 编译与解释的区别和联系
• History
• Contents*
– 编译各阶段的内容
THSS 44100593 2024 / 6A216
1.1 Computer & Software
22
THSS 44100593 2024 / 6A216
Big Data / Cloud Computing
• Pig Latin
– Pig Latin is a data flow 
language rather than 
procedural or declarative.
– User code and existing 
binaries can be included 
almost anywhere.
– Metadata not required, but 
used when available.
– Support for nested types.
– Operates on files in HDFS.
23
Storage Units
VIP
Key JSON
1
Key JSON Key JSON Key JSON
2
Key JSON Key JSON Key JSON
n
Key JSON Key JSON
Routers
THSS 44100593 2024 / 6A216
24
c
THSS 44100593 2024 / 6A216
Javacard VM
• Off Card VM：卡外虚拟机
– 运行于PC或工作站上，负责所有类装载和引用解析的工作
– 实际上为一个Class File的变换程序：输入类文件和导出文件，输出CAP文件
• Interpreter：字节码解释器
– Java卡虚拟机的在卡部分的核心，一个基于switch-case的跳转表
– 获取字节码、解析字节码和执行字节码。
25
THSS 44100593 2024 / 6A216
软件开发
• 程序开发工具? ?
• 如何从编辑器中的文本到可执行程
序的? ?
26
THSS 44100593 2024 / 6A216
A language-processing system
• gcc -E hi.c
-E Preprocess only; 
do not compile, 
assemble or link
27
Preprocessor
Compiler
Assembler
loader/link-editor
modified source program source program
target assembly program relocatable machine code target machine code library file, relocatable object files • gcc hi.c
• gcc -S hi.c
-S Compile only; 
do not assemble or link
• gcc -c hi.c
-c Compile and assemble, 
but do not link
THSS 44100593 2024 / 6A216
28
What is …
• Compilation（编译）
– Compilation is the process whereby one computer language 
is translated into another (usually simpler and more low￾level i.e. machine orientated) language 
– Traditionally, programs in a high-level computer language 
(e.g. Pascal, C, Objective-C, Lisp) are compiled into 
assembly language (essentially machine code) 
• Compiler（编译器）
– The program that does the translation is known as a 
compiler. 
THSS 44100593 2024 / 6A216
29
Compilers
• Simply stated, a compiler is a program that reads a 
program written in one language — the source 
language — and translates it into an equivalent 
program in another language — the target language. 
As an important part of this translation process, the 
compiler reports to its user the presence of errors in 
the source program.
compiler target
program
source
program
error
message
THSS 44100593 2024 / 6A216
30
Preprocessors
• Preprocessors produce input to compilers. They 
may perform the following functions.
• Macro inclusion.
• File inclusion.
• “Rational” preprocessors.
• Language extensions.
THSS 44100593 2024 / 6A216
31
Assemblers
• Some compilers produce assembly code that is 
passed to an assembler for further processing. 
• Other compilers perform the job of the assembler, 
producing relocatable machine code that can be 
passed directly to the loader/link-editor. 
• The relationship between assembly and machine 
code
– Assembly code is mnemonic version of machine code, 
– names are used instead of binary codes for operations
– names are also given to memory address.
THSS 44100593 2024 / 6A216
32
Loaders and Link-Editors
• Usually, the relocatable machine code may have to 
be linked together with other relocatable object files
and library files into the code that actually runs on 
the machine.
• The linker (link-editor) resolves external memory 
addresses, where the code in one file may refer to a 
location in another file.
• The loader then puts together all of the executable 
object files into memory for execution.
THSS 44100593 2024 / 6A216
33
1.2 Why is PoC?
• Why Learn it ?
– Software Engineering/Computer Science
• OS (shell)
• DBS (sql, xquery)
• WEB (wsdl, soap)
• SE (basis)
– Career
• Programmer (javac, gcj)
• Scientist (wm)
• Why research it?
– Live
• 1956~
• POPL (1973~)
• cc, etc.
– Impact
• PLDI
THSS 44100593 2024 / 6A216
34
Why Study Compilers
• Excellent software-engineering example 
– theory meets practice.
• Essential software tool
• Influences hardware design
– RISC (精简指令集)
– VLIW (超长指令集)
• Tools (mostly “optimization”) for enhancing 
software reliability and security
– memory leak
• Applications
– Pig Latin
– JCVM
– …
THSS 44100593 2024 / 6A216
35
1.3 Textbooks for this Part
Compilers: Principles, Techniques and Tools (2ed) 
Alfred V. Aho, 
Monica S. Lam, 
Ravi Sethi,
Jeffrey D. Ullman
Addison-Wesley, 2006 (77, 86)
ISBN 0-32148-6811
编译原理第2版.本科教学版
Alfred V. Aho, Monica S. Lam, Ravi Sethi,
Jeffrey D. Ullman
译者: 赵建华 郑滔 戴新宇
机械工业出版社, 2009.5
ISBN 9787111269298
THSS 44100593 2024 / 6A216
36
Ref.
The Definitive ANTLR 4 Reference. 
Terence Parr. 
The Pragmatic Programmers, 2013
ISBN: 978-1934356999
Lex and Yacc (2nd edition) 
John R Levine, Tony Mason, Doug Brown
O'Reilly & Associates, October 1992
ISBN: 1-56592-0007
… …
Advanced Compiler Design and Implementation
Steven Muchnick
Morgan Kaufman Publishers, 1997
ISBN 1-55860-320-4
THSS 44100593 2024 / 6A216
37
1.4 Programming Languages
• imperative programming languages
– Fortran, C
• objective-oriented programming languages
– SmallTalk, Objective-C, C++, Java
• functional programming languages
– Lisp, Scheme
• logical programming languages
– Prolog
• other languages
– SQL
THSS 44100593 2024 / 6A216
38
How are languages implemented?
• Various strategies depend on how much pre￾processing is done before a program can be run, 
and how CPU-specific the program is.
• Interpreters run a program “as is” with little or no 
pre-processing, but no changes need to be made to 
run on a different platform.
• Compilers take time to do extensive pre-processing, 
but will run a program generally 2- to 20- times 
faster.
THSS 44100593 2024 / 6A216
39
Language implementations cont’d
• Some newer languages use a combination of 
compiler and interpreter to get many of the benefits 
of each.
• Examples are Java and Microsoft’s .NET, which 
compile into a virtual assembly language (while 
being optimized), which can then be interpreted on 
any computer.
• Other languages (such as Basic or Lisp) have both 
compilers and interpreters written for them.
• Recently, “Just-in-Time” compilers are becoming 
more common - compile code only when it is used!
THSS 44100593 2024 / 6A216
40
• 反编译、汇编、反汇编、翻译、…
• 高级语言之间的转换工具 由于计算机硬件的不断更新换
代，更新更好的程序设计语言的推出为提高计算机的使用
效率提供了良好条件，然而一些已有的非常成熟的软件如
何在新机器新语言情况下使用呢?
• 为了减少重新编制程序所耗费的人力和时间，就要解决如
何把一种高级语言转换成另一种高级语言，乃至汇编语言
转换成高级语言的问题。这种转换工作要对被转换的语言
进行词法和语法分析，只不过生成的目标语言是另一种高
级语言而已。这与实现一个完整的编译程序相比工作量要
少些。
– 比如：
– Scheme to C 的翻译器chicken
– C、PASCAL、FORTRAN到Ada的翻译器
– COBOL 到Java 的翻译器
Buddies of Compilation
THSS 44100593 2024 / 6A216
41
编译程序 低级设计
语言程序
高级设计
语言程序
解释程序 计算结果
Compilation and Interpretation
• 程序设计语言的实现主要的途径有两个：通过编译程序和
解释程序
• 有些语言基本通过解释程序: Python
• 有些环境同时提供编译程序和解释系统: Lisp 
高级设计
语言程序
THSS 44100593 2024 / 6A216
42
Compiler and Interpreter
Source program：… …
b := 2 ;
a := b+2 ; 
write a ; 
… …
直接将4的值输出（显示）
（直接对源程序中的语句进行分析，执行其隐含的操作。）
Int 2
St b
Ld b
add 2
St a
生成代码
Compiler
Interpreter
THSS 44100593 2024 / 6A216
43
编译程序和解释程序
编译程序是一个语言处理程序，把一个高级语言程序翻译成
某个机器的汇编或二进制代码程序，这个二进制代码程序在
机器上运行以生成结果。
通过编译程序使得我们可以先准备好一个在该机器上运行的
程序，然后这个程序便会以机器的速度运行。
但是在不把整个程序全部都翻译结束之后，这个程序是不能
开始运行,也不能产生任何结果的。
编译和运行是两个独立分开的阶段。
但在一个交互环境中,不需要将这两个阶段分隔开,编译就不
如解释的方法更方便。
解释程序不需要在运行前先把源程序翻译成目标代码，也可
以让我们实现在某台机器上运行程序并生成结果。
THSS 44100593 2024 / 6A216
44
解释程序
• 是这样一个程序，它接受某个语言的程序并立即
运行这个源程序。
• 它的工作模式是一条条地获取、分析并执行源程
序语句。一旦第一条语句分析结束，源程序便开
始运行并且生成结果。它特别适合程序员交互方
式的工作情况，即希望在获取下一条语句之前了
解每条语句的执行结果,允许执行时修改程序。
• 著名的解释程序有：
– Basic语言解释程序
– Lisp语言解释程序
– UNIX命令语言解释程序(shell)
– 数据库查询语言SQL 解释程序
– bytecode解释程序
THSS 44100593 2024 / 6A216
45
高级语言解释系统(interpreter)
• 功能：让计算机执行高级语言（basic,lisp,prolog)
• 与编译程序的不同 1）不生成目标代码
 2）能支持交互环境
 （同增量式编译系统）
 源 程 序 
 
初始数据 
解释程序 计算结果
THSS 44100593 2024 / 6A216
46
1.5 History of compiler development
1953 IBM develops the 701 EDPM (Electronic Data 
Processing Machine), the first general purpose 
computer, built as a
“defense calculator”.
No high-level 
languages were 
available, so all 
programming was 
done in assembly.
THSS 44100593 2024 / 6A216
47
History of compilers (cont’d)
As expensive as these early computers were, most of 
the money companies spent was for software 
development, due to the complexities of assembly.
John Backus
In 1953, John Backus came up with the 
idea of “speed coding”, and developed 
the first interpreter. Unfortunately, this 
was 10-20 times slower than programs 
written in assembly.
He was sure he could do better.
THSS 44100593 2024 / 6A216
48
History of compilers (cont’d)
In 1954, Backus and his team released a research 
paper titled “Preliminary Report, Specifications for the 
IBM Mathematical FORmula TRANslating System, 
FORTRAN.”
The initial release of FORTRAN I was in 1956, totaling 
25,000 lines of assembly code. Compiled programs ran 
almost as fast as handwritten assembly!
Projects that had taken two weeks to write now took 
only 2 hours. By 1958 more than half of all software 
was written in FORTRAN.
THSS 44100593 2024 / 6A216
49
How to make a compiler
• 自然语言翻译…
THSS 44100593 2024 / 6A216
50
The A-S Model
The Analysis-Synthesis Model of Compilation
• analysis 
– breaks up the source program into constituent pieces
– creates an intermediate representation of the source 
program
• synthesis
– constructs the desired target program from the intermediate 
representation. 
– requires the most specialized techniques
During analysis
• Data → Symbol Table
THSS 44100593 2024 / 6A216
51
Syntax Tree
• Operations → A hierarchical structure
– the operations implied by the source program are 
determined.
– the operations are recorded
:= +
* position
initial
rate 60
• Syntax tree
– a special kind of tree
– stores the operations implied by the source program
– each node represents an operation 
– the children of a node represent the arguments of the 
operation. 
• A syntax tree for
the assignment statement 
position:= initial + rate *60
THSS 44100593 2024 / 6A216
52
Symbol-Table Management
• An essential function of a compiler 
– is to record the identifiers used in the source program 
– collect information about various attributes of each 
identifier. These attributes may provide information about
• the storage allocated for an identifier, 
• its type, 
• its scope (作用域, where in the program it is valid),
• in the case of procedure names, such things as the 
number and types of its arguments, the method of 
passing each argument (e.g., by reference), and the type 
returned, if any.
THSS 44100593 2024 / 6A216
53
Symbol-Table
• A symbol table (符号表) is a data structure 
– containing a record for each identifier, 
– with fields for the attributes of the identifier. 
• The data structure allows us 
– to find the record for each identifier quickly and 
– to store or retrieve data from that record quickly.
THSS 44100593 2024 / 6A216
54
• When an identifier in the source program is detected 
by the lexical analyzer, 
– the identifier is entered into the symbol table. 
• However, the attributes of an identifier cannot 
normally be determined during lexical analysis.
• For example, in a Pascal declaration like
var position, initial, rate : real ;
the type real is not known when position, initial, and 
rate are seen by the lexical analyzer.
THSS 44100593 2024 / 6A216
55
Error Detection and Reporting
• Each phase can encounter errors. 
• However, after detecting an error, 
– a phase must somehow deal with that error, 
– so that compilation can proceed, 
– allowing further errors in the source program to be detected.
– A compiler that stops when it finds the first error is not as 
helpful as it could be.
• The syntax and semantic analysis phases usually 
handle a large fraction of the errors detectable by the 
compiler.
• The lexical phase can detect errors where the 
characters remaining in the input do not form any 
token of the language.
THSS 44100593 2024 / 6A216
56
• Errors where the token stream violates the structure 
rules (syntax) of the language are determined by the 
syntax analysis phase. 
• During semantic analysis the compiler 
– tries to detect constructs that have the right syntactic 
structure but no meaning to be operation involved, 
– e.g., if we try to add two identifiers, one of which is the 
name of an array, and the other the name of a procedure. 
THSS 44100593 2024 / 6A216
57
Challenges
• Many variations:
– many programming languages (eg, FORTRAN, C++, Java)
– many programming paradigms (eg, object-oriented, 
functional, logic)
– many computer architectures (eg, MIPS, SPARC, Intel, alpha)
– many operating systems (eg, Linux, Solaris, Windows)
THSS 44100593 2024 / 6A216
58
Addressing Portability
• Suppose you want to write compilers from m source 
languages to n computer platforms. A naïve solution 
requires n*m programs:
C++ MIPS
Java SPARC
Pentium
FORTRAN PowerPC
• but we can do it with n+m programs:
C++ MIPS
Java SPARC
Pentium
FORTRAN PowerPC
FE
FE
FE
BE
BE
BE
BE
IR
– IR: Intermediate Representation
– FE: Front-End
– BE: Back-End
THSS 44100593 2024 / 6A216
59
error
handler
Intermediate Code
Generator
Lexical Analyzer
Syntax Analyzer
Semantic Analyzer
Machine-Independent
Code Optimizer
Code Generator
symbol
manager
-table
character stream
target-machine code
Machine-Dependent 
Code Optimizer
token stream
syntax tree
syntax tree
intermediate representation
intermediate representation
target-machine code
The Phases of a Compiler
THSS 44100593 2024 / 6A216
60
Front and Back Ends
• Often, the phases are collected into a front end and a 
back end. 
• The front end consists of those phases or parts of 
phases, that depend primarily on the source 
language and are largely independent of the target 
machine. 
• These normally include 
– lexical and syntactic analysis, 
– the creation of the symbol table, 
– semantic analysis, and 
– the generation of intermediate code. 
– the error handling that goes along with each of these 
phases.
• A certain amount of code optimization can be done 
by the front end as well.
THSS 44100593 2024 / 6A216
61
• The back end includes 
– those portions of the compiler that depend on the target 
machine, 
– and generally, these portions do not depend on the source 
language, just the intermediate languages. 
– aspects of the code optimization phase
– code generation, 
– the necessary error handling and symbol-table operations.
• It has become fairly routine to take the front end of a 
compiler and redo its associated back end to 
produce a compiler for the same source language on 
a different machine. 
• If the back end is designed carefully, it may not even 
be necessary to redesign too much of the back end.
THSS 44100593 2024 / 6A216
62
1.6 Contents of this Part
• 编译程序概述
• 编译程序是现代计算机系统的基本组成部分之一
• 编译程序一般由
– 词法分析程序
– 语法分析程序
– 语义分析程序
– 中间代码生成程序
– 目标代码生成程序
– 代码优化程序
– 符号表管理程序
– 错误处理程序
等成分构成。
THSS 44100593 2024 / 6A216
63
After 44100593(I) you should
• 本部分重点讲述
– 编译器的设计原理和常用实现技术
• 通过这部分课程学习和项目实践
– Theoretical framework
• 清楚地理解一个编译器是如何工作的
• 几个阶段
– Compiler methodology 
• 遇到任何一种程序设计语言，知道如何实现这个语言的多数机制
• 基本语句
– Key algorithms
• 掌握编译原理中的关键算法
– Hands-on experience. 
• 具有一定的使用编译构造工具开发编译器的经验
• ANTLR, Lex/Yacc
– build a complete compiler…
• 能够将所学技术和算法灵活应用于类似的软件的设计和实现中
• Domain Language
THSS 44100593 2024 / 6A216
64
Conclusions
1、什么是编译和编译器
2、编译分哪些阶段
3、编译与解释的区别和联系
THSS 44100593 2024 / 6A216
65
Conclusions
THSS 44100593 2024 / 6A216
66
推荐教学资料
◇ 龙书 §1.2
◇ 龙书 §1.5
◇ 《ACM 图灵奖
——计算机发展史的缩影》
THSS 44100593 2024 / 6A216
67
Happy Mid￾Autumn Festival !
THSS 44100593 2024 / 6A216
本次课程是
线下教学
请现场的同学们：
打开雨课堂，点击页面右下角喇叭
按钮调至静音状态
THSS 44100593 2024 / 6A216
Chap. 2 编译示例及形式语言简顾
王朝坤
chaokun@tsinghua.edu.cn
THSS 44100593 2024 / 6A216
3
Outline
• Sample
– Motivation
– Example
• Formal Lang.*
– Natural Lang.
– Definitions
– Operations
• Description
– Grammar
• CFG*
THSS 44100593 2024 / 6A216
4
error
handler
Intermediate Code
Generator
Lexical Analyzer
Syntax Analyzer
Semantic Analyzer
Machine-Independent
Code Optimizer
Code Generator
symbol
manager
-table
character stream
target-machine code
Machine-Dependent 
Code Optimizer
token stream
syntax tree
syntax tree
intermediate representation
intermediate representation
target-machine code
1. Sample — Motivation
THSS 44100593 2024 / 6A216
5
Translation of an 
assignment 
statement Lexical Analyzer Syntax Analyzer
Semantic Analyzer
Intermediate Code Generator
Code Optimizer
code generator
position:= initial + rate * 60 <id,1> <=> <id,2> <+> <id,3> <*> <60> := + * <id,1>
<id,2>
<id,3> 60 := + *
60
inttoreal temp1 := inttoreal(60) temp2 := id3 *temp1 temp3 := id2 +temp2 id1 := temp3
temp1 := id3 *60.0 id1 := id2 + temp1 MOVF id3, R2 MULF #60.0, R2 MOVF id2, R1 ADDF R2, R1 MOVF R1, id1
SYMBOL TABLE
position …
initial …
rate …
1
2
3
4 <id,1>
<id,2>
<id,3>
position:= initial + rate * 60
MOVF id3, R2
MULF #6 0.0, R2
MOVF id2, R1
ADDF R2, R1
MOVF R1, id1
THSS 44100593 2024 / 6A216
6
• 高级语言的认识
• 要学习和构造编译程序，理解和定义程序设计语言是必不
可少的。
• 每个程序设计语言都有一定的规则用于规定合适程序的语
法结构，也需要有对一个程序的含义的精确描述。
• 上下文无关文法CFG给出程序设计语言的精确的、易于理
解的语法说明。
• 尚没有公认的形式系统描述程序含义。
• 流行的描述语义规则的方法—属性文法。
VLDB 2018
THSS 44100593 2024 / 6A216
7
• 词法分析程序的自动构造
• 词法分析程序是编译程序的一个构成部分，它的主要任务
是
– 扫描源程序
– 按构词规则识别单词
– 报告发现的词法错误
• 正则表达式和有穷状态自动机是
– 单词的描述工具和识别机制
– 词法分析程序的自动构造原理
• 学习Lex/ANTLR等工具的使用方法。
Lexical Analyzer Syntax Analyzer
Semantic Analyzer
Intermediate Code Generator
Code Optimizer
code generator
position:= initial + rate * 60 <id,1> <=> <id,2> <+> <id,3> <*> <60> := + * <id,1>
<id,2>
<id,3> 60 := + *
60
inttoreal temp1 := inttoreal(60) temp2 := id3 *temp1 temp3 := id2 +temp2 id1 := temp3
temp1 := id3 *60.0 id1 := id2 + temp1 MOVF id3, R2 MULF #60.0, R2 MOVF id2, R1 ADDF R2, R1 MOVF R1, id1
SYMBOL TABLE
position …
initial …
rate …
1
2
3
4 <id,1>
<id,2>
<id,3>
THSS 44100593 2024 / 6A216
8
SYMBOL TABLE
position …
initial …
rate …
• 语法分析程序的构造
• 自顶向下的语法分析
• 可以看作是为一个输入串寻找一个最
左推导的过程,
• 等价于从根开始，按前序生成结点，
为输入串构造分析树的过程。
• 讨论一种有效的无回溯的自顶向下分
析程序，这种分析程序称为预测分析
程序。
• 介绍对于一个文法类：LL（1）文法。
• 如何自动构造预测分析程序。 
Lexical Analyzer Syntax Analyzer
Semantic Analyzer
Intermediate Code Generator
Code Optimizer
code generator
position:= initial + rate * 60 <id,1> <=> <id,2> <+> <id,3> <*> <60> := + * <id,1>
<id,2>
<id,3> 60 := + *
60
inttoreal temp1 := inttoreal(60) temp2 := id3 *temp1 temp3 := id2 +temp2 id1 := temp3
temp1 := id3 *60.0 id1 := id2 + temp1 MOVF id3, R2 MULF #60.0, R2 MOVF id2, R1 ADDF R2, R1 MOVF R1, id1
1
2
3
4 <id,1>
<id,2>
<id,3>
THSS 44100593 2024 / 6A216
9
• 自底向上（自下而上）语法分析方法
• 也称移进-归约分析法
• 基本思想是对输入符号串自左向右进行扫描，并将输入符
逐个移入一个后进先出栈中；边移进边分析，一旦栈顶符
号串形成可归约串，就用相应非终结符代替可归约串，这
称为一步归约；重复这一过程，直到归约到栈中只剩文法
的开始符号时，则为分析成功，并确认输入串是文法的句
子。
• 介绍LR分析法，分析过程中归约的是当前句型的句柄，
称为规范归约。
• 重点讲解LR类（SLR（1）、LALR（1）、LR（1））文
法的分析表的构造原理。
THSS 44100593 2024 / 6A216
10
• 语义分析和中间代码生成
• 在词法分析和语法分析之后，编译程
序下一个逻辑阶段的任务是语义分析
和生成中间代码。
• 引入属性文法和语法制导翻译的概念，
• 介绍中间代码的形式，
• 针对一些语法成分讨论相应语义处理
工作的描述。
SYMBOL TABLE
position …
initial …
rate …
Lexical Analyzer Syntax Analyzer
Semantic Analyzer
Intermediate Code Generator
Code Optimizer
code generator
position:= initial + rate * 60 <id,1> <=> <id,2> <+> <id,3> <*> <60> := + * <id,1>
<id,2>
<id,3> 60 := + *
60
inttoreal temp1 := inttoreal(60) temp2 := id3 *temp1 temp3 := id2 +temp2 id1 := temp3
temp1 := id3 *60.0 id1 := id2 + temp1 MOVF id3, R2 MULF #60.0, R2 MOVF id2, R1 ADDF R2, R1 MOVF R1, id1
1
2
3
4 <id,1>
<id,2>
<id,3>
THSS 44100593 2024 / 6A216
11
• 符号表
• 介绍符号表的一般组织和使用方法
• 讨论分程序结构语言的名字作用域分析
• 讨论符号表设计方案
SYMBOL TABLE
position …
initial …
rate …
Lexical Analyzer Syntax Analyzer
Semantic Analyzer
Intermediate Code Generator
Code Optimizer
code generator
position:= initial + rate * 60 <id,1> <=> <id,2> <+> <id,3> <*> <60> := + * <id,1>
<id,2>
<id,3> 60 := + *
60
inttoreal temp1 := inttoreal(60) temp2 := id3 *temp1 temp3 := id2 +temp2 id1 := temp3
temp1 := id3 *60.0 id1 := id2 + temp1 MOVF id3, R2 MULF #60.0, R2 MOVF id2, R1 ADDF R2, R1 MOVF R1, id1
1
2
3
4 <id,1>
<id,2>
<id,3>
THSS 44100593 2024 / 6A216
12
• 运行时的存储组织和管理
• 编译的最终目标是生成目标程序。
在目标代码生成前，编译程序必须
对目标程序运行时的数据空间进行
组织和安排. 
• 介绍目标程序运行时的数据空间的
存储分配策略，
• 说明程序设计语言本身关于名称的
作用域和生存期的规则与存储分配
策略的关系，
• 重点讨论栈式动态存储方案.
Lexical Analyzer Syntax Analyzer
Semantic Analyzer
Intermediate Code Generator
Code Optimizer
code generator
position:= initial + rate * 60 <id,1> <=> <id,2> <+> <id,3> <*> <60> := + * <id,1>
<id,2>
<id,3> 60 := + *
60
inttoreal temp1 := inttoreal(60) temp2 := id3 *temp1 temp3 := id2 +temp2 id1 := temp3
temp1 := id3 *60.0 id1 := id2 + temp1 MOVF id3, R2 MULF #60.0, R2 MOVF id2, R1 ADDF R2, R1 MOVF R1, id1
SYMBOL TABLE
position …
initial …
rate …
1
2
3
4 <id,1>
<id,2>
<id,3>
THSS 44100593 2024 / 6A216
13
• 代码优化是对代码作一些等价
变换，以使得最后生成的目标
代码更为高效。
– 机器无关的优化
– 机器相关的优化
• 介绍优化技术
• 优化分类
• 优化工作的基础－控制流和数
据流分析问题
Lexical Analyzer Syntax Analyzer
Semantic Analyzer
Intermediate Code Generator
Code Optimizer
code generator
position:= initial + rate * 60 <id,1> <=> <id,2> <+> <id,3> <*> <60> := + * <id,1>
<id,2>
<id,3> 60 := + *
60
inttoreal temp1 := inttoreal(60) temp2 := id3 *temp1 temp3 := id2 +temp2 id1 := temp3
temp1 := id3 *60.0 id1 := id2 + temp1 MOVF id3, R2 MULF #60.0, R2 MOVF id2, R1 ADDF R2, R1 MOVF R1, id1
SYMBOL TABLE
position …
initial …
rate …
1
2
3
4 <id,1>
<id,2>
<id,3>
THSS 44100593 2024 / 6A216
14
• 编译的最后一个逻辑阶段是目
标代码生成。
• 目标代码生成程序的设计细节
要考虑目标语言和操作系统的
特点。
• 讨论目标代码生成程序设计的
一般问题
– 指令选择
– 寄存器分配
– 计算顺序选择 SYMBOL TABLE
position …
initial …
rate …
Lexical Analyzer Syntax Analyzer
Semantic Analyzer
Intermediate Code Generator
Code Optimizer
code generator
position:= initial + rate * 60 <id,1> <=> <id,2> <+> <id,3> <*> <60> := + * <id,1>
<id,2>
<id,3> 60 := + *
60
inttoreal temp1 := inttoreal(60) temp2 := id3 *temp1 temp3 := id2 +temp2 id1 := temp3
temp1 := id3 *60.0 id1 := id2 + temp1 MOVF id3, R2 MULF #60.0, R2 MOVF id2, R1 ADDF R2, R1 MOVF R1, id1
1
2
3
4 <id,1>
<id,2>
<id,3>
THSS 44100593 2024 / 6A216
15
Translation of an 
assignment 
statement
Lexical Analyzer Syntax Analyzer
Semantic Analyzer
Intermediate Code Generator
Code Optimizer
code generator
position:= initial + rate * 60 <id,1> <=> <id,2> <+> <id,3> <*> <60> := + * <id,1>
<id,2>
<id,3> 60 := + *
60
inttoreal temp1 := inttoreal(60) temp2 := id3 *temp1 temp3 := id2 +temp2 id1 := temp3
temp1 := id3 *60.0 id1 := id2 + temp1 MOVF id3, R2 MULF #60.0, R2 MOVF id2, R1 ADDF R2, R1 MOVF R1, id1
SYMBOL TABLE
position …
initial …
rate …
1
2
3
4 <id,1>
<id,2>
<id,3> √ CFG
√ RE
√ Automata
√ Graph
√ …
THSS 44100593 2024 / 6A216
16
2. Formal Languages
• Artificial language
– Programming Languages
• Formal languages
• Formal language theory
THSS 44100593 2024 / 6A216
17
Terminology
• An alphabet Σ (字母表, character class 字符类)
– is a finite set of symbols (符号)
– letters, characters
– {0, 1}, ASCII, EBCDIC
• A string s over Σ (串, sentence 句子, word 字)
– is a finite sequence of symbols from Σ
– |s| denotes the length of string s
– ε denotes the empty string, thus |ε| = 0
• A language L (语言)
– is simply any set of strings over a fixed alphabet.
• camera
– prefix of s, suffix of s, substring of s
– proper prefix, suffix or substring of s
– subsequence of s 
THSS 44100593 2024 / 6A216
18
3. 如何描述一种语言
• 穷举法
• 语言中的句子数量可能是无穷的
– 有穷表示方法
• 具有无穷句子的语言的有穷表示
– 生成方式
– 文法：严格定义的规则
– 识别方式
– 自动机：过程
– 有限次计算后会停止并回答“是”
– 停止并回答“不是”
– 永远继续下去
文法即用生成方式描述语言
– 语言中的每个句子可以用严格定义的规则来
构造
THSS 44100593 2024 / 6A216
19
文法
• 文法G定义为四元组(VN，VT，P，S )其中
– VN：非终结符号(或语法实体，或变量)集；
– VT：终结符号集；
– P： 规则的集合；
– S： 称作识别符号或开始符号的一个非终结符，它至少要在一条
产生式中作为左部出现。
• 注意：
– VN、VT和P是非空有穷集。
– VN ∩ VT = φ
– 用V表示VN ∪ VT ，称为文法G的字母表或字汇表
– 规则（重写规则、产生式或生成式）
• 是形如 α→β 或 α ∷=β 的(α ，β)有序对
• α∈V+
• β∈V*
• α 称为规则的左部， β 称作规则的右部。
THSS 44100593 2024 / 6A216
20
直接推导（→）
直接推导
给定文法G(VN, VT, P, S), 若有v,w满足：
 - v = Yαδ,
- w = Yβδ, 
- α → β∈P，
 - Y ∈ V*
- δ ∈ V*
则称v直接推导到w,记作 v → w
也称w直接归约到v
例：G： S→0S1， S→01
S → 0S1
0S1 → 00S11
00S11 → 000S111
000S111 → 00001111 
THSS 44100593 2024 / 6A216
21
推导
• 推导
– 若存在v =w0 →w1 →... →wn=w, (n>0)
– 则记为v => w，称作v推导出w，或w归约到v
– 若有v=w 或 v => w
– 则记为v => w
例：G： S→0S1， S→01
0S1 →00S11
00S11 →000S111
000S111 →00001111 
S →0S1 →00S11 →000S111 →00001111 
S => 00001111
S => S 
00S11 => 00S11
+
+
*
+
*
*
THSS 44100593 2024 / 6A216
22
• 句型
给定文法G，若S => x，则称x是文法G的句型。
• 句子
给定文法G，若S => x，且x∈VT
*，则称x是文法G的句子。
例：G： S→0S1， S→01
S →0S1 →00S11 →000S111 →00001111
G的句型？
— S, 0S1 , 00S11, 000S111, 00001111
G的句子？
— 00001111, 01
句型和句子
*
*
THSS 44100593 2024 / 6A216
23
L(G)
由文法G(VN
, VT
, P, S)生成的语言记为L(G)
— 是文法G的一切句子的集合 
 — L(G)={x|S => x，x ∈VT
*
}
例：G： S→0S1， S→01
L(G)={0n1
n|n≥1}
*
THSS 44100593 2024 / 6A216
24
例：文法G[S]：
（1）S→aSBE
（2）S→aBE
（3）EB→BE
（4）aB→ab
（5）bB→bb
（6）bE→be
（7）eE→ee
L(G) (cont’d)
L(G)={ a
nbne
n | n≥1 } 
(1) G生成的每个串都在L(G)中
(2) L(G)中的每个串确实能被G生成
THSS 44100593 2024 / 6A216
25
文法的等价
• 文法G1和G2是等价的
– 若L（G1）=L（G2）
• 文法G1[A]：A→DB 与G2[S]：S→0S1 是否等价？
 A→DE S→01 
E→AB
D→0
B→1
THSS 44100593 2024 / 6A216
26
文法的类型
通过对产生式施加不同的限制，Chomsky将文法分为四种类
型：
0型文法：对任一产生式α→β，都有α∈(VN∪VT)
+
， β∈(VN∪VT)
*
1型文法：对任一产生式α→β，都有|β|≥|α|， 仅仅 S→ε除外
2型文法：对任一产生式α→β，都有α∈VN
3型文法：任一产生式α→β的形式都为A→aB或A→a，其中A∈VN ，
B∈VN ，a∈VT
*
THSS 44100593 2024 / 6A216
27
0型文法
— 无限制文法
— 形式语言谱系中最大的文法类
— 对生成式α→β不作特殊限制
α≠ε
THSS 44100593 2024 / 6A216
28
1型文法
例：1型（上下文有关）文法
 文法G[S]： S→CD Ab→bA
C→aCA Ba→aB
C→bCB Bb→bB
AD→aD C→a
BD→bD D→b
Aa→bD
β要至少和α一样长
THSS 44100593 2024 / 6A216
29
2型文法
例：2型（上下文无关）文法
 
 文法G[S]：S→AB
A→BS|0
B→SA|1
α必须是非终结符
THSS 44100593 2024 / 6A216
30
3型文法
G[S]：
 S→0A|1B|0
A→0A|1B|0S
B→1B|1|0
G[I]：
 I → Tl
I → l
T → Tl
T → Td
T → l
T → d
例：3型（正则）文法
右线性文法/左线性文法
THSS 44100593 2024 / 6A216
31
文法的关联
四类文法之间的逐级“包含”关系
2型文法
1型文法
0型文法
3型文法
在不考虑空字符串时，i型语
言都真包含i＋1型语言 (for 
i＝0，1，2)
THSS 44100593 2024 / 6A216
32
文法和语言
• 0型文法产生的语言称为0型语言
• 1型文法或上下文有关文法（ CSG ）产生的语言称为1型
语言或上下文有关语言（ CSL ）
• 2型文法或上下文无关文法（ CFG ）产生的语言称为2型
语言或上下文无关语言（ CFL ） 
• 3型文法或正则（正规）文法（ RG ）产生的语言称为3型
语言正则（正规）语言（ RL ） 
THSS 44100593 2024 / 6A216
33
文法和语言
• 四种文法之间的关系：
– 将产生式做进一步限制而定义的
• 语言之间的关系依次：
– 存在不是上下文有关语言的0型语言
– 存在不是上下文无关语言的1型语言
– 存在不是正则语言的上下文无关语言
THSS 44100593 2024 / 6A216
34
文法和识别系统
• 根据形式语言理论，文法和识别系统间有这样的关系
• 0型文法（短语结构文法）
– 能力相当于图灵机
– 可以表征任何递归可枚举集
– 任何0型语言都是递归可枚举的
• 任何能用图灵机描述的计算都能机械实现
• 任何能在现代计算机上实现的计算都能用图灵机描述
THSS 44100593 2024 / 6A216
35
图灵机
• 理论计算机——一切计算机的抽象模型
– 一个无限长的带子
– 一个读写头
– 内部状态
– 控制程序
根据程序的命令以及它的
内部状态进行带子的读写、
移动
THSS 44100593 2024 / 6A216
36
文法和识别系统(cont’d)
• 1型文法（上下文有关文法CSG）
– 产生式的形式为α1Aα2→α1βα2
– 只有A出现在α1和α2的上下文中时，才允许β取代A
– 其识别系统是非确定型线性有界自动机
• 2型文法（上下文无关文法CFG）
– 产生式的形式为A→β
– β取代A时与A的上下文无关
– 其识别系统是不确定的下推自动机
• 3型文法（正规文法RG）
– 产生的语言是有穷自动机（FA）所接受的集合
– 正则表达式
THSS 44100593 2024 / 6A216
37
4. 上下文无关文法及其语法树
上下文无关文法有足够的能力描述程序设计语言的语法结构
语法树---句型推导的直观表示
THSS 44100593 2024 / 6A216
38
句型推导（a+a*a）
G[E]： E→E+T|T
T→T*F|F
F→(E)|a
E→E+T →T+T →F+T →a+T →a+T*F
→a+F*F →a+a*F →a+a*a
E→E+T →E+T*F →E+T*a →E+F*a →E+a*a
→T+a*a →F+a*a →a+a*a
E→E+T →T+T →T+T*F →F+T*F →F+F*F
→a+F*F →a+F*a →a+a*a
THSS 44100593 2024 / 6A216
39
规范推导 规范句型
句型推导的分类
最左（最右）推导：
— 在推导的任何一步α → β，其中α、β是句型，都是对α
中的最左（右）非终结符进行替换
最右推导被称为规范推导。
由规范推导所得的句型称为规范句型
句型推导的直观表示
语法树
THSS 44100593 2024 / 6A216
40
语法树
设G=( VN
,VT
,P,S)为一cfg，若一棵树满足下列4个条件，则此
树称作G的语法树/推导树/派生树：
1. 根结点的标号是文法的开始符号S
2. 每个内部结点的标号为A，且A∈VN
3. 每个叶结点标号为一个终结符号或 ε
4. 如果结点n有标记A,其子结点从左到右的次序是n1，
n2，…，nk，对应的标号分别为A1，A2，…，Ak，那么
A→A1A2，…，Ak一定是P中的一个产生式。特例：若A→
ε是一个产生式，则标号为A的结点可以只有一个标号为ε
的子结点。
语法树的结果：
 从左到右读出叶子的标号构成一个句子
THSS 44100593 2024 / 6A216
41
语法树示例
• 句型aabbaa的可能推导序列和语法树
例: G[S]:
S→aAS
A→SbA
A→SS
S→a
A→ba
S→aAS→aAa→aSbAa→aSbbaa→aabbaa
S→aAS→aSbAS→aabAS→aabbaS→aabbaa
S→aAS→aSbAS→aSbAa→aabAa→aabbaa
S
a A S
S b A a
a b a
THSS 44100593 2024 / 6A216
42
语法树性质
给定文法G=(VN
,VT
,P,S)，对于G的任何句型都能构造与之关
联的语法树(推导树)吗？
定理：
 G为上下文无关文法，
对于α≠ε，有S => α，当且仅当
文法G有以α为结果的一棵语法树(推导树)
一棵语法树表示了一个句型的种种可能的(但未必是所有的)
不同推导过程，包括最左(最右)推导。但是，一个句型是
否只对应唯一的一棵语法树呢?一个句型是否只有唯一的
一个最左(最右)推导呢?
*
THSS 44100593 2024 / 6A216
43
句型 i*i+i
例：G‘[E]:
E → i
E → E+E
E → E*E
E → (E)
E
E + E
E * E i
i i
E
E * E
i E + E
i i
句型 i*i+i 的两个不同的最左推导：
推导1：E → E+E → E*E+E → i*E+E → i*i+E → i*i+i
推导2：E → E*E → i*E → i*E+E → i*i+E →i*i+i
THSS 44100593 2024 / 6A216
44
二义性
自然语言中存在二义性
 “走火”
“打酱油”
“你是个好人......”
程序设计语言中存在“类似情况”吗？
 i+i*i
如何避免二义性→如何刻画二义性
语言与文法的关系→语言的二义性、文法的二义性
THSS 44100593 2024 / 6A216
45
文法的二义性和语言的二义性
文法的二义性和语言的二义性是两个不同的概念
若一个文法存在某个句子对应两棵不同的语法树，
则称这个文法是二义的
或者，若一个文法存在某个句子有两个不同的最左
（右）推导，则称这个文法是二义的
如果产生上下文无关语言的每一个文法都是二义的，
则说此语言是先天二义的。
THSS 44100593 2024 / 6A216
46
二义性CFG的范围
可能有两个不同的文法G和G′，其中G是二义的，但
是却有L(G)=L(G′)，也就是说，这两个文法所产
生的语言是相同的。
THSS 44100593 2024 / 6A216
47
二义性与程序设计语言
判定任给的一个上下文无关文法是否二义，或它是
否产生一个先天二义的上下文无关语言，这两个
问题是递归不可解的，但可以为无二义性寻找一
组充分条件。
对于一个程序设计语言来说，常常希望它的文法是
无二义的，因为希望对它的每个语句的分析是唯
一的。
二义文法改造为无二义文法
G[E]: E → i G′[E]：E → T|E+T
E → E+E T → F|T*F
E → E*E F → （E）|i
E → (E) 规定算符优先性和结合性
THSS 44100593 2024 / 6A216
48
（上下文无关文法）句型的分析
句型分析就是识别一个符号串是否为某文法的句型，
是某个推导的构造过程。
在语言的编译实现中，把完成句型分析的程序称为
分析程序或识别程序。分析算法又称识别算法。
从左到右的分析算法，即总是从左到右地识别输入
符号串，首先识别符号串中的最左符号，进而依
次识别右边的一个符号，直到分析结束。
THSS 44100593 2024 / 6A216
49
句型的分析算法分类
分析算法可分为：
自上而下分析法：
从文法的开始符号出发，反复使用文法的产生式，
寻找与输入符号串匹配的推导，或者说，为输入
串寻找一个最左推导。
自下而上分析法：
从输入符号串开始，逐步进行归约，直至归约到
文法的开始符号。
 
THSS 44100593 2024 / 6A216
50
自上而下的语法分析
例：文法G： S → cAd
A → ab
A → a
识别输入串w=cabd是否为该文法的句子
S S S
c A d c A d
a b
推导过程：S → cAd cAd → cabd
THSS 44100593 2024 / 6A216
51
自下而上的语法分析
例：文法G： S → cAd
A → ab
A → a
识别输入串w=cabd是否为该文法的句子
S
A A
c a b d c a b d c a b d
归约过程构造的推导： cAd → cabd S → cAd
THSS 44100593 2024 / 6A216
52
(1) S →cAd (2) A →ab (3) A → a 
识别输入串w=cad是否为该文法的句子
若S → cAd 后选择(2)扩展A，S →
cAd → cabd
那将会？
w的第二个符号可以与叶子结点a
得以匹配，但第三个符号却不能
与下一叶子结点d匹配
？宣告分析失败（其意味着，识别
程序不能为串cad构造语法树，
即cad不是句子）
-显然是错误的结论。
导致失败的原因是在分析中对A的
选择不是正确的。
S
c A d
a b
这时应该回溯，把A为根的子树剪
掉，扫描过的输入串中的a吐出来,
再试探用产生式（3）
自上而下的语法分析
THSS 44100593 2024 / 6A216
53
(1)S → cAd (2) A → ab (3)A → a
识别输入串w=cabd是否为该文法的句子
对串cabd的分析中，如果不是选择ab
用产生式(2),而是选择a用产生式(3)
将a归约到了A，那么在c A b d
中无法找到一个可归约串了，最终就
达不到归约到S的结果，因而也无
从知道cabd是一个句子
c a b d
c A b d
a
自下而上的语法分析
THSS 44100593 2024 / 6A216
54
文法使用中的一些说明
限制化简文法
文法中不含有有害规则和多余规则
有害规则：形如U→U的产生式。会引起文法的二义性
多余规则：指文法中任何句子的推导都不会用到的规则
 文法中不含有不可到达和不可终止的非终结符
1）文法中某些非终结符不在任何规则的右部出现，该非终
结符称为不可到达。
2）文法中某些非终结符，由它不能推出终结符号串，该非
终结符称为不可终止。
THSS 44100593 2024 / 6A216
55
对于文法G[S]，为了保证任一非终结符A在句子推导中出现，
必须满足如下两个条件：
1. A必须在某句型中出现
 即有S => αAβ，其中α，β属于V
*
2. 必须能够从A推出终结符号串t来
 即A => t，其中t∈VT
*
*
*
THSS 44100593 2024 / 6A216
56
化简文法
• 例：G[S] ： 1) S→Be
2) B→Ce
3) B→Af
4) A→Ae
5) A→e
6) C→Cf
7) D→f
D为不可到达 (产生式7)
 C为不可终止 (产生式6)
 产生式 2），6），7）为多余规则应去掉。
THSS 44100593 2024 / 6A216
57
CFG 中的ε规则
上下文无关文法中某些规则可具有形式A→ε，称这
种规则为ε规则
因为ε规则会使得有关文法的一些讨论和证明变得复
杂,有时会限制这种规则的出现
两种定义的唯一差别是ε句子在不在语言中
如果语言L有一个有穷的描述，则L1
=L∪｛ε｝也同
样有一个有穷的描述。并且可以证明，若L是上
下文有关语言、上下文无关语言或正规语言，则
L∪｛ε｝和L-｛ε｝分别是上下文有关语言、上
下文无关语言和正规语言。
THSS 44100593 2024 / 6A216
58
Grammatical Inference （文法推断 ）
文法推断指的是 
从语言的有限信息(输入)出发，
 通过一个归纳推断过程，
最终得到语言的文法描述(输出)。
输入信息一般包含
正例样本集，反例样本集，其它附加信息。 
2023 Rabat
THSS 44100593 2024 / 6A216
THSS 44100593 2024 / 6A216
60
Conclusions
1、编译器样例
2、形式语言
3、语法树
4、句型分析
5、文法化简
THSS 44100593 2024 / 6A216
61
Conclusions
Lexical Analyzer
Syntax Analyzer
Semantic Analyzer
Intermediate Code Generator
Code Optimizer
code generator
position:= initial + rate * 60
<id,1> <=> <id,2> <+> <id,3> <*> <60>
:=
+
*
<id,1>
<id,2>
<id,3> 60
:=
+
*
60
inttoreal
temp1 := inttoreal(60)
temp2 := id3 *temp1
temp3 := id2 +temp2
id1 := temp3
temp1 := id3 *60.0
id1 := id2 + temp1
MOVF id3, R2
MULF #60.0, R2
MOVF id2, R1
ADDF R2, R1
MOVF R1, id1
SYMBOL TABLE
position …
initial …
rate …
1
2
3
4
<id,1>
<id,2>
<id,3>
THSS 44100593 2024 / 6A216
62
推荐教学资料
◇§2 A Simple Syntax-Directed Translator
◇§3.3.1 Strings and Languages
◇§3.3.2 Operations on Languages
◇§4.2 Context-Free Grammars
THSS 44100593 2024 / 6A216
63
Thank you!
THSS 44100593 2024 / 6A-216
1
本次课程是
线下教学
请现场的同学们：
打开雨课堂，点击页面右下角喇叭
按钮调至静音状态
THSS 44100593 2024 / 6A-216
Chap. 3 Lexical Analysis
Chaokun Wang
IISE@Tsinghua
THSS 44100593 2024 / 6A-216
3
Outline
• Lexical Analyzer*
– RE, RE~RG
• Finite Automata Concepts
– Finite Automata
– Non-Deterministic and Deterministic FA
– Conversion Process
• Regular Expressions to NFA
• NFA to DFA
• Minimizing the Number of States of a DFA
• From a RE to a DFA*
• Lexical Analyzer Generators* 
– Lex/ANTLR
THSS 44100593 2024 / 6A-216
int gcd(int a, int b)
{
while (a != b) {
if (a > b) a -= b;
else b -= a;
}
return a;
}
i n t sp g c d ( i n t sp a , sp i n t sp b ) nl {
nl sp sp w h i l e sp ( a sp ! = sp b ) sp { nl sp
sp sp sp i f sp ( a sp > sp b ) sp a sp - = sp b
; nl sp sp sp sp e l s e sp b sp - = sp a ; nl sp sp
} nl sp sp r e t u r n sp a ; nl } nl
Text file is a sequence of characters
What the Lexical Analyzer Sees
THSS 44100593 2024 / 6A-216
Whitespace, comments removed.
A stream of tokens.
Lexical Analysis Gives Tokens
<id, pointer to symbol￾table entry for gcd>
i n t sp g c d ( i n t sp a , sp i n t sp b ) nl {
nl sp sp w h i l e sp ( a sp ! = sp b ) sp { nl sp
sp sp sp i f sp ( a sp > sp b ) sp a sp - = sp b
; nl sp sp sp sp e l s e sp b sp - = sp a ; nl sp sp
} nl sp sp r e t u r n sp a ; nl } nl
THSS 44100593 2024 / 6A-216
6
Lexical Analyzer in Perspective
lexical 
analyzer parser
source 
program
token
get next 
token
Important Issue: 
What are Responsibilities of each Box ?
Focus on Lexical Analyzer and Parser.
symbol 
table
THSS 44100593 2024 / 6A-216
7
Lexical Analyzer in Perspective
• LEXICAL ANALYZER
– Scan Input
– Remove WS, NL, …
– Identify Tokens
– Create Symbol Table
– Insert Tokens into ST
– Read info from ST
– Generate Errors
– Send Tokens to Parser
• PARSER
– Perform Syntax Analysis
– Actions Dictated by Token 
Order
– Create Abstract Rep. of 
Source
– Update Symbol Table Entries
– Generate Errors
– And More…. (We’ll see later)
THSS 44100593 2024 / 6A-216
8
Lexical Analysis is a Separate Phase
• Separation of Lexical Analysis From Parsing 
• Presents a Simpler Conceptual Model
– A parser embodying the conventions for comments and 
white space is significantly more complex than one that can 
assume comments and white space have already been 
removed by lexical analyzer.
• Separation Increases Compiler Efficiency
– Specialized buffering techniques for reading input 
characters and processing tokens…
• Separation Promotes Portability.
– Input alphabet peculiarities and other device-specific 
anomalies can be restricted to the lexical analyzer.
THSS 44100593 2024 / 6A-216
9
Tokens, Patterns, and Lexemes
• A token (词法单元/记号) is a classification of lexical units
– a pair consisting of 
• a token name (词法单元名)
• an optional attribute value (可选属性值)
– token names: id and num
• Lexemes (词素) are the specific character strings that 
make up a token
– For example: abc and 123
• Patterns (模式) are rules describing the set of lexemes 
belonging to a token
– For example: “letter followed by letters and digits” and “non￾empty sequence of digits”
THSS 44100593 2024 / 6A-216
Basic Terminology
Token Sample Lexemes Informal Description of Pattern
const
if
relation
id
num
literal
const
if
<, <=, =, < >, >, >=
pi, count, D2
3.1416, 0, 6.02E23
“core dumped”
const
if
< or <= or = or < > or >= or >
letter followed by letters and digits
any numeric constant
any characters between “ and ” except “
Classifies 
Pattern
Actual values are critical. Info is :
1.Stored in symbol table
2.Returned to parser
10
THSS 44100593 2024 / 6A-216
Attributes for Tokens
Tokens influence parsing decision; the attributes influence 
the translation of tokens.
Example: R = M + C ** 5
<id, pointer to symbol-table entry for R>
<assign_op, >
<id, pointer to symbol-table entry for M>
<plus_op, >
<id, pointer to symbol-table entry for C>
<exp_op, >
<num, integer value 5>
11
THSS 44100593 2024 / 6A-216
Lexical Errors
• Error Handling is very localized, with Respect to 
Input Source 
• For example: whil ( x = 0 ) do 
generates no lexical errors in PASCAL
• Possible error recovery actions:
– Deleting or Inserting Input Characters
– Replacing or Transposing Characters
• Handling Lexical Errors
• Buffer pair
12
THSS 44100593 2024 / 6A-216
Regular Definitions
We may give names to regular expressions and to define regular 
expression using these names as if they were symbols.
Let Σ is an alphabet of basic symbols. The regular definition is a 
sequence of definitions of the form
d1→ r
1 
d2→ r
2 
. . .
dn→ r
n
Where,
each di
is a distinct name, and
each ri
is a regular expression over the symbols in 
Σ  {d1
, d2
, …, di-1
}
13
THSS 44100593 2024 / 6A-216
Towards Token Definition
Regular Definitions: Associate names with Regular Expressions
For Example : PASCAL IDs
letter → A | B | C | … | Z | a | b | … | z
digit → 0 | 1 | 2 | … | 9 
id → letter ( letter | digit )
*
Shorthand Notation:
“+” : one or more r* = r+ | ε (Kleene) & r
+ = r r
*
(Positive)
“?” : zero or one r?=r | ε
[range] : set range of characters (replaces “|” )
[A-Z] = A | B | C | … | Z
Example Using Shorthand : PASCAL IDs
id → [A-Za-z][A-Za-z0-9]*
14
THSS 44100593 2024 / 6A-216
Token Recognition
How can we use concepts developed so far to assist in 
recognizing tokens of a source language ?
Assume Following Tokens:
if, then, else, relop, id, num
What language construct are they used for ?
Given Tokens, What are Patterns ?
if → if
then → then
else → else
relop → < | <= | > | >= | = | <>
id → letter ( letter | digit )
*
num → digit + (. digit +
) ? ( E(+ | -) ? digit +
) ?
What does this represent ?
Grammar:
stmt → |if expr then stmt
|if expr then stmt else stmt
|ε
expr → term relop term | term
term → id | num
15
THSS 44100593 2024 / 6A-216
Example : All RELOPs
start <
0
other
=
6 7
8
return(relop, LE)
5
4
>
=
1 2
3
other
>
=
*
*
return(relop, NE)
return(relop, LT)
return(relop, EQ)
return(relop, GE)
return(relop, GT)
16
THSS 44100593 2024 / 6A-216
Constructing Transition Diagrams for Tokens
• Transition Diagrams (TD) are used to represent the 
tokens
• As characters are read, the relevant TDs are used to 
attempt to match lexeme to a pattern
• Each TD has:
• States : Represented by Circles
• Actions : Represented by Arrows between states
• Start State : Beginning of a pattern (Arrowhead)
• Final State(s) : End of pattern (Concentric Circles)
17
THSS 44100593 2024 / 6A-216
18
Finite Automata (有限状态自动机)
Finite Automata : A recognizer that takes an input 
string & determines whether it’s a 
valid sentence of the language
THSS 44100593 2024 / 6A-216
19
Non-Deterministic Finite Automata
An NFA is a mathematical model that consists of :
• S, a set of states
• Σ, the symbols of the input alphabet
• move, a transition function. 
• move(state, symbol) → set of states
• move : S × Σ{ε} → Pow(S)
• A state, s0 ∈ S, the start state
• F 二 S, a set of final or accepting states.
THSS 44100593 2024 / 6A-216
20
NFAs & DFAs
Non-Deterministic Finite Automata (NFAs) easily
represent regular expression, but are somewhat less 
precise.
Deterministic Finite Automata (DFAs) require more 
complexity to represent regular expressions, but offer 
more precision.
Non-Deterministic : Has more than one alternative action 
for the same input symbol. 
Deterministic(确定) : Has at most one action for a given 
input symbol. 
Both types are used to recognize regular expressions.
THSS 44100593 2024 / 6A-216
21
Direct Simulation of an NFA
s ← s0
c ← nextchar;
while c ≠ eof do
s ← move(s,c);
c ← nextchar;
end;
if s is in F then return “yes”
else return “no”
S ← ∈-closure({s0})
c ← nextchar;
while c ≠ eof do
S ← ∈-closure(move(S,c));
c ← nextchar;
end;
if S∩F≠⑦ then return “yes”
else return “no”
DFA
simulation
NFA
simulation
THSS 44100593 2024 / 6A-216
Some Points
√ Finite Automata Concepts
√ Finite Automata
√ Non-Deterministic and Deterministic FA
√ Conversion Process
√ Regular Expressions to NFA
√ NFA to DFA
√ Minimizing the Number of States of a DFA
√ From RE to DFA Directly
22
THSS 44100593 2024 / 6A-216
23
From Regular Expression to DFA Directly
• The important states of an NFA are those without an 
ε-transition, that is if
move(s, a) ≠ ⑦ for some a then s is an important 
state
• The subset construction algorithm (NFA -> DFA) 
uses only the important states when it determines
ε-closure(move(T,a)) 
THSS 44100593 2024 / 6A-216
24
From RE to DFA Directly (Algorithm)
1. Augment the regular expression r with a special end 
symbol # 
- to make accepting states important
- the new expression is r#
2. Construct a syntax tree for r#
3. Traverse the tree to construct functions 
- nullable
- firstpos
- lastpos
- followpos
THSS 44100593 2024 / 6A-216
25
From RE to DFA Directly
*
|
1
a
2
b
3
a
4
b
5
b
#
6
concatenation
closure
alternation
position
number
(for leafs ≠ε)
Construct syntax tree of (a | b)*abb#
THSS 44100593 2024 / 6A-216
26
RE → DFA Directly: Annotating the Tree
• nullable(n): the subtree at node n generates 
languages including the empty string
• firstpos(n): set of positions that can match the first 
symbol of a string generated by the subtree at node 
n
• lastpos(n): the set of positions that can match the 
last symbol of a string generated be the subtree at 
node n
• followpos(i): the set of positions that can follow 
position i in the tree
THSS 44100593 2024 / 6A-216
27
RE → DFA Directly: Annotating the Tree
Node n nullable(n) firstpos(n) lastpos(n)
Leaf ε true ⑦ ⑦
Leaf i false {i} {i}
|
/ \
c1 c2
nullable(c1
)
or
nullable(c2
)
firstpos(c1
)

firstpos(c2
)
lastpos(c1
)

lastpos(c2
)
•
/ \
c1 c2
nullable(c1
) 
and
nullable(c2
)
if nullable(c1
) 
then firstpos(c1
)
 firstpos(c2
)
else firstpos(c1
)
if nullable(c2
) 
then lastpos(c1
)
 lastpos(c2
)
else lastpos(c2
)
*
|
c1
true firstpos(c1
) lastpos(c1
)
THSS 44100593 2024 / 6A-216
28
RE → DFA Directly: followpos
for each node n in the tree do
followpos(n) := Φ
end do
for each node n in the tree do
if n is a cat-node with left child c1
and right child c2
then
for each i in lastpos(c1
) do
followpos(i) := followpos(i)  firstpos(c2
)
end do
else if n is a star-node
for each i in lastpos(n) do
followpos(i) := followpos(i)  firstpos(n)
end do
end if
end do
THSS 44100593 2024 / 6A-216
29
s0
:= firstpos(root) where root is the root of the syntax tree
Dstates := {s0
} and is unmarked
while there is an unmarked state T in Dstates do
mark T
for each input symbol a ∈ Σ do
let U be the set of positions that are in followpos(p)
for some position p in T,
such that the symbol at position p is a
if U is not empty and not in Dstates then
add U as an unmarked state to Dstates
end if
Dtran[T,a] := U
end do
end do
RE → DFA Directly: Algorithm
THSS 44100593 2024 / 6A-216
30
Detailed Example
Example - a*b (a|b)*aa
syntax tree for this regular expression: 
What is the DFA? 
Let’s construct it directly!
b
2
a
1
*
a
3
*
|
b
4
a
5
a
6
#
7
•Each leaf may a symbol / ε
•If not ε attach a unique integer
THSS 44100593 2024 / 6A-216
31
b
2
a
1
*
a
3
*
b
4
a
5
a
6
#
7
nullable
nullable
{1} {1}
{2} {2}
{3} {3} {4} {4}
{5} {5}
{6} {6}
{7} {7}
firstpos lastpos
{1} {1}
{1, 2} {2}
{3, 4} {3, 4}
{3, 4} {3, 4}
{1, 2} {2, 3, 4}
{1, 2} {5}
{1, 2} {6}
{1, 2} {7}
THSS 44100593 2024 / 6A-216
32
node followpos
1
2
3
5
4
6
7
{ 1 2 }
{ }
{ }
{ }
{ }
{ }
{ }
3 4
3 4
3 4 5
5
5
6
7
THSS 44100593 2024 / 6A-216
33
1, 2
b 3, 4,
5, 6, 7
3, 4,
5, 6
3, 4, 5
a
a
b
a
b
a
b
b
2
a
1
*
a
3
*
|
b
4
a
5
a
6
#
7
followpos:
a*b (a|b)*aa
root node的firstpos是{1,2}, and then let A={1,2}
Drans[A, a]=
Drans[A, b]=
Drans[B, a]=
Drans[B, b]=
Drans[C, a]=
Drans[C, b]=
Drans[D, a]=
Drans[D, b]=
followpos(1)={1,2} \\A
followpos(2)={3,4,5}=B
followpos(3)Ufollowpos(5)={3,4,5,6}=C
followpos(4)={3,4,5} \\B
followpos(3)Ufollowpos(5)Ufollowpos(6)
={3,4,5,6,7}=D
followpos(4)={3,4,5} \\B
followpos(3)Ufollowpos(5)Ufollowpos(6)
={3,4,5,6,7} \\D
followpos(4)={3,4,5} \\B
node followpos
1 {1,2}
2 {3,4,5}
3 {3,4,5}
4 {3,4,5}
5 {6}
6 {7}
7 -
THSS 44100593 2024 / 6A-216
34
RE → DFA Directly: 2nd Example
{6} {1, 2, 3}
{5} {1, 2, 3}
{4} {1, 2, 3}
{3} {1, 2, 3}
{1, 2} {1, 2} *
{1, 2} {1, 2} |
{1} {1} a {2} {2} b
{3} {3} a
{4} {4} b
{5} {5} b
{6} {6} #
nullable
firstpos lastpos
1 2
3
4
5
6
Construct syntax tree of (a | b)*abb#
THSS 44100593 2024 / 6A-216
35
RE → DFA Directly: 2nd Example
1,2,3 start a 1,2,
3,4
1,2,
3,6
1,2,
3,5
b b
b b
a
a
a
Node followpos
1 {1, 2, 3}
2 {1, 2, 3}
3 {4}
4 {5}
5 {6}
6 -
firstpos(root)={1,2,3} \\{1,2,3}
Drans[{1,2,3}, a]=followpos(1) followpos(3)
={1,2,3,4} \\{1,2,3,4}
Drans[{1,2,3}, b]=followpos(2)={1,2,3} 
Drans[{1,2,3,4}, a]=followpos(1) followpos(3)={1,2,3,4}
Drans[{1,2,3,4}, b]= followpos(2)  followpos(4)
={1,2,3,5} \\{1,2,3,5}
Drans[{1,2,3,5}, a]=followpos(1) followpos(3)={1,2,3,4}
Drans[{1,2,3,5}, b]=followpos(2)  followpos(5)
={1,2,3,6} \\{1,2,3,6}
Drans[{1,2,3,6}, a]=followpos(1) followpos(3)={1,2,3,4}
Drans[{1,2,3,6}, b]=followpos(2)={1,2,3}
a
1
b
2
a
3
b
4
b
5
#
6
THSS 44100593 2024 / 6A-216
36
Optimizing Finite Automata 
• Table Compaction 
– Two dimensional arrays provide fast 
access
– Table size may be a concern (10KB to 
100KB)
– Table compression techniques
• Compressing by eliminating 
redundant rows
• Pair-compressed transition tables
THSS 44100593 2024 / 6A-216
37
• A typical transition table has many identical 
columns and some identical rows.
a b c … 1 2 … =
1 1 1 1 2 2 5
2 1 1 1 2 2 5
3 2 2 2 3 3 4
4 3 3 3 4 4 4
5 2 2 2 4 4 7
6 3 3 3 4 4 4
7 4 4 4 3 3 6
8 4 4 4 3 3 6
THSS 44100593 2024 / 6A-216
38
1 2 5
2 3 4
3 4 4
2 4 7
4 3 6
a b c …. 1 2 3 …. =
1 1 1….. 2 2 2 ….. 3
1 1
2 1
3 2
4 3
5 4
6 3
7 5
8 5 
We may create a much smaller transition table 
with indirect row and column maps. Table is 
now accessed as T[ rmap[s], cmap[c] ].
THSS 44100593 2024 / 6A-216
39
Sparse table techniques
0
1
2
3
4
5
2 a | 4 c | 6
3 b | 1 ( | 2 = | 5
THSS 44100593 2024 / 6A-216
Example : All RELOPs （Review）
start <
0
other
=
6 7
8
return(relop, LE)
5
4
>
=
1 2
3
other
>
=
return(relop, NE)
return(relop, LT)
return(relop, EQ)
return(relop, GE)
return(relop, GT)
40
*
*
THSS 44100593 2024 / 6A-216
For Implementing Transition Diagrams
A sequence of transition diagrams can be converted into 
a program to look for the tokens specified by the 
grammar
Each state gets a segment of code
FUNCTIONS USED
•nextchar(), 
•retract(), 
•install_num(), 
•install_id(), 
•gettoken(),
•isdigit(), 
•isletter(), 
•recover()
41
THSS 44100593 2024 / 6A-216
Implementing Transition Diagrams
int state = 0, start = 0
lexeme_beginning = forward; 
token nexttoken()
{ while(1) {
switch (state) {
case 0: c = nextchar();
/* c is lookahead character */
if (c== blank || c==tab || c== newline) {
state = 0;
lexeme_beginning++;
/* advance 
beginning of lexeme */
}
else if (c == ‘<‘) state = 1;
else if (c == ‘=‘) state = 5;
else if (c == ‘>’) state = 6;
else state = fail();
break;
… /* cases 1-8 here */
start <
0
other
=
6 7
8
5
4
>
=
1 2
3
other
>
=
*
*
repeat
until
a “return”
occurs
THSS 44100593 2024 / 6A-216
• Let P1
, P2
, … , Pn be Lexer patterns 
(regular expressions for valid tokens in prog. lang.)
• Construct N(P1
), N(P2
), … N(Pn
)
• Note: accepting state of N(Pi
) will be marked by Pi
• Construct NFA:
∈
∈
∈
N(P1
)
N(P2
)
N(Pn
)
• Lexer applies 
conversion 
algorithm to 
construct DFA 
that is equivalent!
43
Pulling Together Concepts
THSS 44100593 2024 / 6A-216
The Lex and Flex Scanner Generators
• Lex: a tool for automatically generating a lexer or 
scanner given a lex specification (.l file)
• A lexer or scanner is used to perform lexical 
analysis, or the breaking up of an input stream into 
meaningful units, or tokens.
• For example, consider breaking a text file up into 
individual words. 
• Lex and its newer cousin flex are scanner 
generators
• Systematically translate regular definitions into C 
source code for efficient scanning
• Generated code is easy to integrate in C 
applications
44
THSS 44100593 2024 / 6A-216
Creating a Lexical Analyzer with Lex/Flex
lex or flex
compiler
lex
source
program
lex.l
lex.yy.c
input
stream
C
compiler
a.out sequence
of tokens
lex.yy.c
a.out
45
THSS 44100593 2024 / 6A-216
Lex Specification
• A lex specification consists of three parts:
regular definitions, C declarations in %{ %}
%%
translation rules
%%
user-defined auxiliary procedures
• The translation rules are of the form:
p1
{ action1
}
p2
{ action2
}
…
pn
{ actionn
}
46
THSS 44100593 2024 / 6A-216
Regular Expressions in Lex
x match the character x
\. match the character .
“string”match contents of string of characters
. match any character except newline
^ match beginning of a line
$ match the end of a line
[xyz] match one character x, y, or z (use \ to escape -) 
[^xyz]match any character except x, y, and z
[a-z] match one of a to z
r* closure (match zero or more occurrences)
r+ positive closure (match one or more occurrences)
r? optional (match zero or one occurrence)
r1
r2 match r1
then r2
(concatenation)
r1|r2 match r1 or r2
(union)
( r ) grouping
r1/r2 match r1 when followed by r2
{d} match the regular expression defined by d
47
THSS 44100593 2024 / 6A-216
Example Lex Specification 1
%{
#include <stdio.h>
%}
digit [0-9]
letter [A-Za-z]
id {letter}({letter}|{digit})*
%%
{digit}+ { printf(“number: %s\n”, yytext); }
{id} { printf(“ident: %s\n”, yytext); }
. { printf(“other: %s\n”, yytext); }
%%
main()
{ yylex(); 
}
Regular
definitions Translation
rules
48
THSS 44100593 2024 / 6A-216
49
%{ /* definitions of manifest constants */
#define LT (256)
…
%}
delim [ \t\n]
ws {delim}+
letter [A-Za-z]
digit [0-9]
id {letter}({letter}|{digit})*
number {digit}+(\.{digit}+)?(E[+|-]?{digit}+)?
%%
{ws} { }
if {return IF;}
then {return THEN;}
else {return ELSE;}
{id} {yylval = install_id(); return ID;}
{number} {yylval = install_num(); return NUMBER;}
“<“ {yylval = LT; return RELOP;}
“<=“ {yylval = LE; return RELOP;}
“=“ {yylval = EQ; return RELOP;}
“<>“ {yylval = NE; return RELOP;}
“>“ {yylval = GT; return RELOP;}
“>=“ {yylval = GE; return RELOP;}
%%
int install_id()
…
Return
token to
parser
Token
attribute
Install yytext as
identifier in symbol table
Example Lex Specification 2
THSS 44100593 2024 / 6A-216
• Designing Lexical Analyzer Generator
Reg. Expr. → NFA construction
NFA → DFA conversion
DFA simulation for lexical analyzer
• Recall Lex Structure
Pattern Action
Pattern Action
… …
- Each pattern recognizes lexemes
- Each pattern described by regular expression
e.g.
∈
∈
∈
etc.
(abc)*ab
(a | b)*abb
Recognizer!
50
Lex Specification → Lexical Analyzer
THSS 44100593 2024 / 6A-216
Pictorially
Lex
Specification
Lex 
Compiler
Transition 
Table
(a) Lex Compiler
FA 
Simulator
Transition 
Table
lexeme input buffer
(b) Schematic lexical analyzer
51
THSS 44100593 2024 / 6A-216
ANTLR
• ANother Tool for Language Recognition
• Terence Parr 
• Prof. of Computer Science at the 
University of San Francisco
• Language tool that provides a framework for 
constructing recognizers, interpreters, compilers, 
and translators from grammatical descriptions 
containing actions in a variety of target languages
• Provides excellent support for tree construction, tree 
walking, translation, error recovery, and error 
reporting
THSS 44100593 2024 / 6A-216
What does ANTLR do?
• Generates (the source code for) language 
processing tools from a grammatical description
• Commonly categorised as a compiler generator or 
compiler compiler in the tradition of tools.
• ANTLR can generate the source code for various 
tools that can be used to analyze and transform 
input in the language defined by the input grammar
• The basic types of language processing tools that 
ANTLR can generate are Lexers (a.k.a scanners, 
tokenizers), Parsers and TreeParsers (a.k.a tree 
walkers, c.f. visitors). 
THSS 44100593 2024 / 6A-216
Tools
54
• Lex / Yacc
• FLex / Bison
• JFLex / CUP
• ANTLR
• JavaCC
THSS 44100593 2024 / 6A-216
◇ Relating NFAs/DFAs /Conversion to 
Lexical Analysis
LEX / ANTLR ...
◇ LEX / ANTLR ...
Lexical Analyzer Generators
◇ Lexical Analyzer Generators
◇ Lexical Analyzer
55
Conclusions
◇ From a RE to a DFA directly
THSS 44100593 2024 / 6A-216
56
Conclusions
THSS 44100593 2024 / 6A-216
57
推荐教学资料
◇ 熟悉 Lex/Flex 及 ANTLR
◇§3.1 - 3.9
◇§ 2 Using Lex. Lex& Yacc. 2nd Edition
◇Part I: Introducing ANTLR and
Computer Language. The Definitive
ANTLR 4 Reference
THSS 44100593 2024 / 6A-216
58
Happy National Day!
Thank you!
THSS 44100593 2024/ 6A-216
本次课程是
线下教学
请现场的同学们：
打开雨课堂，点击页面右下角喇叭
按钮调至静音状态
THSS 44100593 2024/ 6A-216
思维导图
2
THSS 44100593 2024/ 6A-216
3
THSS 44100593 2024/ 6A-216
Chapter 4
Syntax Analysis (LL)
王朝坤
IISE@Tsinghua
THSS 44100593 2024/ 6A-216
Outline
5
递归下降 LL(1) 分 析 *
◇ 递归下降LL(1)分析*
语法分析的基本思想 *
◇ 语法分析的基本思想*
预测分析
◇ 预测分析
带回溯的自顶向下分析
◇ 带回溯的自顶向下分析
◇ LL(1)文法**
◇First集；Follow集
表驱动 LL(1) 分 析 *
◇ 表驱动LL(1)分析* 文法变换 *
◇ 文法变换*
错误处理
◇ 错误处理
THSS 44100593 2024/ 6A-216
◇ 语法分析程序（Parser）的作用
− 分析源程序的单词流是否符合语言的语法规则
− 报告语法错误
− 产生源程序的语法分析结果，
以语法分析树或与之等价的形式体现出来
◇ 语法规则描述工具
− 通常是一种上下文无关文法
− 语法分析的核心即为针对上下文无关文法的
 句型分析
基本思想
6
THSS 44100593 2024/ 6A-216
基本思想
− 句型分析 
 对任意上下文无关文法G = (V ，T ，P，S ) 
和任意w ∈ T *，是否有w ∈ L(G)？ 若成立，
 则给出分析树或（最左）推导步骤；否则，
 进行报错处理。
− 三种实现途径 
 通用分析（Cocke-Younger-Kasami算法）
 自顶向下（top-down）分析
 自底向上（bottom-up）分析
◇ 语法分析
7
THSS 44100593 2024/ 6A-216
− 从文法开始符号出发进行推导；每一步推导
 都获得文法的一个句型；直到产生出一个句
 子，恰好是所期望的终结符串
− 每一步推导是对当前句型中剩余的某个非终
 结符进行扩展，即用该非终结符的一个产生
 式的右部替换该非终结符
− 如果不存在任何一个可以产生出所期望的终
 结符串的推导，则表明存在语法错误
◇ 自顶向下分析思想
基本思想
8
THSS 44100593 2024/ 6A-216
◇ 自顶向下分析举例
S
→ AB
→ aAB
→ aAb
→ aaAb
→ aaaAb
→ aaab
文法 G（S）:
S → AB
A → aA | ε
B → b | bB
− 单词序列 aaab 的一个自顶向下分析过程
基本思想（例）
（S → AB）
（A → aA）
（B → b）
（A → aA）
（A → aA）
（A → ε ）
9
THSS 44100593 2024/ 6A-216
− 两类非确定性 
 在每一步推导中，选择哪一个非终结符、
 哪一个产生式都可能是非确定的
 分析成功的结果：得到一个推导
◇ 一般方法
带回溯的自顶向下分析
10
THSS 44100593 2024/ 6A-216
◇ 举例
S
→ AB
→ aAB
→ aAbB
→ aaAbB
→ aaaAbB
→ aaabB
……
复杂度很高
 失败条件较复杂
文法 G（S）:
（1）S → AB
（2）A → aA
（3）A → ε
（4）B → b
（5）B → bB
− 单词序列 aaab 的一个自顶向下分析过程
带回溯的自顶向下分析
（1）
（2）
（5）
（2）
（2）
（3）
（回溯）
11
THSS 44100593 2024/ 6A-216
− 仅有产生式选择是非确定的
 在每一步推导中，总是对最左边的非终结符
 进行展开，但选择哪一个产生式是非确定的
 分析成功的结果：得到一个最左推导
− 原理
(1) 每个合法的句子都存在至少一个起始于
开始符号的最左推导；
− (2) 一个终结符串，只要存在一个起始于开始
符号的最左推导，它就是一个合法的句子
 从左向右扫描输入单词，失败条件较简单
◇ 改进的方法
带回溯的自顶向下分析
12
THSS 44100593 2024/ 6A-216
◇ 改进的方法举例
S
→ AB
→ aAB
→ aB
→ aAB
→ aaAB
→ aaaAB
→ aaaB
→ aaabB
→ aaaB
→ aaab
文法 G（S）:
（1）S → AB
（2）A → aA
（3）A → ε
（4）B → b
（5）B → bB
− 单词序列 aaab 的一个自顶向下分析过程
带回溯的自顶向下分析
复杂度降低
失败条件简化
（1）
（2）
（3）
（回溯）
（2）
（2）
（3）
（5）
（回溯）
（4）
（成功）
13
THSS 44100593 2024/ 6A-216
− 非终结符选择和产生式选择都是确定的
 在每一步推导中，总是对最左边的非终结符
 进行展开，且选择哪一个产生式是确定的，
 因此是一种无回溯的方法
 从左向右扫描，可能向前查看（lookahead）
 确定数目的单词
 分析成功的结果：得到唯一的最左推导
 分析条件：对文法需要有一定的限制
◇ 确定的自顶向下分析
预测分析
14
THSS 44100593 2024/ 6A-216
◇ 举例（向前查看 2 个单词）
S
→ AB
→aAB
……
→ a
nAB
→ a
nB
→ a
nbB
……
→ a
nb
m-1B
→ a
nb
m
文法 G（S）:
（1）S → AB
（2）A → aA
（3）A → ε
（4）B → b
（5）B → bB
− 单词序列 a
nb
m（n≥0,m>0）的预测分析过程
预测分析
只要向前查看 2 个
单词，就可预测分
析L(G)中所有句子
（1）
（2）
（2）
……
（3）
（5）
（5）
……
（4）
（成功）
15
THSS 44100593 2024/ 6A-216
◇ 左递归带来的问题
文法 G（S）:
（1）S → Sa
（2）S → b
− 考虑下列文法识别 ban 的分析过程
预测分析
S
→ Sa
→ Saa
→ Saaa
……
→ San
→ ban
但是：无论向前查看的单词数确定为多少，
都无法满足预测分析L(G)中所有句子的需求
需要向前查看n+1个单词，
才能确定这样的推导序列
（1）
（1）
（1）
（1）
……
（2）
16
THSS 44100593 2024/ 6A-216
◇ 要求文法不含左递归
− 例：直接左递归
预测分析
− 可以通过文法变换消除左递归
 专门讨论
− 例：间接左递归
P → Pa
P → b
……
P → Aa
A → Pb
……
17
THSS 44100593 2024/ 6A-216
◇ 左公因子带来的问题
文法 G（S）: S → abA | abB
A → a
B → b
− 如下文法需要向前查看 个单词来预测分析
 L(G)中的句子
预测分析
文法 G'（S）: S → aAb | aAc
A → a |aA
− 对于文法G' 无法确定需要向前查看多少
 个单词来预测分析 L(G) 中的句子
3
18
THSS 44100593 2024/ 6A-216
◇ 通常要求文法不含左公因子
预测分析
− 可以通过文法变换消除左公因子
 专门讨论
19
THSS 44100593 2024/ 6A-216
◇ 应用较普遍的预测分析是
 LL（1）分析
预测分析
− 要求文法一定是LL（1）文法
 专门讨论
− LL（1）分析程序既可以手工构造，
 也可以自动构造
20
THSS 44100593 2024/ 6A-216
− 第一个“L”, 代表从左（Left）向右扫描单
词
− 第二个“L”
,代表产生的是最左（Leftmost）
 推导
− “1”代表向前查看（lookahead）一个单词
◇ LL（1）的含义
LL（1） 分析
21
THSS 44100593 2024/ 6A-216
− 要求文法是LL（1）的
− 什么是LL（1）文法？
◇ 对文法的限制
LL（1） 分析
22
− First 集合
− Follow 集合
◇ 两个重要概念
An Example: 
S => abcAde; 
a ∈ first(S);
d ∈ follow(A).
*
THSS 44100593 2024/ 6A-216
− 定义
 设 G =（VT，VN，P，S）是上下文无关文法
 对 α ∈(VT VN
)
*
，
 First（α）= { a|α → aβ, a ∈VT
, β ∈(VT VN
)
*
}
若α →ε 则规定ε∈First（α）
◇ First 集合
LL（1） 分析
*
*
23
THSS 44100593 2024/ 6A-216
◇ 计算 First 集合
LL（1） 分析
设α = X∈VN  VT
, 则First(X) 可按如下步骤计算:
− 若X∈VT
,则First(X)={X}
− 若X→ε 也是一个产生式,则把 ε 也加到First(X)中；
− 若X∈VN ,且有产生式X→a…，a∈VT
, 则把a加入到First(X)中; 
若X → Y1Y2…YK 是一个产生式,Y1
,Y2
,…,Yk ∈VN  VT
, 
1) 对于任何 j:1≤j≤i-1, 1≤i ≤k, First(Yj
)都含有ε, 但 First(Yi
)不含ε, 则
把 First(Yj
)中的所有非ε元素和First(Yi
)中的所有元素都加到First(X)
中;
2) 特别是,对于任何 j:1≤j≤k, First(Yj
)都含ε，则除First(Yj
)中的非ε元
素外，把ε也加到First(X)中.
24
THSS 44100593 2024/ 6A-216
◇ 计算 First 集合
LL（1） 分析
S ⇨ ES’
S’ ⇨ ε | +S
E ⇨ number | (S)
FIRST(S) = {number, ( }
FIRST(S’) = {ε, + }
FIRST(E) = { number, ( } 25
设α = X1X2
...Xn
,则First(α) 可按如下步骤计算:
− 若对于任何j:1≤j≤i-1<n, 有
 ε ∈First(Xj
)Λε ∈First(Xi
), 
则 First(α) =  First(Xj
)  First(Xi
) − {ε}=  First(Xj
)− {ε}
− 若所有的j,1≤j ≤n, 都有ε ∈First(Xj
),
则 First(α) =  First(Xi
)
j=1
i-1
j=1
n
i
j=1
THSS 44100593 2024/ 6A-216
− 定义
 设 G =（VT，VN，P，S）是上下文无关文法
 对 A∈VN，
 Follow(A)={a|S →αAβ且a∈First(β)，
 α∈(VT VN
)*
, β ∈(VT VN
)
+
}
若S → αAβ, 且 β→ε, 则规定
 #∈Follow（A）
 （# 代表输入单词序列右边的结束符）
◇ Follow 集合
LL（1） 分析
*
* *
26
THSS 44100593 2024/ 6A-216
◇ 计算 Follow 集合
LL（1） 分析
− 对于文法的开始符号S，置#于Follow(S) 中;
− 若A →αBβ是一个产生式,则把 First(β)−{ε}
加至 Follow(B) 中;
− 若 A→αB 是一个产生式, 或A→αBβ是一个
 产生式而β→ ε （即ε∈First(β)），
 则把 Follow(A)加至Follow(B)中．
*
S ⇨ ES’
S’ ⇨ ε | +S
E ⇨ number | (S)
FOLLOW(S) = { #, ) }
FOLLOW(S’) = FOLLOW(S)={ #, ) }
FOLLOW(E) = (FIRST(S’) -{ε}) FOLLOW(S)
= { +, # , ) } 27
THSS 44100593 2024/ 6A-216
◇ 例：计算 First 和 Follow 集合
LL（1） 分析
文法 G（S）:
（1）S → AB
（2）A → Da|ε
（3）B → cC
（4）C → aADC |ε
（5）D → b|ε
First(D) =
First(C) =
First(B) =
First(A) =
First(S) =
Follow(S) =
Follow(C) =
Follow(A) =
Follow(B) =
Follow(D) =
{b, ε}
{a, ε}
{c}
{b,a, ε}
{b,a,c}
{#}
{#}
{c,b,a, #}
{#}
{a,#}
28
THSS 44100593 2024/ 6A-216
◇ 定义： LL（1）文法
文法G是LL（1）的，当且仅当对于G的每个非终
结符A的任何两个不同产生式A→α|β，下面的
条件成立：
− First(α)∩First(β)=φ，即α 和β推导不出以同
 一个单词为首的符号串，也不会同时推导出 ε
− 假若β→ ε，那么First(α)∩Follow(A)＝φ,
即α所能推出的串的首符号不应在Follow(A）
 中．
LL（1） 分析
*
29
THSS 44100593 2024/ 6A-216
◇ 举例：判断如下文法G（S）是否是LL(1)文法
LL（1） 分析
文法 G（S）:
（1）S → AB
（2）A → Da|ε
（3）B → cC
（4）C → aADC |ε
（5）D → b|ε
First(D) = {b, ε}
First(C) = {a, ε}
First(B) = {c}
First(A) = {b,a, ε}
First(S) = {b,a,c}
Follow(S) = {#}
Follow(C) = {#}
Follow(A) = {c,b,a, #}
Follow(B) = {#}
Follow(D) = {a,#}
For A：first(Da) ∩ follow(A)={b,a} ∩{c,b,a,#} ={b,a} 
:G(S)不是 LL(1)文法 30
THSS 44100593 2024/ 6A-216
◇ LL(1)文法的性质
 LL(1)文法是无二义的
 LL(1)文法是无左递归的
 LL(1)文法是无左公因子的
 
 除了利用定义外，有时可以利用这些性质
 判定某些文法不是LL(1)的
LL（1） 分析
31
THSS 44100593 2024/ 6A-216
− 递归下降 LL（1）分析
 （递归下降分析：非终结符 子程序）
◇ LL（1）分析的实现
− 表驱动 LL（1）分析
 借助于预测分析表和一个下推栈
LL（1） 分析
32
THSS 44100593 2024/ 6A-216
− 工作原理
 每个非终结符都对应一个子程序。该子程序
 的行为根据语法描述来明确：
• 每遇到一个终结符，则判断当前读入的单词是否
 与该终结符相匹配。若匹配，再读取下一个单词
 继续分析；不匹配，则进行出错处理
• 每遇到一个非终结符，则调用相应的子程序
◇ 递归下降LL(1)分析程序
递归下降 LL（1）分析
33
THSS 44100593 2024/ 6A-216
− 例 对于下列文法 （其中 function，identifier，
 parameter_list 和 statement 是非终结符）
 function → FUNC identifier ( parameter_list ) statement
◇ 非终结符对应的递归下降子程序
递归下降 LL（1）分析
void ParseFunction( )
{
MatchToken(T_FUNC); //匹配FUNC
ParseIdentifier( );
MatchToken(T_LPAREN); // 匹配 （
 ParseParameterList( );
MatchToken(T_RPAREN); // 匹配 ）
 ParseStatement( );
} 34
THSS 44100593 2024/ 6A-216
− 例 续上页
◇ 非终结符对应的递归下降子程序
递归下降 LL（1）分析
void MatchToken(int expected)
{
if (lookahead != expected) //判别当前单词是否与
 { //期望的终结符匹配
 printf("syntax error \n");
exit(0);
}
else // 若匹配,消费掉当前单词并读入下一个
 lookahead = nexttoken(); //调用词法分析程序
}
35
THSS 44100593 2024/ 6A-216
− 一般结构
 设 A 的产生式:
A → u1 | u2 | ...,
相对于非终结符A
的递归下降子程序
 ParseA的一般结
 构如右图所示
◇ 非终结符对应的
 递归下降子程序
递归下降 LL（1）分析
void ParseA()
{
switch (lookahead) {
case First(u1
):
/* code to recognize u1
*/
break;
case First(u2
):
/* code to recognize u2
*/
break;
...
case Follow(A): /* when A → ε */ 
/* usually do nothing here */
break;
default:
printf("syntax error \n");
exit(0);
}
}
36
*
THSS 44100593 2024/ 6A-216
− 例 对于下列文法
 G(S):
S → AaS | BbS| d
A → a
B → ε | c
◇ 递归下降LL(1)分析程序举例
递归下降 LL（1）分析
因为 First(AaS)={a}，First(BbS)={b, c}，以及
First(d)={d} 之间两两互不相交，同时
Follow(B) = {b} 与 First(c)={ c}不相交，
所以，G(S)是LL(1)文法
First（S）= {a, b, c , d }
First（A）= {a} 
First（B）= {ε, c }
Follow（S）= {#} 
Follow（A）= {a }
Follow（B）= {b}
37
THSS 44100593 2024/ 6A-216
− 接上例 针对文法G(S)构造的递归下降分析程序
递归下降 LL（1）分析
void ParseS( )
{ 
switch (lookahead) {
case a:
ParseA( );
MatchToken(a);
ParseS( );
break;
G(S): S → AaS | BbS| d
A → a
B → ε | c
First（S）= {a, b, c , d }
Follow（S）= {#}
case b,c:
ParseB( );
MatchToken(b);
ParseS( );
break;
case d:
MatchToken(d);
break;
default:
printf("syntax error \n") 
exit(0);
}
}
38
THSS 44100593 2024/ 6A-216
− 接上例 针对文法G(S) 构造的递归下降分析程序
递归下降 LL（1）分析
void ParseA( )
{ 
if (lookahead==a) {
MatchToken(a);
}
else {
printf("syntax error \n”);
exit(0);
}
}
First（A）= {a} 
First（B）= {ε, c }
Follow（S）= {#} 
Follow（A）= {a }
Follow（B）= {b} void ParseB( )
{ 
if (lookahead==c) {
MatchToken(c);
}
else if (lookahead==b) {
}
else {
printf("syntax error \n”);
exit(0);
}
}
G(S): S → AaS | BbS| d
A → a
B → ε | c
39
THSS 44100593 2024/ 6A-216
− 工作原理 利用预测分析表和一个下推栈实现
 （0）初始化，将符号#入栈；
 （1）文法开始符号入栈；
 （2）若栈顶为 终结符，则判断当前读入的单词是否与
 该终结符相匹配，
 (a) 若匹配，再读取下一 单词继续分析；
 (b) 不匹配，则进行出错处理；
 （3）若栈顶为非终结符，则根据该非终结符和当前
 输入单词查预测分析表，
 (a) 若相应表项中是产生式（唯一的），则将此非
 终结符出栈，并把产生式右部符号从右至左入栈；
 (b) 若表项为空，则进行出错处理；
 （4）重复（2）和（3），直到栈顶为 # 同时输入也
 遇到结束符 # 时，分析结束
◇ 表驱动LL(1)分析程序
表驱动 LL（1）分析
40
THSS 44100593 2024/ 6A-216
41
Conclusions
递归下降 LL(1) 分 析
◇ 递归下降LL(1)分析
◇ LL(1)文法
◇First 集
◇Follow 集
语法分析的基本思想
◇ 语法分析的基本思想
预测分析
◇ 预测分析
带回溯的自顶向下分析
◇ 带回溯的自顶向下分析
THSS 44100593 2024/ 6A-216
42
Conclusions
THSS 44100593 2024/ 6A-216
43
推荐教学资料
◇§4.1.1 The Role of the Parser
◇§4.3.1 Lexical Versus Syntactic Analysis 
◇§4.4.1 Recursive-Descent Parsing
◇§4.4.2 FIRST and FOLLOW
◇§4.4.3 LL(1) Grammars
THSS 44100593 2024/ 6A-216
44
Thank you!
THSS 44100593 2024/ 6A-216
Principles of Assembly 
and Compilation
汇编与编译原理
44100593
王朝坤
THSS@Tsinghua
1
THSS 44100593 2024/ 6A-216
本次课程是
线下教学
请现场的同学们：
打开雨课堂，点击页面右下角喇叭
按钮调至静音状态
THSS 44100593 2024/ 6A-216
Outline
3
文法变换 ： 提取左公因子 *
◇ 文法变换：提取左公因子*
自底向上语法分析思想
◇ 自底向上语法分析思想
◇ 句柄*
◇ 移进-归约分析
◇ 文法变换：消除左递归*
◇ 表驱动LL(1)分析*
THSS 44100593 2024/ 6A-216
− 表驱动分析程序需要的二维表M
− 表的每一行A 对应一个非终结符
− 表的每一列a 对应某个终结符或输入结束符#
− 表中的项M(A,a) 表示栈顶为A，下一个输入符
 号为a时，可选的产生式集合
− 对于LL（1）文法，可以构造出一个M(A,a) 最
 多只包含一个产生式的预测分析表，可称之为
 LL（1）分析表
− M(A,a) 不含产生式时，对应一个出错位置
◇ 预测分析表
表驱动 LL（1）分析
4
THSS 44100593 2024/ 6A-216
◇ 预测分析表的构造算法
− 对文法G的每个产生式 A→α 执行如下步骤：
（1）对每个 a ∈ First(α)，把 A→α 加入M[A,a]
（2）若 ε ∈ First(α)，则对任何 b ∈ Follow(A) ,
把 A→α 加至M[A,b]中
− 把所有无定义的M[A,a]标上“出错标志”
可以证明: 一个文法G的预测分析表不含多重入口，当且
仅当该文法是LL(1)的
表驱动 LL（1）分析
5
THSS 44100593 2024/ 6A-216
◇ 预测分析表的构造举例
− 对于下列文法G(S)：
 S → AaS | BbS| d
A → a
B → ε | c
可构造如下预测分析表：
First（S）= {a, b, c , d }
First（A）= {a} 
First（B）= {ε, c }
Follow（S）= {#} 
Follow（A）= {a }
Follow（B）= {b}
S
A
a b
B
c d #
S→AaS S→BbS S→d
A→a
B→ε B→c
表驱动 LL（1）分析
S→BbS
6
THSS 44100593 2024/ 6A-216
◇ 表驱动预测分析程序分析算法
表驱动 LL（1）分析
初始时‘#’入栈，然后文法开始符号入栈；首个输入符号读进 a ；
 flag =TRUE；
 while (flag) do {
栈顶符号出栈并放在X中；
 if (X∈VT
) {
if (X==a)
把下一个输入符号读进a;
else ERROR;
} 
else if (X==‘#’）{
if (a==‘#’) flag = FALSE;
else ERROR;
}
else if (M[X,a] == {X→X1X2…Xk
}) Xk
,XK-1
,…,X1依次进栈; 
else ERROR;
}
/*分析成功，过程完毕*／
7
THSS 44100593 2024/ 6A-216
◇ 表驱动预测分析过程举例
− 对于下列文法G(S)：
 S → AaS | BbS| d
A → a
B → ε | c
分析输入串 aabd 的过程：
表驱动 LL（1）分析
#
S
剩余的输入串
 aabd#
S
A
a b
B
c d #
S→AaS S→BbS S→d
A→a
B→ε B→c
S→BbS
8
THSS 44100593 2024/ 6A-216
◇ 表驱动预测分析过程举例
− 对于下列文法G(S)：
 S → AaS | BbS| d
A → a
B → ε | c
分析输入串 aabd 的过程：
表驱动 LL（1）分析
#
S
剩余的输入串
 aabd# a
A
S
A
a b
B
c d #
S→AaS S→BbS S→d
A→a
B→ε B→c
S→BbS
9
THSS 44100593 2024/ 6A-216
◇ 表驱动预测分析过程举例
− 对于下列文法G(S)：
 S → AaS | BbS| d
A → a
B → ε | c
分析输入串 aabd 的过程：
表驱动 LL（1）分析
#
S
剩余的输入串
 aabd# a
a
S
A
a b
B
c d #
S→AaS S→BbS S→d
A→a
B→ε B→c
S→BbS
10
THSS 44100593 2024/ 6A-216
◇ 表驱动预测分析过程举例
− 对于下列文法G(S)：
 S → AaS | BbS| d
A → a
B → ε | c
分析输入串 aabd 的过程：
表驱动 LL（1）分析
#
S
剩余的输入串
 abd# a
S
A
a b
B
c d #
S→AaS S→BbS S→d
A→a
B→ε B→c
S→BbS
11
THSS 44100593 2024/ 6A-216
◇ 表驱动预测分析过程举例
− 对于下列文法G(S)：
 S → AaS | BbS| d
A → a
B → ε | c
分析输入串 aabd 的过程：
表驱动 LL（1）分析
#
S
剩余的输入串
 bd#
S
A
a b
B
c d #
S→AaS S→BbS S→d
A→a
B→ε B→c
S→BbS
12
THSS 44100593 2024/ 6A-216
◇ 表驱动预测分析过程举例
− 对于下列文法G(S)：
 S → AaS | BbS| d
A → a
B → ε | c
分析输入串 aabd 的过程：
表驱动 LL（1）分析
#
剩余的输入串
 bd#
S
b
B
S
A
a b
B
c d #
S→AaS S→BbS S→d
A→a
B→ε B→c
S→BbS
13
THSS 44100593 2024/ 6A-216
◇ 表驱动预测分析过程举例
− 对于下列文法G(S)：
 S → AaS | BbS| d
A → a
B → ε | c
分析输入串 aabd 的过程：
表驱动 LL（1）分析
#
剩余的输入串
 bd#
S
b
S
A
a b
B
c d #
S→AaS S→BbS S→d
A→a
B→ε B→c
S→BbS
14
THSS 44100593 2024/ 6A-216
◇ 表驱动预测分析过程举例
− 对于下列文法G(S)：
 S → AaS | BbS| d
A → a
B → ε | c
分析输入串 aabd 的过程：
表驱动 LL（1）分析
#
剩余的输入串
 d#
S
S
A
a b
B
c d #
S→AaS S→BbS S→d
A→a
B→ε B→c
S→BbS
15
THSS 44100593 2024/ 6A-216
◇ 表驱动预测分析过程举例
− 对于下列文法G(S)：
 S → AaS | BbS| d
A → a
B → ε | c
分析输入串 aabd 的过程：
表驱动 LL（1）分析
#
剩余的输入串
 d#
d
S
A
a b
B
c d #
S→AaS S→BbS S→d
A→a
B→ε B→c
S→BbS
16
THSS 44100593 2024/ 6A-216
◇ 表驱动预测分析过程举例
− 对于下列文法G(S)：
 S → AaS | BbS| d
A → a
B → ε | c
分析输入串 aabd 的过程：
表驱动 LL（1）分析
#
剩余的输入串
 #
③
S
A
a b
B
c d #
S→AaS S→BbS S→d
A→a
B→ε B→c
S→BbS
17
THSS 44100593 2024/ 6A-216
文法变换
18
− LL(1)文法不含左递归和左公因子
− 许多文法在消除左递归和提取左公因子后可
 以变换为LL(1)文法
− 但不含左递归和左公因子的文法不一定都是
 LL(1)文法
◇ 文法变换 ：消除左递归、提取左公因子
THSS 44100593 2024/ 6A-216
文法变换：消除左递归
◇ 左递归消除规则
− 消除直接左递归
 对形如
 P → P α|β
的产生式，其中α非ε， α、β不以 P 开头， 
 可改写为：
 P → βQ
Q → αQ | ε
其中Q为新增加的非终结符
19
THSS 44100593 2024/ 6A-216
文法变换：消除左递归
◇ 左递归消除规则
− 消除直接左递归
 对更一般的形如
 P→Pα1|Pα2|… |Pαm|β1|β2|…|βn
的一组产生式，其中αi（1≤i≤m）不为ε，βj（1≤j≤n）
不以 P 打头， 
 可改写为：
 P→β1Q|β2Q|…|βnQ
Q → α1Q|α2Q|…|αmQ | ε
其中Q为新增加的非终结符
20
THSS 44100593 2024/ 6A-216
文法变换：消除左递归
◇ 左递归消除举例
原文法 G[ E]: 
E → E + T | T 
T → T * F | F
F → (E) | a
消除左递归后的文法 G’[ E]:
(1) E → TE’ (2) E’ → + TE’ (3) E’ → ε
(4) T → FT’ (5) T’ → * FT’ (6) T’ → ε
(7) F → (E) (8) F →a
21
THSS 44100593 2024/ 6A-216
文法变换：消除左递归
◇ 左递归消除规则
− 消除一般左递归
 对无回路(A → A) 、无ε-产生式的文法，通过下列步骤可消除
 一般左递归（包括直接和间接左递归）：
 （1）以某种顺序将文法非终结符排列A1 ,A2 , … , An
（2）for i = 1 , …, n do {
for j=1, …, i-1 do {
用Aj → α1 | α2… | αk替换掉形如 Ai → Aj
Y 的规则的右部中的
首个Aj ，得到 Ai → α1 Y| α2 Y… | α k
Y ，其中
Aj → α1 | α2… | αk 是关于Aj 的全部产生式;
}
消除Ai规则的直接左递归;
}
（3）化简由（2）得到的文法
+
22
THSS 44100593 2024/ 6A-216
文法变换：消除左递归
◇ 左递归消除举例
原文法 G[S]: S → PQ | a 
P → QS | b
Q → SP | c
非终结符排序为 S、P、Q，按照消除一般左递归的方法，进行
如下变换:
Q → SP | c 结果：
S → PQ | a 
P 
Q 
→
→
QS 
bQP
|
R
b
|aPR|cR
R → SQPR|ε
Q → PQP|aP|c
Q → QSQP| bQP| aP|c
Q → bQPR|aPR|cR
R → SQPR|ε 23
THSS 44100593 2024/ 6A-216
文法变换：提取左公因子
◇ 提取左公因子规则
− 对形如
 P → αβ| αγ
的一对产生式，可用如下三个产生式替换：
 P → αQ
Q → β | γ
其中Q为新增加的未出现过的非终结符
24
THSS 44100593 2024/ 6A-216
文法变换：提取左公因子
◇ 提取左公因子规则
− 一般含有左公因子的产生式形如
 P → αβ1|αβ2|…|αβm
|γ1|γ 2|…|γn
其中，每个γ不以α开头.
提取左公共因子，产生式改写成：
 P → αQ|γ1|γ 2|…|γn
Q → β1|β2|…|βm
25
THSS 44100593 2024/ 6A-216
文法变换：提取左公因子
− 对文法 G(S): 
S → if C t S | if C t S e S | d
C → b
提取左公因子后，可改写为文法G’(S)：
 S → if C t S A | d
A → e S | ε
C → b
◇ 提取左公因子举例
26
THSS 44100593 2024/ 6A-216
文法变换
◇ 举例：许多文法在消除左递归和提取左公因
 子后可以变换为LL(1)文法
可验证如下文法 G[E]是LL(1)文法:
(1) E → TE’ (2) E’ → + TE’
(3) E’ → ε (4) T → FT’
(5) T’ → * FT’ (6) T’ → ε
(7) F → (E) (8) F →a
27
THSS 44100593 2024/ 6A-216
文法变换
◇ 不含左递归和左公因子的文法一定是
 LL(1)文法吗？
First集 Follow集
S { if, d } { #,e }
A { e, ε } { #,e }
C { b } { t }
M[A,e] = {A→ e S，
 A→ ε }
S → if C t S 
| if C t S e S
| d
C → b
提取左公因子后：
 S → if C t S A | d
A → e S | ε
C → b
不一定！
28
THSS 44100593 2024/ 6A-216
预测分析中的错误处理
− 错误报告（error reporting）
• 栈顶的终结符与当前输入符不匹配
• 非终结符A于栈顶，面临的输入符为a，
 但分析表M的M[A,a]为空
◇ 表驱动LL(1)分析中的错误处理
29
THSS 44100593 2024/ 6A-216
预测分析中的错误处理
− 简单的应急恢复（panic-mode error recovery）
 跳过输入串中的一些符号直至遇到同步符号 
 （synchronizing token）为止
同步符号的选择：
• 把 Follow(A) 中的所有符号作为A的同步符号, 跳过
 输入串中的一些符号直至遇到这些“同步符号”，
 把A从栈中弹出，可使分析继续
• 把First(A)中的符号加到A的同步符号集，当First(A)
中的符号在输入中出现时，可根据A恢复分析
◇ 预测分析中的错误处理
30
THSS 44100593 2024/ 6A-216
ANTLR (Review)
• Language tool providing a framework to construct
– recognizers
– interpreters
– compilers
– translators
• Terence Parr, Kathleen Fisher. LL(*): the foundation 
of the ANTLR parser generator. PLDI 2011.
THSS 44100593 2024 / 6A-216
Chapter 4'
Syntax Analysis (LR)
王朝坤
IISE@Tsinghua
THSS 44100593 2024 / 6A-216
Outline
33
◇ LR(0)自动机
◇ SLR(1)分析
◇ LR分析*
◇ 自底向上语法分析思想
◇ 句柄*
◇ 移进-归约分析
◇ LR分析基础
◇ LR(1) 分析*
◇ LALR(1) 分析*
THSS 44100593 2024 / 6A-216
自底向上分析思想
− 核心问题：句型分析 
 对任意上下文无关文法G = (V ，T ，P，S ) 
和任意w ∈ T *，是否有w ∈ L(G)？ 若成立，
 则给出分析树或（最左）推导步骤；否则，
 进行报错处理。
− 三种实现途径 
通用分析（Cocke-Younger-Kasami算法）
 自顶向下（top-down）分析
 自底向上（bottom-up）分析
◇ 语法分析
右
THSS 44100593 2024 / 6A-216
− 从所要分析的终结符串开始进行归约；
− 每一步归约是在当前串中找到与某个产生式
 的右部相匹配的子串，然后将该子串用这一
 产生式的左部非终结符进行替换；如果找不
 到这样的子串，则回退到上一步归约前的状
 态，选择不同的子串或不同的产生式重试；
− 重复上一步骤，直到归约至文法开始符号；
− 如果不存在任何一个这样的归约，则表明该
 终结符串存在语法错误
◇ 自底向上分析的一般过程
自底向上分析思想
THSS 44100593 2024 / 6A-216
− 在每一步归约中，匹配哪一个位置上的子串
以及选择哪一个产生式都可能是非确定的
− 这些非确定性导致分析过程会有很高的复杂性
◇ 自底向上分析中的非确定性
自底向上分析思想
aaab
← aaaAb
← aaAb
← aAb
← aAB
← AB
← S
（ A → ε , B → b ）
（ A → aA , A → ε , B → b ）
（ A → aA , A → ε , B → b ）
（B → b , A → aA , A → ε ）
（ A → aA , A → ε , S → AB ）
（ S → AB , A → ε ）
THSS 44100593 2024 / 6A-216
− 最左归约（目标，唯一性/确定化）
− 等价于最右推导（保证了唯一性）
− 分析栈 + 输入串（实现手段：移进-归约分析）
◇ 自底向上分析中的确定化
自底向上分析思想
文法 G[S]:
(1) S → E
(2) E → E + T 
(3) E → T
(4) T → T * F
(5) T → F
(6) F → ( E )
(7) F → v
(8) F → d
v+v*d F+v*d
E+v*d
E E+T
E+F*d
→
rm
→
rm E+T*F
→
rm →
rm
→
rm →
rm
S
E+T*d
T+v*d
→
rm
→
rm
→
rm
可归约串
(7) (5) (3)
(7) (5) (8)
(4) (2) (1)
(句柄)
THSS 44100593 2024 / 6A-216
◇ 改进的方法
句柄
− 选择“可归约串”进行归约
 在实用的自底向上分析中，总是选择某个“可
 归约串”进行归约，可大大减少回溯
*
rm
− 对于文法 G = (VN
, VT
, P , S ) , 以及
 α , Y ∈(VNVT
)* , β ∈VT
*
若 S →αA β 且 A → Y ，则称
 Y 是右句型α Y β 相对于非终结符 A 的句柄
对于一个句型而言，“可归约串” 即句柄
THSS 44100593 2024 / 6A-216
◇ 举例：句柄
句柄
文法 G（S）:
（1）S → AB
（2）A → aA
（3）A → ε
（4）B → b
（5）B → bB
− 对于右边的文法G(S),
aaab 的句柄：
aaAb 的句柄：
aaaAb aaab
aaAb
S AB
aAb
Ab →
rm
→
rm
→
rm →
rm
→
rm
→
rm
ε
aA
ε
THSS 44100593 2024 / 6A-216
◇ 举例：句柄一定唯一吗？
句柄
− 对于右边的文法G(S),
aaab 的句柄：ε
 右句型aaAb的句柄：
文法 G（S）:
（1）S → AB
（2）A → aA
（3）A → aaA
（4）A → ε
（5）B → b
（6）B → bB
不唯一的原因：
G（S）是二义
文法，右句型的
最右推导有多个
aA，aaA
THSS 44100593 2024 / 6A-216
◇ 句柄的作用
自底向上分析思想
− 作为LR分析中的“可归约串”
 LR分析是bottom-up parsing的重点内容
◇ 自底向上分析的实现技术
− 移进−归约（shift-reduce）分析技术
 LR分析和算符优先分析
 均采用移进−归约分析技术
THSS 44100593 2024 / 6A-216
◇ 与自顶向下技术相比
自底向上分析思想
− 功能较强大
 原因在于推导和归约过程有如下差别：推导时仅观察
 可推导出的输入串的一部分，而归约时可归约的输入
 串整体已全部出现
− 构造较复杂
 不适合手工构造
 但存在很好的自动构造技术
 （如Yacc工具采用的LALR分析技术）
THSS 44100593 2024 / 6A-216
− 借助于一个确定的下推自动机来实现，包括一个下推栈
 （分析栈）和一个有限状态控制引擎
 下推自动机根据当前状态、下推栈当前状态、剩余输入
 单词序列来唯一确定如下动作之一，然后进入新状态：
• Reduce: 依确定的产生式序列对位于栈顶的可归约串进行归约
• Shift: 从输入序列移进一个单词
• Error: 发现语法错误，进行错误处理/恢复
• Accept: 分析成功
◇ 基本原理
移进−归约分析
- 确定的自底向上语法分析：最左归约
......AbCd efg......#
THSS 44100593 2024 / 6A-216
◇ 移进−归约分析
 过程的一个例子
移进−归约分析
文法 G[S]:
(1) S → E
(2) E → E + T 
(3) E → T
(4) T → T * F
(5) T → F
(6) F → ( E )
(7) F → v
(8) F → d
待分析输入串:
v＋v * d
+ v * d # Reduce(7) （1） v
+ v * d # Reduce(5) （2） F
v * d # （5） E + Shift
+ v * d # （3） T Reduce(3)
+ v * d # （4） E Shift
* d # （6） E + v Reduce(7)
* d # （7） E + F Reduce(5)
* d # （8） E + T Shift
d # （9） E + T * Shift
# （10） E + T * d Reduce(8)
# （11） E + T * F Reduce(4)
# （12） E + T Reduce(2)
# （13） E Reduce(1)
# （14） S Accept
v + v * d # Shift （0）
步骤 分析栈 余留输入串 动作
top
THSS 44100593 2024 / 6A-216
− 对应一个最右推导
 将分析栈中的符号
 串和余留输入串并
 置，逆向观察每一
 分析步骤，从步骤
 （14）至步骤（1）
 对应一个最右推导
◇ 成功分析的结果
移进−归约分析
+ v * d # Reduce(7) （1） v
+ v * d # Reduce(5) （2） F
v * d # （5） E + Shift
+ v * d # （3） T Reduce(3)
+ v * d # （4） E Shift
* d # （6） E + v Reduce(7)
* d # （7） E + F Reduce(5)
* d # （8） E + T Shift
d # （9） E + T * Shift
# （10） E + T * d Reduce(8)
# （11） E + T * F Reduce(4)
# （12） E + T Reduce(2)
# （13） E Reduce(1)
# （14） S Accept
（
步骤
0）
分析栈
v 
余留输入串
+ v * d # Shift
动作
− 格局
 栈内容.余留输入串
.v+v *d
← v.+v *d
← F.+v *d
← T.+v *d
← E.+ v*d
← E+.v *d
← E+v .*d
← E+F .*d
← E+T .*d
← E+T *.d
← E+T *d.
← E+T *F.
← E+T.
← E.
← S.
− 句柄
栈顶形成；有效识别
THSS 44100593 2024 / 6A-216
− 句柄作为“可归约串”
 成功的归约对应一个最右推导，
 因此每一步归约的串必定是一
 个句柄
 对于右边的文法G[S]，在当前
 栈顶出现 E + T 时，没有使用
 产生式（2）归约，这是因为
 E + T 不是句柄
 右句型 E + T * d 的唯一一个
 句柄是d, 于是当d出现在栈顶时
 使用产生式（8）进行归约
移进−归约分析
◇ 成功分析的关键
文法 G[S]:
(1) S → E
(2) E → E + T 
(3) E → T
(4) T → T * F
(5) T → F
(6) F → ( E )
(7) F → v
(8) F → d
THSS 44100593 2024 / 6A-216
− 移进−归约（shift-reduce）冲突
 到达一个不能确定下一步应该移进还是应该归约的状态 
 例如，有产生式
 S → if E then S | if E then S else S
考虑对于如下串进行移进−归约分析
 if E then if E then S else S
当 if E then if E then S 出现在分析栈中时，是移进 else，
 还是归约 if E then S ?
◇ 分析过程确定化的关键：解决两类冲突
移进−归约分析
THSS 44100593 2024 / 6A-216
− 归约−归约（reduce-reduce）冲突
 到达这样的状态：有按多个产生式进行归约的选择
 例如，有产生式
 S → aA | aaA
考虑对于串 aaab 进行移进−归约分析
 当分析到某一步时，aaA出现在分析栈中（b 位于剩
 余输入区），是用产生式 S → aA 归约 aA，还是用产
 生式 S → aaA 归约 aaA ?
移进−归约分析
◇ 分析过程确定化的关键：解决两类冲突
THSS 44100593 2024 / 6A-216
− 借助于移进−归约表
 多数移进−归约分析的实现都是基于表驱动方法
 下推自动机根据分析栈当前状态/内容、剩余输入单词序
 列，通过查询移进−归约表，确定Reduce，Shift，Error
和Accept 等动作
 移进−归约表可以体现出移进−归约冲突和归约−归约冲
 突的解决方法
 在LR分析中，LR分析表可以起到上述作用
◇ 表驱动方法
移进−归约分析
THSS 44100593 2024 / 6A-216
◇ 表驱动移进−归约分析模型
移进−归约分析
THSS 44100593 2024 / 6A-216
LR分析
LR分析基础
◇ LR分析基础
SLR （1） 分 析
◇ SLR（1）分析 LR（1） 分 析
◇ LR（1）分析 LALR （1） 分 析
◇ LALR（1）分析 LR（K） 文 法
◇ LR（K）文法 错误恢复
◇ 错误恢复
LR（0） 自动机
◇ LR（0）自动机
THSS 44100593 2024 / 6A-216
52
Conclusions
◇ 移进-归约分析
◇ 文法变换
◇消除左递归
◇提取左公因子
◇ 自底向上语法分析思想
◇ 句柄
◇ 表驱动LL(1)分析
◇ LR分析
◇ LL(1)分析中的错误处理
THSS 44100593 2024 / 6A-216
53
Conclusions
THSS 44100593 2024 / 6A-216
54
推荐教学资料
◇§4.3.3 Elimination of Left Recursion 
◇§4.3.4 Left Factoring 
◇§4.4.4 Nonrecursive Predictive Parsing 
◇§4.4.5 Error Recovery in Predictive Parsing 
◇§4.5 Bottom-Up Parsing 
THSS 44100593 2024 / 6A-216
55
Thank you!
THSS 44100593 2024 / 6A-216
本次课程是
线下教学
请现场的同学们：
打开雨课堂，点击页面右下角喇叭
按钮调至静音状态
THSS 44100593 2024 / 6A-216
Chapter 4'
Syntax Analysis (LR)
王朝坤
IISE@Tsinghua
THSS 44100593 2024 / 6A-216
Outline
3
LR(1) 分 析 LR(1) 项 目 LR(1) 项目集规范族 LR(1) A*
◇ LR(1)分析*
√ LR(1)项目
√ LR(1)项目集规范族
√ LR(1) A
SLR(1) 分 析 SLR(1) 分析表 SLR(1) 文 法 SLR(1) 分析算法 SLR(1) 分析的局限性
◇ SLR(1)分析
√ SLR(1)分析表
√ SLR(1)文法
√ SLR(1)分析算法
√ SLR(1)分析的局限性
LR(0) 自动机 *
◇ LR(0) 自动机*
LR分析基础
◇ LR 分析基础
THSS 44100593 2024 / 6A-216
LR分析
LR分析基础
◇ LR分析基础
SLR （1） 分 析
◇ SLR（1）分析 LR（1） 分 析
◇ LR（1）分析 LALR （1） 分 析
◇ LALR（1）分析 LR（K） 文 法
◇ LR（K）文法 错误恢复
◇ 错误恢复
LR（0） 自动机
◇ LR（0）自动机
LR的含义：
− “L”, 代表从
左（Left）向右
扫描输入单词
序列
− “R”
,代表产
生的是最右
（Rightmost）
推导
THSS 44100593 2024 / 6A-216
◇ LR 分析模型
− LR 分析是一种表驱动的移进−归约分析
LR 分析基础
THSS 44100593 2024 / 6A-216
◇ 主要学习四种 LR 分析技术
− LR（0）分析
 适用于 LR（0）文法
− SLR（1）分析
 适用于 SLR（1）文法
− LR（1）分析
 适用于 LR（1）文法
− LALR（1）分析
 适用于 LALR（1）文法
LR 分析基础
Simple LR(1)
LookAhead LR(1)
“0” − 向前查看 0 个符号
“1” − 向前查看 1 个符号
（见龙书 I）
THSS 44100593 2024 / 6A-216
◇ LR 分析表
− LR 分析表的构造是LR 分析的基础
− LR（0）, SLR（1）, LR（1）和 LALR（1）
 四种分析方法可共享同样的LR 分析算法
LR 分析基础
◇ LR 分析表(两张表)
− ACTION 表 告诉分析引擎：在栈顶状态为k, 当前输
 入符号是 a 时做什么
 ACTION [k,a] = …
− GOTO 表 告诉分析引擎：在依产生式 A→β 归约之后，
栈顶状态为i 时做什么
 GOTO[i,A] = …
THSS 44100593 2024 / 6A-216
◇ LR 分析表举例
− 文法： G[E]
栈顶
状态
ACTION GOTO
v d * + ( ) # E T F
0
1
2
3
4
5
6
7
8
9
10
11
12
1 2 3
acc s7
s8 r2
（1）E → E+T （2） E → T 
（3）T →T*F （4） T → F 
（5）F → (E) （6） F → v （7）F → d
r2 r2
r4 r4 r4
s4 s5 s6
s5 s6 s4 9 2 3
r4
r6 r6 r6 r6
r7 r7 r7 r7
s5 s6 s4 10 3
s5 s6 s4 11
s12
s8 r1 r1 r1
r3 r3 r3 r3
r5 r5 r5 r5
s7
LR 分析基础
THSS 44100593 2024 / 6A-216
◇ LR(0)项目
− LR（0）项目（item）或配置（configuration）
• 一个LR（0）项目或配置是在右端某一位置有圆点
 的产生式
 如，产生式 A→xyz 对应如下 4 个 LR（0）项目：
 A→.xyz
A→x.yz
A→xy.z
A→xyz.
圆点标志着已分析过的串与该产生式匹配的位置
• 内核项：圆点不在最左端
• 非内核项：圆点在最左端
LR(0)自动机
THSS 44100593 2024 / 6A-216
LR(0)自动机
◇ 核心概念
− 拓广文法（augmented grammar）
 对于文法 G = (VN
, VT
, P , S ) , 增加如下产生式
 S’ → S
其中，S’  VN  VT ，得到 G 的拓广文法
 G’ = (VN
, VT
, P , S’ )
说明：(1) 拓广文法等价于原文法;
(2) 拓广文法的开始符号不会出现在任何产
 生式的右部；
 (3) LR(0)自动机的构造用到拓广文法
 (4) S’ → .S 是内核项
THSS 44100593 2024 / 6A-216
◇ LR(0)自动机的构造举例
− 文法G[E]的拓广文法G’ [E’] 的 LR(0)自动机
G[E]:
(1) E → E+T 
(2) E → T
(3) T → ( E )
(4) T → d
E’ → .E
E → .E+T 
E → .T
T → .(E)
T → .d
T → (.E)
E → .E+T 
E → .T
T → .( E )
T → .d
E’ → E.
E → E.+T 
E → T.
T → d.
T → (E.)
E → E.+T 
I2
I3
E → E+.T 
T → .( E )
T → .d
T → (E).
I6
E → E+T. 
I4
I3
(
E
T
d
E
T
d
(
+
)
+
T
d
(
I0
: I1
:
I2
:
I3
:
I4
: I5
:
I6
:
I7
:
I8
:
LR(0)自动机
THSS 44100593 2024 / 6A-216
◇ 核心概念
− LR(0)自动机
• 每个上下文无关文法 G 都对应一个LR(0)
自动机
• 由 G 的拓广文法 G’ 直接构造其 LR(0)自动机
• 文法 G = (VN
, VT
, P , S ) 的LR(0)自动机可以
看作一个字母表为 VN  VT 的 DFA（所有状
 态都是终态）, 可以证明该 DFA 的语言是
 G 的所有活前缀的集合（后面讨论）
LR(0)自动机
THSS 44100593 2024 / 6A-216
◇ LR(0)自动机的构造
− LR(0)自动机的状态
• LR(0)自动机的状态是一个 LR（0）项目集的闭包
 （closure）
• 计算LR（0）项目集 I 的闭包 CLOSURE(I)的算法：
 function CLOSURE(I）
 { J:= I;
repeat for J 中的每个项目A →α .Bβ 和 产生式 B→ Y
do 若B→ .Y 不在J中，则加 B→ .Y 到 J 中 
 until 上一次循环不再有新项目加到J中
 return J
};
LR(0)自动机
THSS 44100593 2024 / 6A-216
◇ LR(0)自动机的构造
− LR（0）项目解析
 设 G’ [S’] 是文法 G = (VN
, VT
, P , S )的拓广文法
 根据圆点所在的位置和圆点后是终结符还是非终结符
 或为空，把项目分为以下几种：
 移进项目: 形如 A → α .aβ, 其中a∈VT , α ,β∈(VNVT
)*
待约项目: 形如 A → α .Bβ
归约项目: 形如 A → α .
接受项目: 形如 S’→ S .
LR(0)自动机
THSS 44100593 2024 / 6A-216
◇ LR(0)自动机的构造
− LR(0)自动机的初态
 设文法 G[S] 的拓广文法为 G’ [S’], 则 G’的LR(0)自动机
的初态
 I0 = CLOSURE({S’→.S})
G[E]:
(1) E → E+T 
(2) E → T
(3) T → ( E )
(4) T → d
例 右边文法G[E]的拓广文法为
 G’ [E’] ，其 LR(0)自动机的初态
 I0 = { E’ → .E，
 E → .E+T，
 E → .T，
 T → .( E ),
T → . d
}
LR(0)自动机
THSS 44100593 2024 / 6A-216
◇ LR(0)自动机的构造
− LR(0)自动机的状态转移函数
 GO (I,X) = CLOSURE(J)
其中，I为LR(0)自动机的状态（项目集的闭包），X 为
 文法符号，J={ A→αX.β | A→α.Xβ ∈I}
− 从 LR(0)自动机的初态出发，应用上述转移函数，
 可逐步构造出完整的 LR(0)自动机
对于文法G，称其 LR(0)自动机的所有状态的集合为 G 
 的LR（0）项目集规范族
LR(0)自动机
THSS 44100593 2024 / 6A-216
◇ LR(0)自动机的构造
− 计算 LR（0）项目集规范族
 设文法 G[S] 的拓广文法为 G’ [S’], 则 G’ 的LR（0）项目
 集规范族 C 可由如下算法计算：
 C:= { CLOSURE ({S’→.S})}
Repeat
For C 中每一项目集 I 和每一文法符号X
Do if GO(I,X) 非空且不属于C
Then 把 GO(I,X) 放入C中
 Until C 不再增大
LR(0)自动机
THSS 44100593 2024 / 6A-216
I0
: S → .E
E → .E+T 
E → .T
T → .T*F
T → .F
F → .(E)
F → .v
F → .d
I1
: S → E.
E → E.+T 
I3
: T→F.
I6
: F → d.
E
(
+
I4
: F → (.E)
E → .E+T 
E → .T
T → .T*F
T → .F
F → .(E)
F → .v
F → .d
I9
: F → (E.)
E → E.+T 
I12: F → (E).
I5
: F → v.
I2
: E → T.
T → T. *F 
I7
: E → E+.T 
T → .T*F
T → .F
F → .(E)
F → .v
F → .d
I8
: T → T*.F
F → .(E)
F → .v
F → .d
I10: E → E+T. 
T → T.*F
I11: T → T*F. T
(
F v d
*
E
I2
T
I3
F
I5
v
I6
d
)
I7
+
F
(
I4
v
I5
d
I6
T
I3
F
I4
(
I5
v
I6
d
I8
*
拓广文法G’ [S]:
(0) S → E
(1) E → E + T 
(2) E → T
(3) T → T * F
(4) T → F
(5) F → ( E )
(6) F → v
(7) F → d
LR(0)自动机
◇ LR(0)自动机的构造举例
− 文法G[E]的拓广文法G’ [S] 的 LR(0)自动机
THSS 44100593 2024 / 6A-216
◇ 核心概念
− 文法的活前缀/可行前缀（viable prefix）
• 在移进−归约分析中，活前缀是可以出现在
 分析栈上的任何右句型之前缀
• 活前缀是任何右句型的前缀，它不超过该右
 句型最右句柄的右端
• 对于文法 G = (VN
, VT
, P , S ) , 以及
 α ,Y ∈(VNVT
)* , β∈VT
*
若 S →αAβ 且 A → Y ，则 αY 的任何前
 缀δ 都是文法 G 的活前缀
*
rm
LR(0)自动机
THSS 44100593 2024 / 6A-216
◇ 活前缀举例
文法 G（S）:
（1）S → AB
（2）A → aA
（3）A → ε
（4）B → b
（5）B → bB
− 对于右边的文法G(S),
句子 aaab 是一个右句型，其
 唯一的句柄为：
 ε ：aaaεb；
 所以 aaa 的任何前缀都是文法
 的活前缀：ε， a ， aa ， aaa
右句型 aaAb 的唯一的句柄为：
 aA：aaAb；
 所以 aaA 的任何前缀都是文法
 的活前缀：ε， a ， aa ， aaA
LR(0)自动机
THSS 44100593 2024 / 6A-216
◇ 活前缀与句柄的关系
− 活前缀不含有句柄的任何符号
 此时期待从输入串中看到该句柄对应的
 产生式 A→α的右部所推导出的符号串
− 活前缀只含句柄的一部分符号
 表明该句柄对应的产生式 A→α1α2 的
 右部的子串α1 已出现在栈顶，期待从输入串
 中看到α2 推导出的符号串
− 活前缀已含有句柄的全部符号
 表明该句柄对应的产生式 A→α的右部α
已出现在栈顶
LR(0)自动机
THSS 44100593 2024 / 6A-216
◇ LR 分析模型
分析引擎
LR 分析表 产生式表
Input #
Output
分析栈
状
态
0
S1
Sm
...
◇ 如何获得 LR 分析表
− SLR（1）, LR（1）和 LALR（1）
 三种分析方法分别讨论
SLR（1）分析
THSS 44100593 2024 / 6A-216
SLR（1）分析
◇ SLR（1）分析思想
− SLR（1）分析表的构造基于文法的 LR(0)
自动机
 在SLR（1）分析表中，ACTION 表的归约
 表项只适用于相应非终结符Follow 集中的输入
 符号
 即，根据下一个输入符号是否属于要归约的
非终结符的 Follow 集来决定是否进行归约
THSS 44100593 2024 / 6A-216
SLR（1）分析
◇ SLR（1）分析表的构造
− 假定G[S]的拓广文法为G’ [S]，其LR(0)A的状态集为C={I0
,
I1
,…，In
}；令状态Ik对应的 SLR（1）分析表的栈顶状态
 为k ；并令含有项目S’→.S 的项目集为I0
, 因此0为初态。
 ACTION表项和 GOTO 表项可按如下方法构造：
• 若GO (Ik
, A)= I
j
, A为非终结符，则置GOTO(k, A)=j;
• 若项目A→α.aβ属于 Ik 且 GO (Ik
, a)= I
j
, a 为终结符，则置
 ACTION[k, a] 为“把状态j移进栈”，简记为“sj”;
• 若项目A→α. 属于Ik
, 那么，对任何a∈Follow(A), 置ACTION[k, a]为
 “用产生式A→α进行归约”，简记为“rj”;其中，假定A→α为文法G’
的第j个产生式；
• 若项目S’→S. 属于Ik
, 则置ACTION[k, #]为“接受”，简记为“acc”;
• 分析表中凡不能用上述规则填入信息的空白格均置上“出错标志”
THSS 44100593 2024 / 6A-216
◇ SLR（1）分析表
 的构造举例
− 拓广文法：G’ [S]
SLR（1）分析
栈顶
状态
ACTION GOTO
v d * + ( ) # E T F
0
1
2
3
4
5
6
7
8
9
10
11
12
1 2 3
acc s7
s8 r2 r2 r2
r4 r4 r4
s4 s5 s6
s5 s6 s4 9 2 3
r4
r6 r6 r6 r6
r7 r7 r7 r7
s5 s6 s4 10 3
s5 s6 s4 11
s12
s8 r1 r1 r1
r3 r3 r3 r3
r5 r5 r5 r5
s7
（0）S→E （1）E→ E+T （2） E → T 
（3）T →T*F （4） T → F 
（5）F → (E) （6） F → v （7）F → d
THSS 44100593 2024 / 6A-216
◇ SLR（1）文法
− 按上述算法构造的分析表，如果各表项均无多
 重定义，则称它为文法 G 的一张 SLR（1）表，
 并称 G 为一个 SLR（1）文法
− SLR（1）文法的LR(0)A中，每个状态都满足：
• 对该状态的任何项目A→u.av（a为终结符），不存在
 项目 B→w. 使得 a∈Follow(B)
• 对该状态的任何两个项目A→u.和B→v.，满足
 Follow(A) ∩ Follow(B) = Φ
SLR（1）分析
THSS 44100593 2024 / 6A-216
◇ SLR(1) 分析表
− 使用两张表
• ACTION 表 告诉分析引擎：在栈顶状态为k, 当前输
 入符号是 a 时做什么
 ACTION [k,a]=si， Shift：状态 i 移进栈顶
 ACTION [k,a]=rj， Reduce：按第 j 条产生式归约
 ACTION [k,a]=acc， Accept ：分析完成
 ACTION [k,a]=err，Error ：发现错误 （常标为空白）
• GOTO 表 GOTO[i,A]=j 告诉分析引擎：
 在依产生式 A→β 归约之后，栈顶状态为i 时，要将新
 状态为 j 移进栈顶
 （依产生式 A→β 归约时，要将栈顶的 |β| 个状态弹出）
SLR（1）分析
THSS 44100593 2024 / 6A-216
◇ SLR(1) 分析算法
− 置 ip 指向输入串 w 的首符号，置初始栈顶状态为 0
令 i 为栈顶状态，a 是 ip 指向的符号，重复如下步骤：
if ( ACTION[i,a]=sj ) {
PUSH j ; /*进栈*/ ip 前进 ；/*指向下一输入符号*/
}
else if （ACTION[i,a]=rj ) { /*第 j 条产生式为 A→β */
POP | β | 项; /*位于栈顶部的 | β | 个状态退栈*/
令当前栈顶状态为 k； PUSH GOTO[k,A]；
}
else if （ACTION[i,a]=acc ) return； /*成功*/
else error； /*报错/错误恢复*/
SLR（1）分析
THSS 44100593 2024 / 6A-216
分析栈 余留输入串 分析动作
0 v + v * d # ACTION [0,v]=s5
+ v * d # ACTION [5,
+]=r6 0 5
+ v * d # ACTION [3,
+]=r4 0 
+ v * d # ACTION [2,
+]=r2 0
+ v * d # ACTION [1,
+]=s7 0
v * d # ACTION [7,v]=s5 0 1 7
* d # ACTION [5,
*]=r6 0 1 7 5
* d # ACTION [3,
*]=r4 0 1 7
* d # ACTION [10,
*]=s8 0 1 7
d # ACTION [8,d]=s6 0 1 7 10 8
# ACTION [6,#]=r7 0 1 7 10 8 6
# ACTION [11,#]=r3 0 1 7 10 8
# ACTION [10,#]=r1 10
# ACTION [1,#]=acc 0
◇ SLR(1) 分析过程举例
− 文法：G[E]
− 输入串： v + v * d
（1）E→E+T （2） E→T 
（3）T→T*F （4）T→F 
（5）F→(E) （6） F→v （7）F→d
, GOTO [0,F]=3
, GOTO [0,T]=2
, GOTO [0,E]=1
, GOTO [7,F]=3
, GOTO [7,T]=10
, GOTO [8,F]=11
, GOTO [7,T]=10
, GOTO [0,E]=1
3
2
1
3
10
11
0 1 7 
1
SLR（1）分析
THSS 44100593 2024 / 6A-216
LR（1）分析
◇ SLR（1）分析的局限性举例
− 验证如下文法不是 SLR（1）的
文法 G[E]:
(1) E → (L , E )
(2) E → F
(3) L → L , E
(4) L → E
(5) F → ( F )
(6) F → d
G[E] 的拓广文法 G’ [S]:
(0) S → E
(1) E → (L , E )
(2) E → F 
(3) L → L , E
(4) L → E
(5) F → ( F )
(6) F → d
THSS 44100593 2024 / 6A-216
◇ SLR（1）分析的局限性举例
− 构造拓广文法G’ [S] 的 LR(0)A
拓广文法G’ [S]:
(0) S → E
(1) E → (L , E )
(2) E → F
(3) L → L , E
(4) L → E
(5) F → ( F )
(6) F → d
I0
: S → .E
E → .(L,E) 
E → .F
F → .(F)
F → .d
I1
: S → E.
I4
: F → d.
E
(
I3
: E → (.L,E)
F → (.F)
L → .L,E
L → .E
F → .(F)
F → .d
E → .(L,E) 
E → .F
I5
: L → E.
I2
: E → F.
I7
: F → (F.)
E → F.
I6
: E → (L.,E)
L → L.,E
F
(
d
E
I4
d
L
F
, I8
: E → (L,.E)
L → L,.E
I9
: F → (F).
)
E
I10: E → (L,E.)
L → L,E.
I11: E → (L,E).
)
LR（1）分析
THSS 44100593 2024 / 6A-216
◇ SLR（1）分析的局限性举例
− 文法G’ [S] 不是SLR（1）文法
 状态 I7 的移进−归约冲突无法用 SLR（1）
 分析方法解决 注意： )∈Follow(E)
拓广文法G’ [S]:
(0) S → E
(1) E → (L , E )
(2) E → F
(3) L → L , E
(4) L → E
(5) F → ( F )
(6) F → d
I0
: S → .E
E → .(L,E) 
E → .F
F → .(F)
F → .d
I3
: E → (.L,E)
F → (.F)
L → .L,E
L → .E
F → .(F)
F → .d
E → .(L,E) 
E → .F
I7
: F → (F.)
E → F.
I6
: E → (L.,E)
L → L.,E
(
L
F
, I8
: E → (L,.E)
L → L,.E
E
I10: E → (L,E.)
L → L,E.
LR（1）分析
THSS 44100593 2024 / 6A-216
◇ SLR（1）分析的局限性举例
− 状态 I7 的冲突是可以解决的
 从 I3 和 I5 容易看出，到达状态 I7 （栈上的
 活前缀为(F）时，句柄 F 所期望的下一个
 输入符号实际上是 , ，而不是 )
拓广文法G’ [S]:
(0) S → E
(1) E → (L , E )
(2) E → F
(3) L → L , E
(4) L → E
(5) F → ( F )
(6) F → d
I0
: S → .E
E → .(L,E) 
E → .F
F → .(F)
F → .d
I3
: E → (.L,E)
F → (.F)
L → .L,E
L → .E
F → .(F)
F → .d
E → .(L,E) 
E → .F
I7
: F → (F.)
E → F.
I6
: E → (L.,E)
L → L.,E
(
L
F
, I8
: E → (L,.E)
L → L,.E
E
I10: E → (L,E.)
L → L,E.
I5
: L → E. E
LR（1）分析
THSS 44100593 2024 / 6A-216
LR（1）分析
◇ SLR（1）分析的局限性
− 只考虑到所归约非终结符的 Follow 符号
 虽然是向前查看一个输入符号，但只要输入符号属
 于所归约非终结符的 Follow 集合，就可进行归约
− 未考虑非终结符 Follow 集中的符号是否也是
 句柄的 Follow 符号
 一个输入符号属于所归约非终结符的 Follow 集合，
 未必就是句柄可以后跟的符号
THSS 44100593 2024 / 6A-216
LR（1）分析
◇ LR（1）项目
− 在 LR（0）项目基础上增加一个终结符
 所增加的终结符称为向前搜索符（lookahead）
 表示产生式右端完整匹配后所允许在余留符号
 串中的下一个终结符
− LR（1）项目形如：
 A → α . β , a
A → α . β 同 LR（0）项目， a 为向前搜索符。
 这里，a 或为终结符，或为输入结束标志符 #
THSS 44100593 2024 / 6A-216
LR（1）分析
◇ LR（1）项目解析
− 对于形如：
 A → α . , a
的 LR（1）项目，对应 LR（0）的归约项目，
 但只有当下一个输入符是 a 时才能进行归约
 对于其它形式的LR（1）项目， a 只起到信息
 传承的作用
 （参见随后的 LR（1） 自动机构造过程）
THSS 44100593 2024 / 6A-216
LR（1）分析
◇ 记号
− 若形如
 A → α . β, a1
A → α . β, a2
…
A → α . β, am
的 LR（1）项目序列需要出现在同一个项目集
 中时，将其简记为
 A → α . β, a1
/ a2
/ … / am
THSS 44100593 2024 / 6A-216
LR（1）分析
◇ LR（1）A
− 类似于 LR(0) A, 可以在 LR（1）项目的基础上
 为上下文无关文法 G 构造一个类似的有限状态
 机，称为 LR(1)自动机（LR(1) A）
THSS 44100593 2024 / 6A-216
◇ LR（1）A的构造
− LR（1）A的状态
• LR（1） A 的状态是 LR（1）项目集的闭包
 （closure）
• 计算LR（1）项目集 I 的闭包 CLOSURE(I)的算法：
 function CLOSURE(I）
 { J:= I;
repeat for J 中的每个项目 [A→α . Bβ ，a] 和产生式 B→ Y
do 将所有形如 [B→ .Y , b] 的项目加到 J 中, 这里
 b ∈ First（βa）
 until 上一次循环不再有新项目加到 J 中
 return J
};
LR（1）分析
THSS 44100593 2024 / 6A-216
◇ LR（1）A的构造
− LR（1）A的初态
 设文法 G[S] 的拓广文法为 G’ [S’], 则 G’的 LR（1）A
的初态 I0 = CLOSURE( { [S’→.S，#] } )
LR（1）分析
例 设右边文法G[S]的拓广文法为
 G’ [S] ，其 LR（1）A 的初态
 I0
: S → .E ，#
E → . (L , E ) ，#
E → . F ，#
F → .( F ) ，#
F → . d ，#
文法 G[E]:
(1) E → (L , E )
(2) E → F
(3) L → L , E
(4) L → E
(5) F → ( F )
(6) F → d
THSS 44100593 2024 / 6A-216
◇ LR（1）A的构造
− LR（1）A的状态转移函数
 GO (I,X) = CLOSURE(J)
其中，I为自动机的状态（闭包的项目集），X 为文法符
 号，J={ [A→αX . β , a] | [A→α . Xβ , a] ∈ I}
− 从 LR（1）A 的初态出发，应用上述转移函
 数，可逐步构造出完整的 LR（1）A
对于文法G，称其 LR（1）A的所有状态的集合为 G
的 LR（1）项目集规范族
LR（1）分析
THSS 44100593 2024 / 6A-216
LR（1）分析
◇ LR（1）A的构造
− 计算 LR（1）项目集规范族
 设文法 G[S] 的拓广文法为 G’ [S’], 则 G’ 的LR（1）项目
 集规范族 C 可由如下算法计算：
 C:= { CLOSURE ( { [S’→.S, #] } ) }
Repeat
For C 中每一项目集 I 和每一文法符号X
Do if GO(I,X) 非空且不属于 C
Then 把 GO(I,X) 放入 C 中
 Until C 不再增大
THSS 44100593 2024 / 6A-216
LR（1）分析
◇ LR（1）A的构造举例
− 构造拓广文法G’ [S] 的 LR（1）A
拓广文法G’ [S]:
(0) S → E
(1) E → (L , E )
(2) E → F
(3) L → L , E
(4) L → E
(5) F → ( F )
(6) F → d
I0
: S → .E , #
E → .(L,E) , #
E → .F , #
F → .(F) , #
F → .d , #
I1
: S → E. , #
I4
: F → d. , #
E
I3
: E → (.L,E) , #
F → (.F) , #
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , ,
I5
: L → E. , ,
I2
: E → F. , #
I7
: F → (F.) , #
E → F. , ,
I6
: E → (L.,E) ,#
L → L.,E , ,
F
(
d
E
d
L
F
(
I9
: F→d. , , / )
I8
: 
E → (.L,E) , ,
F → (.F) , , / )
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , , I16: F → (F). , #
)
THSS 44100593 2024 / 6A-216
LR（1）分析
◇ LR（1）A的构造举例
− 构造拓广文法G’ [S] 的 LR（1）A
I12: E → F. , , / )
E
I11: E → (L,E.) , #
L → L,E. , ,
I6
: E → (L.,E) , #
L → L.,E , ,
F
(
d
I10: E → (L,.E) , #
L → L,.E , ,
E → .(L,E) , , / )
E → .F , , / )
F → .(F) , , / ) 
F → .d , , / )
,
I13: E → (.L,E) , , / )
F → (.F) , , / ) 
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , ,
E I5
I14: E → (L.,E) , , / )
L → L.,E , ,
L
F
d I9
(
I8
I18: E → (L,.E) , , / )
L → L,.E , ,
E → .(L,E) , , / )
E → .F , , / )
F → .(F) , , / )
F → .d , , / )
,
I9 I20: E → (L,E). , #
)
I15
I24: E → (L,E.) , , / )
L → L,E. , ,
I25: E → (L,E). , , / )
E
)
d I9
I13
(
F I12
THSS 44100593 2024 / 6A-216
LR（1）分析
◇ LR（1）A的构造举例
− 构造拓广文法G’ [S] 的 LR（1）A
I8
: E → (.L,E) , ,
F → (.F) , , / )
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , ,
E I5
d I9
I15: F → (F.) , , / ) 
E → F. , ,
F
(
I17: E → (L.,E) , ,
L → L.,E , ,
L
I19: E → (L,.E) , , 
L → L,.E , ,
E → .(L,E) , , / )
E → .F , , / )
F → .(F) , , / )
F → .d , , / )
,
I21: F → (F). , , / ) )
(
I13
d
I9
F I12
I22: E → (L,E.) , , 
L → L,E. , ,
E
I23: E → (L,E). , , 
)
THSS 44100593 2024 / 6A-216
46
Conclusions
LR(0) 自动机 活前缀
◇ LR(0) 自动机
√ 活前缀 SLR(1) 分 析 SLR(1) 分析表 SLR(1) 文 法 SLR(1) 分析算法
◇ SLR(1)分析
√ SLR(1)分析表
√ SLR(1)文法
√ SLR(1)分析算法 LR(1) 分 析 LR(1) 项 目 LR(1) 项目集规范族 LR(1) A
◇ LR(1)分析
√ LR(1)项目
√ LR(1)项目集规范族
√ LR(1) A
LR分析基础
◇ LR分析基础
THSS 44100593 2024 / 6A-216
47
Conclusions
THSS 44100593 2024 / 6A-216
48
推荐教学资料
◇§4.6 Introduction to LR Parsing: Simple LR
◇§4.7.1 Canonical LR(1) Items 
◇§4.7.2 Constructing LR(1) Sets of Items 
THSS 44100593 2024 / 6A-216
49
Thank you!
THSS 44100593 2024 / 6A-216
本次课程是
线下教学
请现场的同学们：
打开雨课堂，点击页面右下角喇叭
按钮调至静音状态
THSS 44100593 2024 / 6A-216
Chapter 4'
Syntax Analysis (LR)
王朝坤
IISE@Tsinghua
THSS 44100593 2024 / 6A-216
Outline
3
◇ LR(1) 分析*
语法制导翻译 *
◇ 语法制导翻译*
◇ LALR(1) 分析*
◇ 语义分析
二义文法
◇ 二义文法
THSS 44100593 2024 / 6A-216
LR（1）分析
◇ LR（1）A的构造举例
− 构造拓广文法G’ [S] 的 LR（1）A
拓广文法G’ [S]:
(0) S → E
(1) E → (L , E )
(2) E → F
(3) L → L , E
(4) L → E
(5) F → ( F )
(6) F → d
I0
: S → .E , #
E → .(L,E) , #
E → .F , #
F → .(F) , #
F → .d , #
I1
: S → E. , #
I4
: F → d. , #
E
I3
: E → (.L,E) , #
F → (.F) , #
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , ,
I5
: L → E. , ,
I2
: E → F. , #
I7
: F → (F.) , #
E → F. , ,
I6
: E → (L.,E) ,#
L → L.,E , ,
F
(
d
E
d
L
F
(
I9
: F→d. , , / )
I8
: 
E → (.L,E) , ,
F → (.F) , , / )
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , , I16: F → (F). , #
)
THSS 44100593 2024 / 6A-216
LR（1）分析
◇ LR（1）A的构造举例
− 构造拓广文法G’ [S] 的 LR（1）A
I12: E → F. , , / )
E
I11: E → (L,E.) , #
L → L,E. , ,
I6
: E → (L.,E) , #
L → L.,E , ,
F
(
d
I10: E → (L,.E) , #
L → L,.E , ,
E → .(L,E) , , / )
E → .F , , / )
F → .(F) , , / ) 
F → .d , , / )
,
I13: E → (.L,E) , , / )
F → (.F) , , / ) 
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , ,
E I5
I14: E → (L.,E) , , / )
L → L.,E , ,
L
F
d I9
(
I8
I18: E → (L,.E) , , / )
L → L,.E , ,
E → .(L,E) , , / )
E → .F , , / )
F → .(F) , , / )
F → .d , , / )
,
I9 I20: E → (L,E). , #
)
I15
I24: E → (L,E.) , , / )
L → L,E. , ,
I25: E → (L,E). , , / )
E
)
d I9
I13
(
F I12
THSS 44100593 2024 / 6A-216
LR（1）分析
◇ LR（1）A的构造举例
− 构造拓广文法G’ [S] 的 LR（1）A
I8
: E → (.L,E) , ,
F → (.F) , , / )
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , ,
E I5
d I9
I15: F → (F.) , , / ) 
E → F. , ,
F
(
I17: E → (L.,E) , ,
L → L.,E , ,
L
I19: E → (L,.E) , , 
L → L,.E , ,
E → .(L,E) , , / )
E → .F , , / )
F → .(F) , , / )
F → .d , , / )
,
I21: F → (F). , , / ) )
(
I13
d
I9
F I12
I22: E → (L,E.) , , 
L → L,E. , ,
E
I23: E → (L,E). , , 
)
THSS 44100593 2024 / 6A-216
◇ 解决前例SLR（1）分析中的冲突
− 当到达状态 I7 （栈上的活前缀为(F）时，
 句柄 F 所期望的下一个输入符号只有,，没
 有 )，因而该状态下不存在移进−归约冲突
− 可以验证，对本例中G’ [S] 的 LR（1）A，
 任何状态都不存在（移进−归约或归约−归
 约）冲突
拓广文法G’ [S]:
(0) S → E
(1) E → (L , E )
(2) E → F
(3) L → L , E
(4) L → E
(5) F → ( F )
(6) F → d
LR（1）分析
I0
: S → .E , #
E → .(L,E) , #
E → .F , #
F → .(F) , #
F → .d , #
I3
: E → (.L,E) , #
F → (.F) , #
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , ,
I7
: F → (F.) , #
E → F. , ,
(
F
THSS 44100593 2024 / 6A-216
◇ LR（1）分析表的构造
− 假定C={I0
, I1
,…，In
}，令状态Ik对应的 LR（1）分析表
 的栈顶状态为k；令含有项目[S’→.S，# ]的状态为I0
, 因
 此 0 为初态。ACTION 表项和 GOTO 表项可按如下方
 法构造：
• 若项目[A→α.aβ, b]属于 Ik 且 GO (Ik
, a)= I
j
, a 为终结符，则置
 ACTION[k, a] 为“把状态j移进栈”，简记为“sj”
• 若项目[A→α. , b] 属于Ik
, 那么置ACTION[k, b]为“用产生式A→α
进行归约”，简记为“rj”; 这里，假定A→α为文法G’的第j个产生
式
• 若项目[S’→S., #] 属于Ik
, 则置ACTION[k, #]为“接受”，记为
“
acc”
• 若GO (Ik
, A)= I
j
, A为非终结符，则置GOTO(k, A)=j;
• 分析表中凡不能用上述规则填入信息的空白格均置上“出错标志”
LR（1）分析
THSS 44100593 2024 / 6A-216
◇ LR（1）分析表的构造举例
− 拓广文法：
 G’ [S]
（0）S→E （1）E→(L,E) （2） E→F 
（3）L→L,E （4）L→E （5）F→(F) （6）F→d
LR（1）分析
栈顶
状态
ACTION GOTO
d , ( ) # E L F
2
4
5
6
7
8
10
11
12
1 acc
r2
0 1 2 s3 s4
r4
r6
s10
r2 r2
3 s8 s9 5 6 7
s16 r2
s9 s8 5 16 14
s13 s9 11 12 r3 s20
r6 r6 9
THSS 44100593 2024 / 6A-216
◇ LR（1）分析表的构造举例
− 拓广文法：
 G’ [S]
（0）S→E （1）E→(L,E) （2） E→F 
（3）L→L,E （4）L→E （5）F→(F) （6）F→d
LR（1）分析
栈顶
状态
ACTION GOTO
d , ( ) # E L F
14
15
16
17
18
19
20
21
22
23
24
25
r5
s18
s23 r3
r5 r5
s13 s9 24 12
r2 s21
s19
s13 s9 22 12
r1
r1
s25 r3
r1 r1
13 s8 s9 5 14 15
THSS 44100593 2024 / 6A-216
LR（1）分析
◇ LR（1）文法
− 按上述算法构造的分析表，如果各表项均无多
 重定义，则称它为文法 G 的一张 LR（1）表，
 并称 G 为一个 LR（1）文法
− LR（1）文法的LR（1）A中，每个状态都
 满足：
• 如果该状态含有项目 [A → u.av , b] ，a是终结符，
 那么就不会有项目[B → w., a] ；反之亦然
• 该状态里所有归约项目的向前搜索符不相交，即不
 能同时含有项目[A → u., a] 和 [B → v., a]
THSS 44100593 2024 / 6A-216
LR（1）分析
◇ 可推广到更强大的LR（k）分析
− LR（k）项目
 形如： [ A → α . β , a1a2…ak
],其中a1a2…ak
为向前搜索符号串
 移进项目形如：[ A →α . aβ， a1 a2 … ak
]
待约项目形如：[ A →α . Bβ， a1 a2 … ak
]
归约项目形如：[ A →α. ，a1 a2 … ak
]
− 只有理论意义（ LR（1）A 的状态数已经
 太大，k>1的情形难以想象）
THSS 44100593 2024 / 6A-216
LALR（1）分析
◇ LR（1）和 SLR（1）分析技术的折衷
− LR（1）分析比 SLR（1）分析强大
 可以采用SLR（1）分析的文法一定可以采用LR（1）
 分析；但反之不成立
− LR（1）分析的复杂度比 SLR（1）分析高
 通常，一个 SLR（1）文法的 LR（0）A 状态数目要
比它的 LR（1）A状态数目少得多
− 合并LR（1）A的相似状态
 LALR（1）分析中将同芯/核心（core）的LR（1）A 
状态合并，得到与LR（0）A 相同数目的状态，但
保留了LR（1）的部分向前搜索能力
THSS 44100593 2024 / 6A-216
LALR（1）分析
◇ LR（1）A的同芯状态
− LR（1）项目的“芯”或“核心” （core）
 LR（1）项目 [A → α . β , a] 中的 A → α . β
部分称为该项目的“芯”
− 同芯状态
 对于LR（1）A 的两个状态，如果只考虑
 每个项目的 “芯”，它们是完全相同的项目集
 合，那么这两个状态就是同芯的状态
THSS 44100593 2024 / 6A-216
LALR（1）分析
I3
: E → (.L,E) , #
F → (.F) , #
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , ,
I8
: E → (.L,E) , ,
F → (.F) , , / )
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , ,
I13: E → (.L,E) , , / )
F → (.F) , , / ) 
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , ,
I4
: F → d. , # I9
: F→d. , , / )
I2
: E → F. , # I12: E → F. , , / )
◇ LR（1）A 同芯状态举例
− 文法G’ [S] 的 LR（1）A中的同芯状态
 （共 9 组）
拓广文法G’ [S]:
(0) S → E
(1) E → (L , E )
(2) E → F
(3) L → L , E
(4) L → E
(5) F → ( F )
(6) F → d
THSS 44100593 2024 / 6A-216
LALR（1）分析
I6
: E → (L.,E) ,#
L → L.,E , ,
I17: E → (L.,E) , ,
L → L.,E , ,
I7
: F → (F.) , #
E → F. , ,
I15: F → (F.) , , / ) 
E → F. , ,
I10: E → (L,.E) , #
L → L,.E , ,
E → .(L,E) , , / )
E → .F , , / )
F → .(F) , , / ) 
F → .d , , / )
I18: E → (L,.E) , , / )
L → L,.E , ,
E → .(L,E) , , / )
E → .F , , / )
F → .(F) , , / )
F → .d , , / )
I19: E → (L,.E) , , 
L → L,.E , ,
E → .(L,E) , , / )
E → .F , , / )
F → .(F) , , / )
F → .d , , / )
I14: E → (L.,E) , , / )
L → L.,E , ,
◇ LR（1）A 同芯状态举例
− 文法G’ [S] 的 LR（1）A中的同芯状态（共 9 组）
THSS 44100593 2024 / 6A-216
LALR（1）分析
I11: E → (L,E.) , #
L → L,E. , ,
I24: E → (L,E.) , , / )
L → L,E. , ,
I22: E → (L,E.) , , 
L → L,E. , ,
I21: F → (F). , , / ) I16: F → (F). , #
I20: E → (L,E). , # I25: E → (L,E). , , / ) I23: E → (L,E). , , 
◇ LR（1）A 同芯状态举例
− 文法G’ [S] 的 LR（1）A中的同芯状态（共 9 组）
THSS 44100593 2024 / 6A-216
LALR（1）分析
◇ LR（1）A的同芯状态合并
− 同芯项目的搜索符号集合进行合并
− 举例 上例中的 9 组同芯状态合并为9个新状态
E → F. , , / ) / #
F → (F). , , / ) / #
F → d. , , / ) / # E → (L,.E) , , / ) / # 
L → L,.E , ,
E → .(L,E) , , / )
E → .F , , / )
F → .(F) , , / ) 
F → .d , , / )
E → (L.,E) , , / ) / #
L → L.,E , ,
F → (F.) , , / ) / #
E → F. , ,
E → (L,E). , , / ) / #
E → (L,E.) , , / ) / #
L → L,E. , ,
I2-12 I4-9 I10-18-19
I6-14-17
E → (.L,E) , , / ) / #
F → (.F) , , / ) / #
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , ,
I3-8-13
I7-15
I11-22-24
I16-21
I20-23-25
THSS 44100593 2024 / 6A-216
LALR（1）分析
◇ LALR（1）文法
− 一个LR（1）文法，如果将其LR（1）A的
 同芯状态合并后所得到的新状态无归约−归约
 冲突，则该文法是一个 LALR（1）文法
− 注：
• 由于是LR（1）文法，所以未合并的状态无冲突
• 合并同芯状态后，不会产生新的移进−归约冲突
 （分析一下为什么？）
• 合并同芯状态后，可能产生新的归约−归约冲突
THSS 44100593 2024 / 6A-216
LALR（1）分析
◇ LALR（1）A的构造
− 方法1：“brute-force”方法
• 构造拓广文法的 LR（1）A 状态
• 合并“同芯”的状态（同芯项目的搜索符集合相并）
 得到LALR(1) A 的状态
• LALR(1) A 状态由 GO 函数得到的后继状态是所
 有被合并的“同芯”状态的后继状态之并
 请思考： 若两个状态“同芯”，那么其原来的后继状
 态也一定是“同芯”的
THSS 44100593 2024 / 6A-216
LALR（1）分析
◇ LALR（1）A的构造
− “brute-force”方法举例（续前例）
I0
: S → .E , #
E → .(L,E) , #
E → .F , #
F → .(F) , #
F → .d , #
I1
: S → E. , #
E F
(
d
E → F. , , / ) / #
I2-12
E → (.L,E) , , / ) / #
F → (.F) , , / ) / #
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , ,
I3-8-13
I5
: L → E. , ,
E
d
L
F
F → d. , , / ) / #
I4-9
I4-9
E → (L.,E) , , / ) / #
L → L.,E , ,
I6-14-17
F → (F.) , , / ) / #
E → F. , ,
I7-15
(
)
F → (F). , , / ) / #
I16-21
,
E → (L,.E) , , / ) / # 
L → L,.E , ,
E → .(L,E) , , / )
E → .F , , / )
F → .(F) , , / ) 
F → .d , , / )
I10-18-19
E
F
d I4-9
I2-12
E → (L,E.) , , / ) / #
L → L,E. , ,
I11-22-24
(
)
E → (L,E). , , / ) / #
I20-23-25
THSS 44100593 2024 / 6A-216
LALR（1）分析
◇ LALR（1）A的构造
−方法2：“
on-the-fly”方法或逐步合并法
 （step-by-step merging）
 比“brute-force” 的方法更有效
• LALR（1）A的状态和 GO 函数的构造过
 程同LR（1）A，但每产生一个新状态后，
 需判断其是否与已有状态“同芯”；若是，就
 并到“同芯”的状态，否则才加入此状态
THSS 44100593 2024 / 6A-216
LALR（1）分析
◇ LALR（1）分析表
− 构造方法同LR（1）分析表
THSS 44100593 2024 / 6A-216
LALR（1）分析
◇ LALR（1）分析表的构造举例
− 拓广文法：
 G’ [S]
（0）S→E （1）E→(L,E) （2） E→F 
（3）L→L,E （4）L→E （5）F→(F) （6）F→d
栈顶
状态
ACTION GOTO
d , ( ) # E L F
2-12
4-9
5
6-14-17
7-15
10-18-19
16-21
20-23-25
1 acc
r2
0 1 s3-8-13 s4-9
r4
r6
s10-18-19
3-8-13 5
s16-21 r2
r1
s20-23-25 r3 11-22-24
2-12
r2 r2
6-14-17 7-15
r6 r6
s4-9 s3-8-13
s3-8-13 s4-9 11-22-24 2-12
r5 r5 r5
r1 r1
THSS 341000037 6A309
棱(kernel)
给定项目集I，它的核由以下项目构成：
(1) [S´→ . S]，如果 [S´→ . S] ∈I;
(2) [A → α . β]，如果 [A → α . β]∈I, A≠S´
, α ≠ε。
I : E → (.L,E)
E → .(L,E) 
E → .F
L → .L,E
L → .E
F → .(F)
F → (.F)
F → .d
kernel of I : 
E → (.L,E)
F → (.F)
可以只使用核来表示任意的 LR(0) 或 LR(1) 项集。
THSS 341000037 6A309
向前看符号从 I 的内核中的 A→ α ·β 传播到了 J 的内核中
的 B→ γ ·δ 上，如果
1. 存在一个包含内核项[A→ α ·β, b]的项集I, 且 J=GO(I, X);
2. [B→ γ ·δ, b] ∈ GO(CLOSURE({[A→ α ·β, b]}), X), 且其
原因是项 [A→ α ·β, b] 有一个向前看符号 b.
• 注意：传播关系并不取决于某个特定的向前看符号，要么所
有的向前看符号都从一个项传播到另一个项, 要么都不传播。
传播
I0
: S → .E , #
E → .(L,E) , #
E → .F , #
F → .(F) , #
F → .d , #
I1
: S → E. , #
I4
: F → d. , #
E
I3
: E → (.L,E) , #
F → (.F) , #
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , ,
I2
: E → F. , #
F
(
d
# 传播 # 传播
# 传播 # 传播
THSS 341000037 6A309
对于B→ γ ·δ, 向前看符号 b 被称为自发生成的，如果
1. 存在一个包含内核项[A→ α ·β, a]的项集I，且J=GO(I, X);
2. [B→ γ ·δ, b] ∈ GO(CLOSURE({[A→ α ·β, a]}), X).
• 特殊情况：向前看符号$对于初始项集中的项[S. → ·S]而
言是自发生成的。
自生
I3
: E → (.L,E) , #
F → (.F) , #
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , ,
I5
: L → E. , ,
I7
: F → (F.) , #
E → F. , ,
I6
: E → (L.,E) ,#
L → L.,E , ,
E
d
L
F
(
I9
: F→d. , , / )
I8
: 
E → (.L,E) , ,
F → (.F) , , / )
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , ,
, 自生
, 自生
) 自生
, 自生
, 自生 # 传播
# 传播
, 自生
, 自生
) 自生
THSS 341000037 6A309
确定超前搜索符的算法
输入：一个LR(0)项目集I的核K和一个文法符号X。
输出：对于GO(I，X)中的核项目，由I中的项目自生的搜索
符，以及对于I中的项目，搜索符从这些项目将会传播到
GO(I，X)中的核项目中。
方法：其中哑超前搜索符#来检测出现传播的情形。
 for K中每一项B→γ·δ do begin
J′:=CLOSURE({[B→γ·δ，#]});
if [A→α·X β，a]∈J′，其中a不是# then
对于GO(I，X)中的核项目A→αX·β，超前搜索
符a是自生的;
if [A→α·Xβ，#]∈J′ then
超前搜索符从I中的B→γ·δ传播到GO(I，X)中的
A→αX·β
end
THSS 341000037 6A309
（0）S→E （1）E→(L,E) 
（2） E→F （3）L→L,E 
（4）L→E （5）F→(F) 
（6）F→d
I0
: S → .E
E → .(L,E) 
E → .F
F → .(F)
F → .d
I1
: S → E.
I4
: F → d.
E
(
I3
: E → (.L,E)
F → (.F)
L → .L,E
L → .E
F → .(F)
F → .d
E → .(L,E) 
E → .F
I5
: L → E.
I2
: E → F.
I7
: F → (F.)
E → F.
I6
: E → (L.,E)
L → L.,E
F
(
d
E
I4
d
L
F
,
I8
: E → (L,.E)
L → L,.E
E →.(L,E)
E →.F
F →.(F)
F →.d
I9
: F → (F).
)
E
I10: E → (L,E.)
L → L,E.
I11: E → (L,E).
)
(
I3
F
I2
d
I4
◇ LALR（1）A的构造
−方法3：基于自生和传播的方法
−LALR(1) 语法分析表的有效构造方法
LALR（1）分析
THSS 341000037 6A309
从 到
I0
: S → .E I1
: S → E. 
I2
: E → F.
I3
: E → (.L,E)
I3
: F → (.F)
I4
: F → d.
I3
: E → (.L,E) I6
: E → (L . ,E)
I3
: F → (.F) I7
: F → (F.)
I6
: E → (L.,E) I8
: E → (L,.E)
I6
: L → L.,E I8
: L → L,.E
I7
: F → (F.) I9
: F → (F).
I8
: E → (L,.E) I10: E → (L,E.)
I8
: L → L,.E I2
: E → F.
I3
: E → (.L,E)
I3
: F → (.F)
I4
: F → d.
I10: E → L, E.
I10: E → (L,E.) I11: E → (L,E).
传播
I0
: S → .E, △
E → .(L,E),△
E → .F, △
F → .(F), △
F → .d, △
I1
: S → E., 
△
I3
: E → (.L,E),△
F → (.F), △
I2
: E → F., 
△
I4
: F → d., 
△
E
(
F
d
THSS 341000037 6A309
从 到
I0
: S → .E I1
: S → E. 
I2
: E → F.
I3
: E → (.L,E)
I3
: F → (.F)
I4
: F → d.
I3
: E → (.L,E) I6
: E → (L . ,E)
I3
: F → (.F) I7
: F → (F.)
I6
: E → (L.,E) I8
: E → (L,.E)
I6
: L → L.,E I8
: L → L,.E
I7
: F → (F.) I9
: F → (F).
I8
: E → (L,.E) I10: E → (L,E.)
I8
: L → L,.E I2
: E → F.
I3
: E → (.L,E)
I3
: F → (.F)
I4
: F → d.
I10: E → L, E.
I10: E → (L,E.) I11: E → (L,E).
传播
I8
: E → L,.E , △
E → .(L,E), △
E → .F, △
F → .(F), △
F → .d, △
I10: E → L,E. , △
I3
: E → (.L,E), △
F → (.F), △
I2
: E → F., 
△
I4
: F → d., 
△
E
(
F
d
THSS 341000037 6A309
自生
初始 
I0
: S → .E # 
I1
: S → E. 
I2
: E → F. ) 
I3
: E → (.L,E) , ) 
I3
: F → (.F) , ) 
I4
: F → d. , ) 
I5
: L → E. , 
I6
: E → (L.,E) 
I6
: L → L.,E , 
I7
: F → (F.) 
I7
: E → F. , 
I8
: E → (L,.E) 
I8
: L → L,.E 
I9
: F → (F). 
I10: E → (L,E.) 
I10: L → L,E. 
I11: E → (L,E). 
I0
: S → .E, △
E → .(L,E),△
E → .F, △
F → .(F), △
F → .d, △
THSS 341000037 6A309
自生
初始 
I0
: S → .E # 
I1
: S → E. 
I2
: E → F. ) 
I3
: E → (.L,E) , ) 
I3
: F → (.F) , ) 
I4
: F → d. , ) 
I5
: L → E. , 
I6
: E → (L.,E) 
I6
: L → L.,E , 
I7
: F → (F.) 
I7
: E → F. , 
I8
: E → (L,.E) 
I8
: L → L,.E 
I9
: F → (F). 
I10: E → (L,E.) 
I10: L → L,E. 
I11: E → (L,E). 
I3
: E → (.L,E) ,
△
L → .L,E , ,
L → .E , ,
E → .(L,E) , ,
E → .F , ,
F → .(F) , , 
F → .d , , 
I6
: L → L.,E , ,
I5
: L → E. , ,
I3
: E → (.L,E) , ,
F → (.F) , ,
I7
: E → F. , ,
I4
: F → d. , ,
L
E
(
F
d
THSS 341000037 6A309
自生
初始 
I0
: S → .E # 
I1
: S → E. 
I2
: E → F. ) 
I3
: E → (.L,E) , ) 
I3
: F → (.F) , ) 
I4
: F → d. , ) 
I5
: L → E. , 
I6
: E → (L.,E) 
I6
: L → L.,E , 
I7
: F → (F.) 
I7
: E → F. , 
I8
: E → (L,.E) 
I8
: L → L,.E 
I9
: F → (F). 
I10: E → (L,E.) 
I10: L → L,E. 
I11: E → (L,E). 
I3
: F → (.F) ,
△
F → .(F) , )
F → .d , )
I3
: F → (.F) , )
I4
: F → d. , )
(
d
THSS 341000037 6A309
自生
初始 
I0
: S → .E # 
I1
: S → E. 
I2
: E → F. ) 
I3
: E → (.L,E) , ) 
I3
: F → (.F) , ) 
I4
: F → d. , ) 
I5
: L → E. , 
I6
: E → (L.,E) 
I6
: L → L.,E , 
I7
: F → (F.) 
I7
: E → F. , 
I8
: E → (L,.E) 
I8
: L → L,.E 
I9
: F → (F). 
I10: E → (L,E.) 
I10: L → L,E. 
I11: E → (L,E). 
I8
: E → (L,.E) , △
E → .(L,E), )
E → .F, )
F → .(F), )
F → .d, )
I2
: E → F. , )
I4
: F → d. , )
F
d
I3
: E → (.L,E) , )
F → (.F) , )
(
THSS 341000037 6A309
构造LALR(1)项目集族的核
输入：拓广文法G′
输出：文法G′的LALR(1) 项目集族的核。
步骤：
(1). 构造G的各LR(0)项目集的核。
(2). 对每个 LR(0) 项目集的核和文法符号 X，确定出哪些超前
搜索符对于 GO(I, X) 中的核项目是自生的，并确定出从哪些 
I 中的项目出发，超前搜索符可以传播到在 GO(I, X) 中的核
项目中去。
(3). 对于每个项目集的每个核项目，初始化一个表，使之给出
与之相联系的各个超前搜索符。
 开始时，与每一个项目相联系的超前搜索符仅是那些在(2)
中确定的自生超前搜索符。
(4). 反复遍历所有集合中的核项目。
 当我们访问一个项目 i 时，利用(2)中所建立的信息来查看 i
能将它的超前搜索符传播到哪些核项目。把 i 的当前超前搜
索符集合附加到已经与 i 相关联的各个项目中去，即附加到 i
已将其超前搜索符传播到达的那些项目中去。
 继续遍历核项目，直到没有新的超前搜索符被传播为止。
THSS 341000037 6A309
初始 1 2 3 4 5
I0
: S → .E # # # # # #
I1
: S → E. # # # # #
I2
: E → F. ) # ) # ) , # , ) # , ) # , )
I3
: E → (.L,E) , ) # , ) # , ) # , ) # , ) # , )
I3
: F → (.F) , ) # , ) # , ) #, ) # , ) # , )
I4
: F → d. , ) # , ) # , ) # , ) # , ) # , )
I5
: L → E. , , , , , ,
I6
: E → (L.,E) , ) # , ) # , ) # , ) # , )
I6
: L → L.,E , , , , , ,
I7
: F → (F.) , ) # , ) # , ) # , ) # , )
I7
: E → F. , , , , , , 
I8
: E → (L,.E) , ) , ) # # , ) # , )
I8
: L → L,.E , , , , , 
I9
: F → (F). , ) , ) # # , ) # , )
I10: E → (L,E.) , ) # , ) # , )
I10: L → L,E. , , , ,
I11: E → (L,E). , ) # , )
从 到
I0: S → .E I1: S → E. 
I2: E → F.
I3: E → (.L,E)
I3: F → (.F)
I4: F → d.
I3: E → (.L,E) I6: E → (L . ,E)
I3: F → (.F) I7: F → (F.)
I6: E → (L.,E) I8: E → (L,.E)
I6: L → L.,E I8: L → L,.E
I7: F → (F.) I9: F → (F).
I8: E → (L,.E) I10: E → (L,E.)
I8: L → L,.E I2: E → F.
I3: E → (.L,E)
I3: F → (.F)
I4: F → d.
I10: E → L, E.
I10: E → (L,E.) I11: E → (L,E).
搜索符的计算 LALR（1）分析
THSS 341000037 6A309
（0）S→E （1）E→(L,E) （2） E→F 
（3）L→L,E （4）L→E （5）F→(F) （6）F→d
I0
: S → .E
I1
: S → E.
I4
: F → d.
E
(
I3
: E → (.L,E)
F → (.F)
I5
: L → E.
I2
: E → F.
I7
: F → (F.)
E → F.
I6
: E → (L.,E)
L → L.,E
F
(
d
E
I4
d
L
F
,
I8
: E → (L,.E)
L → L,.E
I9
: F → (F).
)
E
I10: E → (L,E.)
L → L,E.
I11: E → (L,E).
)
(
I3
F
I2
d
I4
LALR（1）分析
THSS 341000037 6A309
（0）S→E （1）E→(L,E) （2） E→F 
（3）L→L,E （4）L→E （5）F→(F) （6）F→d
I0
: S → .E, #
I1
: S → E., #
I4
: F → d. , # /, / ) 
E
(
I3
: E → (.L,E) ,
# /, / ) 
F → (.F) ,
# /, / ) 
I5
: L → E. , , 
I2
: E → F., # /, / ) 
I7
: F → (F.) ,
# /, / ) 
E → F. , , 
I6
: E → (L.,E) 
, # /, / ) 
L → L.,E,, 
F
(
d
E
I4
d
L
F
,
I8
: E → L,.E) ,
# /, / ) 
L → L,.E, ,
I9
: F → (F). , # /, / ) 
)
E
I10: E → (L,E.) , # /, / ) 
L → L,E. , , 
I11: E → (L,E). , # /, / ) 
)
(
I3
F
I2
d
I4
LA
I0
: S → .E #
I1
: S → E. #
I2
: E → F. # , )
I3
: E → (.L,E) # , )
I3
: F → (.F) # , )
I4
: F → d. # , )
I5
: L → E. ,
I6
: E → (L.,E) # , )
I6
: L → L.,E ,
I7
: F → (F.) # , )
I7
: E → F. , 
I8
: E → (L,.E) # , )
I8
: L → L,.E , 
I9
: F → (F). # , )
I10: E → (L,E.) # , )
I10: L → L,E. ,
I11: E → (L,E). # , )
LALR（1）分析
THSS 341000037 6A309
LALR（1）分析
◇ LALR（1）分析表的构造举例
− 拓广文法：
 G’ [S]
（0）S→E
（1）E→(L,E) （2）E→F 
（3）L→L,E （4）L→E 
（5）F→(F) （6）F→d
栈顶
状态
ACTION GOTO
d , ( ) # E L F
2
4
5
6
7
8
10
11
1 acc
r2
0 1 s3 s4
r4
r6
s8
3 5
s9 r2
r1
r5 r5 9
2
r2 r2
6 7
r6 r6
s4 s3
s3 s4 2 10
r3 s11
r5
r1 r1
THSS 44100593 2024 / 6A-216
LALR（1）分析
◇ 与SLR（1）分析相比
− LALR（1）A 的状态数目与 LR（0）A 相同
− LALR（1）分析强于SLR（1）分析
 比较如下 LR（0）A （左）和 LALR（1）A（右）的片断
I0
: S → .E
E → .(L,E) 
E → .F
F → .(F)
F → .d
I3
: E → (.L,E)
F → (.F)
L → .L,E
L → .E
F → .(F)
F → .d
E → .(L,E) 
E → .F
I7
: F → (F.)
E → F.
(
F
I0
: S → .E , #
E → .(L,E) , #
E → .F , #
F → .(F) , #
F → .d , #
(
E → (.L,E) , , / ) / #
F → (.F) , , / ) / #
L → .L,E , ,
L → .E , ,
F → .(F) , , / )
F → .d , , / )
E → .(L,E) , ,
E → .F , ,
F
F → (F.) , , / ) / #
E → F. , ,
I7-15
THSS 44100593 2024 / 6A-216
二义文法在LR 分析中的应用
◇ 某些二义文法可以构造出高效的LR 分析器
− 二义性文法不是LR文法，但是对某些二义性文
 法， 人为地给出合理的限定规则，可能构造出
 高效的LR分析器
− 例：规定优先级和结合性可构造下述文法的
SLR（1）分析器
拓广文法G’ [S]:
(0) S → E
(1) E → E + E 
(2) E → E * E
(3) E → ( E )
(4) E → v
(5) E → d
THSS 44100593 2024 / 6A-216
二义文法在LR 分析中的应用
◇ 例：对右边文法G’ [S]，
 先构造其 LR（0）A 
(0) S → E
(1) E → E + E 
(2) E → E * E
(3) E → ( E )
(4) E → v
(5) E → d
I0
: S → .E 
E → .E+E
E → .E *E
E → .(E)
E → .v 
E → .d
I1
: S → E. 
E → E.+E
E → E. *E
E
v
(
d
I4
: E → d. 
I3
: E → v. 
I2
: E → (.E) 
E → .E+E
E → .E *E
E → .(E)
E → .v 
E → .d
I7
: E → (E.)
E → E.+E
E → E. *E E
I5
: E → E+.E
E → .E+E
E → .E *E
E → .(E)
E → .v 
E → .d
I6
: E → E*.E
E → .E+E
E → .E*E
E → .(E)
E → .v 
E → .d
I5
*
+
*
+
I9
: E → E+E.
E → E.+E
E → E.*E
I10: E → E*E.
E → E.+E
E → E.*E
E
E
(
I2
I5
I3
I4
v
d
(
v d
+
*
*
I8
: E → (E).
)
(
d
I3
v
+
THSS 44100593 2024 / 6A-216
二义文法在LR 分析中的应用
◇ 例：右边文法G’ [S] 的 LR（0）A中，
 因为+, *∈Follow(E)={+, *, ), #},
状态 I9 和 I10 存在移进−归约冲突,
所以，该文法不是SLR（1）文法
 但如果规定 * 的优先级高于+，
 * 和 +都服从左结合性,则可以解
 决 I9 和 I10 中存在移进−归约冲突：
• 对于 I9
若遇*，则移进；若遇+，则归约
• 对于 I10
无论遇*，还是遇+，都归约
文法G’ [S]
(0) S → E
(1) E → E + E 
(2) E → E * E
(3) E → ( E )
(4) E → v
(5) E → d
I9
: E → E+E.
E → E.+E
E → E.*E
I10: E → E *E.
E → E.+E
E → E.*E
THSS 44100593 2024 / 6A-216
二义文法在LR 分析中的应用
◇ 例：对右边文法G’ [S]，从其 LR（0）A
和前述移进−归约冲突的解决方法，
 可构造该文法的LR分析表如下
(0) S → E
(1) E → E + E 
(2) E → E * E
(3) E → ( E )
(4) E → v
(5) E → d
栈顶
状态
ACTION GOTO
v d * + ( ) # E
0
1
2
3
4
5
6
7
8
9
1
acc s5
s2
r4 r4 r4
s2 s3 s4
s6
r4
r5 r5 r5 r5
s5 s6 s8
s6
10
7 s3 s4
s2 9 s3 s4
s2 10 s3 s4
r3 r3 r3 r3
r1 r1 r1
r2 r2 r2 r2
THSS 44100593 2024 / 6A-216
LR 分析中的错误处理
◇ 简单的LR 分析错误处理
− LR分析表的空表项对应一个出错位置
− 可根据相应的分析栈状态和输入符号设置
报错信息，进行简单的恢复工作
THSS 44100593 2024 / 6A-216
LR 分析中的错误处理
◇ 简单的LR 分析错误处理举例
− 可能的报错信息 e1−缺少运算数
 e2−右括号未匹配 e3−缺少运算符 e4−缺少右括号
栈顶
状态
ACTION GOTO
v d * + ( ) # E
0
1
2
3
4
5
6
7
8
9
1
acc s5
s2
r4 r4 r4
s2 s3 s4
s6
r4
r5 r5 r5 r5
s5 s6 s8
s6
10
7 s3 s4
s2 9 s3 s4
s2 10 s3 s4
r3 r3 r3 r3
r1 r1 r1
r2 r2 r2 r2
e1 e1 e1
e1 e1 e2 e1
e1 e1 e2 e1
e1 e1 e2 e1
e2
e2
e3 e3 e3
e3 e3 e3
e3 e3 e3
e4 e3 e3 e3
e3 e3 e3
e3 e3 e3
e3 e3 e3
− 可能的恢复措施 e1？e2？e3？e4？
THSS 44100593 2024 / 6A-216
算符优先分析
算符优先分析（参见龙书第1版）
算符优先文法的定义
 算符优先关系表的构造
 算符优先分析法的特点
THSS 44100593 2024 / 6A-216
YACC 概述
• YACC的工作原理：
• YACC的处理能力：可以用LALR(1)文法表示的上下文
无关文法。
文法描述 语法分析程序
• YACC是一个语法分析程序的自动产生系统
YACC源程序 YACC parser_tab.c文件
THSS 44100593 2024 / 6A-216
几类分析文法之间的关系
SLR（1） LALR（1）
LR（1） LL（1）
确定的CFG
无二义的CFG
CFG
THSS 44100593 2024 / 6A-216
Chapter 5
Syntax-Directed Translation
王朝坤
IISE@Tsinghua
THSS 44100593 2024 / 6A-216
语法制导定义 *
◇ 语法制导定义*
Outline
52
基于语法制导定义的语义处理 *
◇ 基于语法制导定义的语义处理*
语义处理概述
◇ 语义处理概述
翻译方案 *
◇ 翻译方案*
THSS 44100593 2024 / 6A-216
语义处理概述
◇ 语义处理在编译程序中的逻辑位置
词法分析
语法分析
中间代码生成
中间代码优化（可选）
目标代码优化（可选）
目标代码生成
静态语义分析
语义处理
THSS 44100593 2024 / 6A-216
− 两项工作：
 静态语义分析：主要工作如类型检查、名字的作用域分
 析等
 中间/目标代码生成：从语法分析的结果生成中间代
 码（个别编译程序可能直接生成目标代码）
− 跨分析和综合两个阶段
 分析阶段：理解源程序，挖掘源程序的语义
 综合阶段：生成与源程序语义上等价的目标程序
− 跨编译程序的前端和后端
语义处理概述
◇ 语义处理在编译程序中的逻辑位置
THSS 44100593 2024 / 6A-216
− 语法制导的语义处理
 编译程序的设计中，语义分析和中间（目标）代码生
 成的实现多采用语法制导的语义处理（许多时候直接
 称之为语法制导的翻译）
 语法制导语义处理技术的基础是应用语法制导定义
语义处理概述
◇ 语义处理技术
◇ 现实生活中的语义
THSS 44100593 2024 / 6A-216
− 语法制导定义（Syntax-Directed Definition, SDD）
− 属性文法（Attribute Grammar）
在上下文无关文法
 的基础上进行如下扩展：
• 为每个文法符号关联多个属性（Attribute）
• 为文法的每个产生式关联一个语义规则集合
◇ 概念
语法制导定义
THSS 44100593 2024 / 6A-216
− 属性（Attribute）可用来刻画一个文法符号的
 任何我们所关心的特性，如：符号的值，符号
 的名字串，符号的类型，符号的存储地址，符
 号被赋予的寄存器，代码片断，等等…
− 记号
 文法符号 X 关联属性 a 的属性值可通过 X.a 访问
◇ 概念
语法制导定义
THSS 44100593 2024 / 6A-216
− 语义规则（Semantic Rule）
 在SDD中，每个产生式 A→α 都关联一个语义规
 则的集合，用于描述如何计算当前产生式中文法符号
 的属性值
− SDD中允许两种语义规则
• 复写（copy）规则，形如
 X.a := Y.b
• 基于语义函数（semantic function）的规则，形如
 b:=f(c1
, c2
, …, ck
) 或 f(c1
, c2
, …, ck
)
其中，b,c1
, c2
, …, ck是该产生式中文法符号的属性
− 实践中，对语义函数的限制会适当放宽
◇ 概念
语法制导定义
THSS 44100593 2024 / 6A-216
59
Conclusions
二义文法
◇ 二义文法 LR分析错误处理
◇ LR 分析错误处理
语法制导定义
◇ 语法制导定义
语义处理概述
◇ 语义处理概述
◇ LALR(1)分析
◇LALR（1）A 的三种构造方法、
LALR(1)文法、LALR(1)分析表
LR(1) 分 析 LR(1) A 、LR(1) 文 法 LR(1) 分析表的构造 、
◇ LR(1) 分析
◇LR(1) A、 LR(1) 文法、LR(1) 
分析表的构造
THSS 44100593 2024 / 6A-216
60
Conclusions
THSS 44100593 2024 / 6A-216
61
推荐教学资料
◇§4.7.3 -- 4.7.6
◇§4.8 Using Ambiguous Grammars
◇§5.1 Syntax-Directed Definitions
◇§4.9 Parser Generation
THSS 44100593 2024 / 6A-216
课外学习建议
◇ Floyd, R. W. Syntactic Analysis and 
Operator Precedence. J. ACM. 10:3, 316-333. 
1961
◇ Paakki, J.. Attribute Grammar 
Paradigms — A High-Level Methodology in 
Language Implementation. Computing 
Surveys. 27:2, 196-255. 1995
THSS 44100593 2024 / 6A-216
63
Thank you!
THSS 44100593 2024 / 6A-216
本次课程是
线下教学
请现场的同学们：
打开雨课堂，点击页面右下角喇叭
按钮调至静音状态
THSS 44100593 2024 / 6A-216
Chapter 5
Syntax-Directed Translation
王朝坤
IISE@Tsinghua
THSS 44100593 2024 / 6A-216
Outline
3
基于语法制导定义的语义处理 *
◇ 基于语法制导定义的语义处理*
翻译方案 *
◇ 翻译方案*
◇ 继承属性的模拟求值**
符号表
◇ 符号表
类型检查
◇ 类型检查
运行时存储组织 *
◇ 运行时存储组织*
中间代码生成及优化 *
◇ 中间代码生成及优化*
THSS 44100593 2024 / 6A-216
◇ 有两种属性：综合属性和继承属性
− 综合属性（synthesized attribute）
 用于“自下而上”传递信息
 对关联于产生式 A→α 的语义规则 b:=f(c1
, c2
, …, ck
) ，
 如果 b 是 A 的某个属性, 则称 b 是 A 的一个综合属性
− 继承属性（inherited attribute）
 用于“自上而下”传递信息
 对关联于产生式 A→α 的语义规则 b:=f(c1
, c2
, …, ck
) ，
 如果 b 是产生式右部某个文法符号 X 的某个属性，则称
 b 是文法符号 X 的一个继承属性
语法制导定义
THSS 44100593 2024 / 6A-216
◇ 语法制导定义举例
− 仅含综合属性的例子（开始符号S）
产生式
S → E
E → E1 + T
E → T
T → T1 * F
T → F
F → ( E )
F → d
语义规则
{ print(E.val) }
{ E.val := E1
.val + T.val }
{ E.val := T.val }
{ T.val := T1
.val × F.val }
{ T.val := F.val }
{ F.val := E.val }
{ F.val := d.lexval }
注：d.lexval 是词法分析程序确定的属性值
语法制导定义
继承属性：
综合属性：
THSS 44100593 2024 / 6A-216
◇ 综合属性代表自下而上传递的信息
− 接上页的例子，对
 表达式 3 * (5+4) 
的分析树进行自下
 而上（后序）遍历，
 并执行相应的语义
 规则，得到该表达
 式的一种求值过程
T E
T
E
F
T
d
＋
( )
*
d
S
E
F
F T
d
F
d.lexval=5
d.lexval=3
d.lexval=4
F.val=5
F.val=3
T.val=3
T.val=5
E.val=5
F.val=4
T.val=4 E.val=9
F.val=9
T.val=27
E.val=27
print(27)
语法制导定义
THSS 44100593 2024 / 6A-216
◇ 语法制导定义举例
− 含继承属性的例子（开始符号D）
产生式
D → T L
T → int
T → real
L → L1
, v
L → v
语义规则
{ L.in := T.type }
{ T.type := integer }
{ T.type := real }
{ L1
.in := L.in
addtype(v.entry,L.in)
}
{ addtype(v.entry,L.in) }
注：语义函数 addtype(v.entry,L.in) 表示将属性
 值 L.in 填入 v 的符号表项中的 type 域
语法制导定义
继承属性：
综合属性：
THSS 44100593 2024 / 6A-216
◇ 继承属性代表自上而下传递的信息
− 接上页的例子，对声明语句 int x,y,z 的分析树进行遍
 历，自下而上执行综合属性相应的语义规则，自上
 而下执行继承属性相应的语义规则，可以得到所有
 属性值的一个求值过程
T
,
L
D
L v int
T.type=integer L.in=integer
, v L.in=integer
v
L
L.in=integer
addtype(v.entry, integer)
addtype(v.entry, integer)
addtype(v.entry, integer)
语法制导定义
THSS 44100593 2024 / 6A-216
◇ 语法制导定义举例
− 更复杂的例子（开始符号N）
产生式
N → S1
.S2
S → S1B
S → B
B → 0
B → 1
语义规则
{ N.v := S1
.v+S2
.v; S1
.f : =1; S2
.f :=2-S2.l
}
{ S1
.f := 2S.f; B.f : =S.f; S.v := S1
.v+B.v; S.l := S1
.l +1 }
{ S.l := 1 ; S.v := B.v ; B.f := S.f }
{ B.v := 0 }
{ B.v := B.f }
该语法制导定义可用于
 将二进制无符号小数转化为十进制小数
语法制导定义
继承属性：
综合属性：
THSS 44100593 2024 / 6A-216
基于SDD的语义处理
◇ 基于SDD的语义处理即为语法制导的语义处
 理（Syntax-Directed Semantic Process），也称语法
 制导的翻译（Syntax-Directed Translation）
 处理方法分两类：
− 树遍历方法
 通过遍历分析树进行属性计算
− 单遍的方法 （On-the-fly方法 ）
 语法分析遍的同时进行属性计算
THSS 44100593 2024 / 6A-216
◇ 基于树遍历方法的语义处理
− 步骤
• 构造输入串的语法分析树
• 构造依赖图（Dependency graph）
• 若该依赖图是无环的，则按照此无环图的一种
 拓扑排序（Topological sort）对分析树进行遍
 历，就可以计算所有的属性
注：若依赖图含有环，则相应的SDD不可采用这
种方法进行语义处理，此类SDD不是
良定义的. 所谓良定义的SDD，当且仅当它的规则
集合能够为所有分析树中的属性集确定唯一的值
集。
基于SDD的语义处理
THSS 44100593 2024 / 6A-216
◇ 依赖图是一个有向图，用来描述分析树中的属
 性与属性之间的相互依赖关系
− 构造算法
 for 分析树中每一个结点n do
for 结点n对应的文法符号的每一个属性a do
为a在依赖图中建立一个结点；
 for 结点n所用产生式中每个形如f(c1
,c2
,…ck
)的语义规则 do
为该规则在依赖图中也建立一个结点（称为虚结点）；
 for 分析树中每一个结点n do
for 结点n所用产生式对应的每个语义规则 b:=f(c1
,c2
,…ck
) do
（可以只是f(c1
,c2
,…ck
) ，此时b结点为一个虚结点）
 for i :=1 to k do
从ci结点到b结点构造一条有向边
基于SDD的语义处理
THSS 44100593 2024 / 6A-216
◇ 基于树遍历的处理方法举例
− 设有如下SDD，考虑输入串 10.01 的语义处理过程
产生式
N → S1
.S2
S → S1B
S → B
B → 0
B → 1
语义规则
{ N.v := S1
.v+S2
.v; S1
.f : =1; S2
.f :=2-S2.l
}
{ S1
.f := 2S.f; B.f : =S.f; S.v := S1
.v+B.v; S.l := S1
.l +1 }
{ S.l := 1; S.v := B.v ; B.f := S.f }
{ B.v := 0 }
{ B.v := B.f }
基于SDD的语义处理
THSS 44100593 2024 / 6A-216
− 步骤一 构造输入串10.01的语法分析树
◇ 基于树遍历的处理方法举例
S
S
N
S
B
0
.
B
1
S B
1 B
0
基于SDD的语义处理
THSS 44100593 2024 / 6A-216
− 步骤二 为分析树中所有结点的每个属性建立一个
 依赖图中的结点，并给定一个标记序号
◇ 基于树遍历的处理方法举例
S
S
N
S
B
0
.
B
1
S B
1 B
0
1：v
4：v
3：f
2：l
5：l 6：f
7：v
8：f
9：v
10：f
11：v
18：f 19：v
15：l 16：f
17：v
12：l
13：f
14：v
20：f
21：v
基于SDD的语义处理
THSS 44100593 2024 / 6A-216
− 步骤三 根据语义规则，建立依赖图中的有向边
◇ 基于树遍历的处理方法举例
S
S
N
S
B
0
.
B
1
S B
1
B
0
1：v
4：v
3：f
2：l
5：l 6：f
7：v
8：f
9：v
10：f
11：v
18：f 19：v
15：l 16：f
17：v
12：l
13：f
14：v
20：f
21：v
基于SDD的语义处理
THSS 44100593 2024 / 6A-216
− 步骤三 根据语义规则，建立依赖图中的有向边
◇ 基于树遍历的处理方法举例
S
S
N
S
B
0
.
B
1
S B
1
B
0
1：v
4：v
3：f
2：l
5：l 6：f
7：v
8：f
9：v
10：f
11：v
18：f 19：v
15：l 16：f
17：v
12：l
13：f
14：v
20：f
21：v
基于SDD的语义处理
N → S1
.S2
{ N.v := S1
.v+S2
.v }
THSS 44100593 2024 / 6A-216
− 步骤三 根据语义规则，建立依赖图中的有向边
◇ 基于树遍历的处理方法举例
S
S
N
S
B
0
.
B
1
S B
1
B
0
1：v
4：v
3：f
2：l
5：l 6：f
7：v
8：f
9：v
10：f
11：v
18：f 19：v
15：l 16：f
17：v
12：l
13：f
14：v
20：f
21：v
基于SDD的语义处理
N → S1
.S2
{S2
.f :=2-S2.l
}
THSS 44100593 2024 / 6A-216
− 步骤三 根据语义规则，建立依赖图中的有向边
◇ 基于树遍历的处理方法举例
S
S
N
S
B
0
.
B
1
S B
1
B
0
1：v
4：v
3：f
2：l
5：l 6：f
7：v
8：f
9：v
10：f
11：v
18：f 19：v
15：l 16：f
17：v
12：l
13：f
14：v
20：f
21：v
基于SDD的语义处理
S → S1B { S1
.f := 2S.f; B.f : =S.f }
THSS 44100593 2024 / 6A-216
− 步骤三 根据语义规则，建立依赖图中的有向边
◇ 基于树遍历的处理方法举例
S
S
N
S
B
0
.
B
1
S B
1
B
0
1：v
4：v
3：f
2：l
5：l 6：f
7：v
8：f
9：v
10：f
11：v
18：f 19：v
15：l 16：f
17：v
12：l
13：f
14：v
20：f
21：v
基于SDD的语义处理
S → S1B { S.l := S1
.l +1 }
THSS 44100593 2024 / 6A-216
− 步骤三 根据语义规则，建立依赖图中的有向边
◇ 基于树遍历的处理方法举例
S
S
N
S
B
0
.
B
1
S B
1
B
0
1：v
4：v
3：f
2：l
5：l 6：f
7：v
8：f
9：v
10：f
11：v
18：f 19：v
15：l 16：f
17：v
12：l
13：f
14：v
20：f
21：v
基于SDD的语义处理
S → S1B { S.v := S1
.v+B.v }
THSS 44100593 2024 / 6A-216
− 步骤三 根据语义规则，建立依赖图中的有向边
◇ 基于树遍历的处理方法举例
S
S
N
S
B
0
.
B
1
S B
1
B
0
1：v
4：v
3：f
2：l
5：l 6：f
7：v
8：f
9：v
10：f
11：v
18：f 19：v
15：l 16：f
17：v
12：l
13：f
14：v
20：f
21：v
基于SDD的语义处理
S → B { S.v := B.v }
THSS 44100593 2024 / 6A-216
− 步骤三 根据语义规则，建立依赖图中的有向边
◇ 基于树遍历的处理方法举例
S
S
N
S
B
0
.
B
1
S B
1
B
0
1：v
4：v
3：f
2：l
5：l 6：f
7：v
8：f
9：v
10：f
11：v
18：f 19：v
15：l 16：f
17：v
12：l
13：f
14：v
20：f
21：v
基于SDD的语义处理
S → B { B.f := S.f }
THSS 44100593 2024 / 6A-216
− 步骤三 根据语义规则，建立依赖图中的有向边
◇ 基于树遍历的处理方法举例
S
S
N
S
B
0
.
B
1
S B
1
B
0
1：v
4：v
3：f
2：l
5：l 6：f
7：v
8：f
9：v
10：f
11：v
18：f 19：v
15：l 16：f
17：v
12：l
13：f
14：v
20：f
21：v
基于SDD的语义处理
B → 1 { B.v := B.f }
THSS 44100593 2024 / 6A-216
− 步骤四 容易看出，该依赖图是无环的，因此存在
 拓扑排序. 依任何一个拓扑排序，都能够顺利完成
 属性值的计算. 如下是一种可能的计算次序：
 3,5,2,6,10,8,9,7,11,4,15,12,13,16,20,18,21,19,17,14,1 
◇ 基于树遍历的处理方法举例
S
S
N
S
B
0
.
B
1
S B
1 B
0
1：v
4：v
3：f
2：l
5：l 6：f
7：v
8：f
9：v
10：f
11：v
18：f 19：v
15：l 16：f
17：v
12：l
13：f
14：v
20：f
21：v
基于SDD的语义处理
THSS 44100593 2024 / 6A-216
− 步骤五 依计算次序，根据语义规则求出各结点对
 应的属性值. 对如下结点次序进行计算：
 3,5,2,6,10,8,9,7,11,4,15,12,13,16,20,18,21,19,17,14,1 
◇ 基于树遍历的处理方法举例
S
S
N
S
B
0
.
B
1
S B
1 B
0
1：v
4：v
3：f
2：l
5：l 6：f
7：v
8：f
9：v
10：f
11：v
18：f 19：v
15：l
16：f
17：v
12：l
13：f
14：v
20：f
21：v
1
1
2
2
1
2
2
2 0
2
1
2
0.25
0.5 0.25
0.5
0.25
0
0
0.25
2.25
基于SDD的语义处理
继承(f)：
综合(l, v)：
THSS 44100593 2024 / 6A-216
− 语法分析树中各结点属性值的计算过程被称为对语
 法分析树的标注（annotating）或修饰（decorating），
 用带标注的语法分析树表示属性值的计算结果，如：
◇ 带标注（annotated）的语法分析树
S
S
N
S
B
0
.
B
1
S B
1 B
0
f=1
l=1
l=2
f=2 l=1
f=2 v=2
v=2
v=0
v=2
f=1
l=2
f=0.25
f=0.5 f=0.25
f=0.5
v=0.25
v=0
v=0
v=0.25
v=2.25
基于SDD的语义处理
THSS 44100593 2024 / 6A-216
◇ 基于SDD的语义处理即为语法制导的语义处
 理（Syntax-Directed Semantic Process），也称
 语法制导的翻译（Syntax-Directed Translation）
 处理方法分两类：
− 树遍历方法
 通过遍历分析树进行属性计算
− 单遍的方法 （On-the-fly方法 ）
 语法分析遍的同时进行属性计算
基于SDD的语义处理
THSS 44100593 2024 / 6A-216
◇ 单遍的方法 （On-the-fly方法 ）
− 语法分析遍的同时进行属性计算
• 自下而上方法
• 自上而下方法
− 只适用于特定文法
 两类SDD：
• S-属性SDD
• L-属性SDD
基于SDD的语义处理
THSS 44100593 2024 / 6A-216
◇ S-属性的SDD
− 只包含综合属性
− S for synthesized
◇ L-属性的SDD
− 可以包含综合属性，也可以包含继承属性
− L for left-to-right
− 产生式右端某文法符号的继承属性的计算只取决
 于该符号左边文法符号（包括产生式左边的文法
 符号）的属性
− S-属性SDD是L-属性SDD的一个特例
基于SDD的语义处理
THSS 44100593 2024 / 6A-216
◇ S-属性的SDD的语义处理
− 通常采用自下而上的方式进行
− 若采用LR分析技术，可以
通过扩充分析栈中的域，
 形成语义栈来存放综合属性的值，
计算相应产生式
 左部文法符号的综合属性值刚好
发生在每一步归约之前的时刻
基于SDD的语义处理
分析引擎
LR 分析表 产生式表
Input #
Output
分析栈
状态
/符号
0
S1
Sm
...
THSS 44100593 2024 / 6A-216
◇ 采用LR分析技术进行S-属性SDD的语义处理
− 扩充分析栈中的域形成语义栈存放综合属性的值
基于SDD的语义处理
分析引擎
LR 分析表 产生式表
Input #
Output
分析栈
状态
/符号
0
S1
Sm
...
语
义
-
Y1
...
Ym
THSS 44100593 2024 / 6A-216
− 例如，假设有相应于产生式 A→BCD 的语义规则
 A.a := f（B.b, C.c, D.d）
 在 BCD 归约为 A 之前，B.b, C.c,和 D.d分别存放
 于语义栈的 top-2，top-1 和 top 的相应域中，因
 此 A.a 可以顺利求出
 归约后，B.b, C.c, D.d被弹出，而在栈顶 top 的位
 置上存放 A.a。
◇ 采用LR分析技术进行S-属性SDD的语义处理
− 语义规则中的综合属性可以通过存在于当前语义栈
 栈顶部分的属性进行计算
基于SDD的语义处理
THSS 44100593 2024 / 6A-216
产生式
S → E
E → E1 + T
E → T
T → T1 * F
T → F
F → ( E )
F → d
语义规则
{ print(E.val) }
{ E.val := E1
.val + T.val }
{ E.val := T.val }
{ T.val := T1
.val × F.val }
{ T.val := F.val }
{ F.val := E.val }
{ F.val := d.lexval }
◇ 用LR分析技术进行S-属性SDD的语义处理举例
− 通过下列S-属性SDD G’[S]为常量表达式求值
基于SDD的语义处理
THSS 44100593 2024 / 6A-216
◇ 文法G’ [S] 的LR
分析表
状态 ACTION GOTO
d * + ( ) # E T F
0
1
2
3
4
5
6
7
8
9
10
11
1 2 3
acc s6
s7 r2 r2 r2
r4 r4 r4
s4 s5
s5 s4 8 2 3
r4
r6 r6 r6 r6
s5 s4 9 3
s5 s4 10
s11
s7 r1 r1 r1
r3 r3 r3 r3
r5 r5 r5 r5
s6
（0）S→E （1）E→ E+T （2） E → T 
（3）T →T*F （4） T → F 
（5）F → (E) （6）F → d
基于SDD的语义处理
THSS 44100593 2024 / 6A-216
◇ LR分析过程伴随常量
 表达式2 + 3 * 5的求值
（0）S→E （1）E→ E+T （2） E → T 
（
（
3
5
）
）
T 
F →
→T
(E) 
*F 
（
（
6）
4）
F →
T →
d
F 
分析栈（状态，语义值） 余留输入串 动作
0 − 2 + 3 * 5 # s5
+ 3 * 5 # s6 0 − 1 2
3 * 5 # s5 0 − 1 2 6 −
* 5 # s7 0 − 1 2 6 − 9 3
5 # s5 0 − 1 2 6 − 9 3 7 −
语义规则
+ 3 * 5 # r6 0 − 5 2 F.val := d.lexval
+ 3 * 5 # r4 0 − 3 2 T.val := F.val
+ 3 * 5 # r2 0 − 2 2 E.val := T.val
# r3 0 − 1 2 6 − 9 3 7 − 10 5 T.val:=T1
.val×F.val
# acc 0 − 1 17 print(E.val)
* 5 # r6 0 − 1 2 6 − 5 3 F.val := d.lexval
* 5 # r4 0 − 1 2 6 − 3 3 T.val := F.val
# r6 0 − 1 2 6 − 9 3 7 − 5 5 F.val := d.lexval
# r1 0 − 1 2 6 − 9 15 E.val:=E1
.val+T.val
基于SDD的语义处理
THSS 44100593 2024 / 6A-216
◇ L-属性SDD的语义处理
− 采用自上而下的方式可以较方便地进行
− 可以采用下列基于深度优先后序遍历的算法
 procedure dfvisit(n: node);
begin
for n 的每一孩子m, 从左到右 do
begin
计算 m 的继承属性值;
dfvisit(m)
end;
计算n的综合属性值
 end 
− 该算法与自上而下预测分析过程对应. 因此,基于 LL(1)
文法的 L-属性SDD可以采用这种方法进行语义处理.
（随后将结合翻译方案的进一步讨论分析程序的构造）
基于SDD的语义处理
THSS 44100593 2024 / 6A-216
38
N
. S
B S
S B
B S
1
0
ε
1
产生式
N → .S
S → BS1
S → ε
B → 0
B → 1
语义规则
{ S.f : =1； print(S.v) }
{ S1
.f := S.f+1; B.f : =S.f; 
S.v := S1
.v+B.v }
{ S.v := 0 }
{ B.v := 0 }
{ B.v := 2-B.f
}
继承属性：
综合属性：
S.f
S.f
B.f
B.f
B.v
B.v
B.v
print( )
B.f
S.f
S.v
S.v
S.v
◇ 采用基于深度优先后序遍历算法进行 L-属性
SDD 的语义处理举例
− 考虑对于下列L-属性SDD，输入串为 .101 时的处理过程
=1
=1
=0.5
= 2
=2
=0
= 3
= 3
= 0.125 =0
=0.125
=0.125
0.625
S.v=0.625
基于SDD的语义处理
S.f= 4
THSS 44100593 2024 / 6A-216
◇ 语法制导的翻译方案（Syntax-Directed 
Translation Scheme, SDT）概念
− 在产生式体中嵌入了程序片段的CFG
− 翻译方案 / 翻译模式；语义动作
− 适合语法制导语义处理的另一种描述形式
− 可以体现一种合理调用语义规则的翻译算法
− 形式上类似于SDD，但允许由{ }括起来的
 语义规则集合出现在产生式右端的任何位置. 
优点在于可显式地表达动作和属性计算的
 次序，而在前述的SDD中不体现这种次序
翻译方案
THSS 44100593 2024 / 6A-216
翻译方案
◇ 受限的翻译方案
− 在设计翻译方案时，必须作某些限制，以确
 保每个属性值在被访问到的时候已经存在
− 这里仅讨论两类受限的翻译方案
• 受S-属性SDD的启示，对于仅需要综合属性的情形，只要
 创建一个语义规则集合，放在相应产生式右端的末尾，把
 属性的计算规则加入其中即可
• 受L-属性定义的启示，对于既包含继承属性又包含综合属
 性的情形，必须注意：
（1）产生式右端某个符号的继承属性的计算必须位于该符
号之前；
（2）每个计算规则不访问位于它右边符号的综合属性；
（3）产生式左部非终结符的综合属性的计算只能在所用到
的属性都已计算出来之后进行，通常放在相应产生式右端的
末尾
THSS 44100593 2024 / 6A-216
◇ 翻译方案举例
− 定点二进制小数转换为十进制小数
翻译方案
N → . { S.f : =1} S { print(S.v) }
S → { B.f : =S.f } B { S1
.f := S.f +1} S1 {S.v := S1
.v+B.v }
S → ε { S.v := 0 }
B → 0 { B.v := 0 }
B → 1 { B.v := 2-B.f
}
THSS 44100593 2024 / 6A-216
翻译方案
◇ 基于翻译方案的语义处理（翻译）
− 仅考虑单遍的方法
• 自上而下的语义处理（翻译）
 借助于自上而下的预测分析技术
• 自下而上的语义处理（翻译）
 借助于自下而上的移进−归约分析技术
− 仅考虑上述的受限翻译方案，
THSS 44100593 2024 / 6A-216
翻译方案
◇ 基于翻译方案的自上而下语义处理（翻译）
− 对适合于自上而下预测技术的翻译方案，语法制导
 的语义处理（翻译）程序可以如下构造 
• 对每个非终结符 A，构造一个函数，以 A 的每个
 继承属性为形参，以A的综合属性为返回值（若有
 多个综合属性，可返回记录类型的值） 。如同预
 测分析程序的构造，该函数代码的流程是根据当
 前的输入符号来决定调用哪个产生式。
• 与每个产生式相关的代码根据其右端的结构来构
 造（见下页）
THSS 44100593 2024 / 6A-216
翻译方案
◇ 基于翻译方案的自上而下语义处理（翻译）
− 语法制导的语义处理（翻译）程序的构造中，与每
 个产生式相关的代码根据产生式右端的终结符，非
 终结符，和语义规则集（语义动作），依从左到右
 的次序完成下列工作：
• 对终结符 x，调用匹配终结符（match_token），并继续输
入。
• 对非终结符 B，利用相应于 B 的函数调用产生赋值语句
 c:=B(b1
, b2
, …, bk
)，其中变量 b1
, b2
, …, bk 对应 B的各继
 承属性，变量c对应B的综合属性
• 对语义规则集，直接copy其中每一语义规则（动作）来产
 生代码，只是将对属性的访问替换为对相应变量的访问。
THSS 44100593 2024 / 6A-216
翻译方案
◇ 基于翻译方案的自上而下语义处理举例
− 构造下列翻译方案的自上而下预测分析程序
 （可以验证其基础文法为 LL（1）文法）
N → . { S.f : =1} S { print(S.v) }
S → { B.f : =S.f } B { S1
.f := S.f +1} S1 {S.v := S1
.v+B.v }
S → ε { S.v := 0 }
B → 0 { B.v := 0 }
B → 1 { B.v := 2-B.f
}
THSS 44100593 2024 / 6A-216
翻译方案
◇ 基于翻译方案的自上而下语义处理举例
− 根据产生式
 N → . { S.f : =1} S { print(S.v) }
对非终结符 N，构造如下函数
void ParseN()
{
MatchToken(‘.’); //匹配‘.’
Sf : =1; //变量 Sf 对应属性S.f
Sv : = ParseS(Sf); //变量 Sv 对应属性S.v
print(Sv);
}
THSS 44100593 2024 / 6A-216
翻译方案
◇ 基于翻译方案的自上而下语义处理举例
− 根据产生式
 S → { B.f : =S.f } B { S1
.f := S.f +1} S1 {S.v := S1
.v+B.v }
S → ε { S.v := 0 }
对非终结符 S，构造如下函数
float ParseS( int f )
{
if (lookahead==‘0’ or lookahead==‘1’ ) {
Bf : = f; Bv : = ParseB(Bf); S1f := f +1 ;
S1v := ParseS(S1f); Sv := S1v + Bv;
}
else if (lookahead== ‘#’ ) Sv := 0;
else { printf("syntax error \n"); exit(0); }
return Sv;
}
THSS 44100593 2024 / 6A-216
翻译方案
◇ 基于翻译方案的自上而下语义处理举例
− 根据产生式
 B → 0 { B.v := 0 }
B → 1 { B.v := 2-B.f
}
对非终结符 B，构造如下函数
float ParseB( int f )
{
if (lookahead==‘0’) {MatchToken(‘0’); Bv : = 0;} 
else if (lookahead== ‘1’ ) { 
MatchToken(‘1’); Bv := 2^(-f); 
}
else { printf("syntax error \n"); exit(0); }
return Bv;
}
THSS 44100593 2024 / 6A-216
翻译方案
◇ 基于翻译方案的自下而上语义处理（翻译）
− 扩展前述的关于S-属性SDD的自下而上处理技术
 （即在分析栈中增加存放属性值的域）
• 翻译方案中综合属性的求值采用前述的处理方法
− 对于前述受限的翻译方案，核心问题可转化为L-属性
 SDD 的自下而上处理，该问题的讨论较复杂，本讲仅
 涉及如下 3 个方面的简介
• 翻译方案中去掉嵌在产生式中间的语义规则
• 分析栈中继承属性的访问
• 继承属性的模拟求值
THSS 44100593 2024 / 6A-216
50
语法制导定义
◇ 语法制导定义
Conclusions
基 于 SDD 的语义处理 基于树遍历方法的语义处理 单遍的方法 自下而上 自上而下
◇ 基于SDD的语义处理
√基于树遍历方法的语义处理
√单遍的方法
√自下而上
√自上而下 翻译方案
◇ 翻译方案 基于翻译方案的语义处理 基于翻译方案的自上而下语义处理 基于翻译方案的自下而上语义处理
◇ 基于翻译方案的语义处理
√基于翻译方案的自上而下语义处理
√基于翻译方案的自下而上语义处理
THSS 44100593 2024 / 6A-216
51
Conclusions
THSS 44100593 2024 / 6A-216
52
推荐教学资料
◇§5.2 Evaluation Orders for SDD's
◇§5.1 Syntax-Directed Definition
◇§5.4 Syntax-Directed Translation
Schemes
◇§5.5 Implementing L-Attributed SDD’s
THSS 44100593 2024 / 6A-216
课外学习建议
◇ Floyd, R. W. Syntactic Analysis and 
Operator Precedence. J. ACM. 10:3, 316-333. 
1961
◇ Engelfriet, J. Attribute Evaluation Methods. 
Methods and Tools for Compiler Construction. 
103-138. 1984
THSS 44100593 2024 / 6A-216
54
Thank you!
THSS 44100593 2024 / 6A-216
本次课程是
线下教学
请现场的同学们：
打开雨课堂，点击页面右下角喇叭
按钮调至静音状态
THSS 44100593 2024 / 6A-216
Outline
2
◇ 中间代码生成
翻译方案 *
◇ 翻译方案*
◇ 继承属性的模拟求值**
◇ 符号表
◇ 类型检查
◇ 运行时存储组织*
THSS 44100593 2024 / 6A-216
翻译方案
◇ 基于翻译方案的自下而上语义处理（翻译）
− 从翻译方案中去掉嵌在产生式中间的语义规则集
• 若语义规则集中未关联任何属性，引入新的非终结
 符N和产生式N→ε,把嵌入在产生式中间的动作用
 非终结符N代替,并把该语义规则集放在产生式后面
• 若语义规则集中有关联的属性，引入新的非终结
 符N和产生式N→ε，以及把该语义规则集放在产
 生式后面的同时，需要在适当的地方增加复写规则
 （可参照稍后关于分析栈中继承属性的模拟求值的
 解决方案）
• 目的：使所有嵌入的语义规则都出现在产生式的末
 端,以便自下而上处理继承属性
THSS 44100593 2024 / 6A-216
翻译方案
◇ 基于翻译方案的自下而上语义处理（翻译）
− 从翻译方案中去掉嵌在产生式中间的语义规则集举例
E → T R
R → + T { print(‘+’) } R1
R → − T { print(‘−’) } R1
R → ε
T → num { print(num.val ) }
E → T R
R → + T M R1
R → − T N R1
R → ε
T → num { print(num.val ) }
M → ε { print(‘+’) } 
N → ε { print(‘−’) } 
THSS 44100593 2024 / 6A-216
翻译方案
◇ 基于翻译方案的自下而上语义处理（翻译）
− 分析栈中继承属性的访问
• 自下而上语义处理程序根据产生式 A→XY 的归约 
过程中，假设X的综合属性 X.s 已经出现在语义栈上. 
• 因为在Y 以下子树的任何归约之前，X.s的值一直存
在，因此它可以被Y 访问. 
• 如果用复写规则Y.i:=X.s 来定义 Y 的继承属性Y.i，
则在需要Y.i 时，可以使用X.s
THSS 44100593 2024 / 6A-216
翻译方案
D → T { L.in := T.type } L
T → int { T.type := integer } | real { T.type := real }
L → { L1
.in := L.in } L1
, v { addtype(v.entry,L.in) }
L → v { addtype(v.entry,L.in) }
翻译方案
◇ 基于翻译方案的自下而上语义处理（翻译）
− 分析栈中继承属性的访问举例
D → T L
T → int val [top] := integer
T → real val [top] := real
L → L , v addtype(val [top] , val [top-3] )
L → v addtype(val [top] , val [top-1] )
(分析栈val 存放文法符号的综合属性, top为栈顶指针)
产生式 依产生式归约时语义处理的代码片断
继承
属性：
综合
属性：
THSS 44100593 2024 / 6A-216
翻译方案
D → T { L.in := T.type } L
T → int { T.type := integer } | real { T.type := real }
L → { L1
.in := L.in } L1
, v { addtype(v.entry,L.in) }
L → v { addtype(v.entry,L.in) }
翻译方案
◇ 基于翻译方案的自下而上语义处理（翻译）
− 分析栈中继承属性的访问举例
D → T L
T → int val [top] := integer
T → real val [top] := real
L → L , v addtype(val [top] , val [top-3] )
L → v addtype(val [top] , val [top-1] )
(分析栈val 存放文法符号的综合属性, top为栈顶指针)
产生式 依产生式归约时语义处理的代码片断
继承
属性：
综合
属性： 0 ...
… …
T T.type [top-3]
v v.entry [top]
L … [top-2]
, … [top-1]
val栈
THSS 44100593 2024 / 6A-216
翻译方案
D → T { L.in := T.type } L
T → int { T.type := integer } | real { T.type := real }
L → { L1
.in := L.in } L1
, v { addtype(v.entry,L.in) }
L → v { addtype(v.entry,L.in) }
翻译方案
◇ 基于翻译方案的自下而上语义处理（翻译）
− 分析栈中继承属性的访问举例
D → T L
T → int val [top] := integer
T → real val [top] := real
L → L , v addtype(val [top] , val [top-3] )
L → v addtype(val [top] , val [top-1] )
(分析栈val 存放文法符号的综合属性, top为栈顶指针)
产生式 依产生式归约时语义处理的代码片断
继承
属性：
综合
属性： 0 ...
… …
T T.type [top-1]
v v.entry [top]
val栈
THSS 44100593 2024 / 6A-216
翻译方案
◇ 基于翻译方案的自下而上语义处理（翻译）
− 继承属性的模拟求值
• 从上面的讨论可知，分析栈中继承属性的访问是通
 过栈中已有文法符号的综合属性值间接进行的，因
 此设计翻译方案时需要做到的一点就是要保证继承
 属性总可以通过某个文法符号的综合属性体现出来
• 必要时，通过增加新的文法符号以及相应的复写规
 则常常可以达到上述目的
THSS 44100593 2024 / 6A-216
翻译方案
◇ 基于翻译方案的自下而上语义处理（翻译）
− 继承属性的模拟求值举例
 考虑如下翻译方案：
 S → a A {C.i := A.s} C | b A B {C.i := A.s} C
C → c {C.s := g(C.i)}
若直接应用上述复写规则的处理方法，则在使用 C → c 进行归
约时，C.i 的值或存在于次栈顶（top-1），或存在于次次栈顶（top-
2），不能确定用哪一个. 
一种可行的做法是引入新的非终结符 M，将以上翻译方案改造为：
 S → a A {C.i := A.s} C | b A B {M.i := A.s} M {C.i := M.s} C
C → c {C.s := g(C.i)}
M → ε {M.s := M.i }
这样，在使用C → c 进行归约时，C.i 的值就一定可以通过访问次栈
顶（top-1）得到
THSS 44100593 2024 / 6A-216
翻译方案
◇ 基于翻译方案的自下而上语义处理（翻译）
− 继承属性的模拟求值举例
 考虑如下翻译方案：
 S → a A {C.i := f(A.s)} C
这里，继承属性 C.i 不是通过复写规则来求值，而是通过普通函数
f(A.s) 调用来计算. 在计算 C.i 时，A.s 在语义栈上，但 f(A.s)并未
存在于语义栈. 
同样，一种做法是引入新的非终结符M，将以上翻译方案改造为：
 S → a A {M.i := A.s} M {C.i := M.s} C
M →ε {M.s := f(M.i)}
这样，就解决了上述问题。
注：从翻译方案中去掉嵌在产生式中间的语义规则集时，若语义
规则集中有关联的属性，则可参照此例的解决方案
THSS 44100593 2024 / 6A-216
类型检查
类型检查
THSS 44100593 2024 / 6A-216
◇ 静态语义分析的主要工作
− 静态语义检查
• 类型检查（type checks）
 检查每个操作是否遵守语言类型系统的定义
• 名字的作用域（scope）分析 
 建立名字的定义和使用之间联系
• 控制流检查（flow-of-control checks）
 控制流语句必须使控制转移到合法的地方（如 break 
语句必须有合法的语句包围它）
• 唯一性检查（uniqueness checks） 很多场合要求对
 象只能被定义一次（如枚举类型的元素不能重复出现）
• 名字相关检查（name-related checks）
 （如，一些名字可能被要求配对出现）
• ……
静态语义分析
THSS 44100593 2024 / 6A-216
◇ 语义处理的环境
− 符号表（symbol tables）
• 名字信息建立后加入/更改符号表
 名字信息如：类型，偏移地址，占用空间等
• 需要获取名字信息时，查找符号表
• 符号表的组织可以体现名字作用域规则
静态语义分析
语法
分析
器
类型
检查
器
中间
代码
生成
器
语 法
树
语 法
树
中间
表示
记号
流
◇ 类型检查（自学）
THSS 44100593 2024 / 6A-216
Chapter 6
符号表与运行时
存储组织
THSS 44100593 2024 / 6A-216
◇ 符号表的作用
符号表
关于符号表的操作
◇ 关于符号表的操作
符号表的常见属性
◇ 符号表的常见属性
符号表的实现
◇ 符号表的实现
THSS 44100593 2024 / 6A-216
◇ 符号表的作用
符号表
− 用来存放有关标识符的属性信息
• 这些信息会在编译的不同阶段用到
• 在语义分析中，符号表所登记的内容将用于语义检
 查和产生中间代码
• 在目标代码生成阶段，符号表是对符号名进行
 地址分配的依据
• 对一个多遍扫描的编译程序，不同遍所用的符号表
 也会有所不同，因为每遍所关心的信息会有差异
− 用来体现作用域信息
THSS 44100593 2024 / 6A-216
符号表
符号表的常见属性
◇ 符号表的常见属性
− 符号名
− 符号的类型
− 符号的存储类别和存储分配信息
− 符号的作用域/可见性
− 其他属性
• 数组内情向量
• 记录结构的成员信息
• 函数及过程的形参
THSS 44100593 2024 / 6A-216
符号表
关于符号表的操作
◇ 关于符号表的操作
− 创建符号表 在编译开始，或进入一个分程序
− 插入表项 在遇到新的标识符声明时进行
− 查询表项 在引用标识符时进行
− 修改表项 在获得新的语义值信息时进行
− 删除表项 在标识符成为不可见/不再需要它的任何
 信息时进行
− 释放符号表空间 在编译结束前或退出一个分程序
THSS 44100593 2024 / 6A-216
符号表
符号表的实现
◇ 符号表的实现
− 表项属性信息的组成
• 把属性种类完全相同的那些符号组织在一起，构
 造出多张符号表：常数表、变量名表、过程名表,
标号表,等等
• 把程序中的所有符号都组织在一张符号表中，组
 成一张包括了所有属性的庞大的符号表
THSS 44100593 2024 / 6A-216
符号表
符号表的实现
◇ 符号表的实现
− 实现符号表的常用数据结构
• 一般的线性表
 如：数组、链表，等
• 有序表
 查询较无序表快，如可以采用折半查找
• 二叉搜索树
• Hash表
THSS 44100593 2024 / 6A-216
符号表
符号表的实现
◇ 符号表的实现
− 名字域（表项的关键字域）的组织
• 可采用关键字池解决名字串长短不一带来空间浪
 费的问题
− 其他域的组织
• 解决好不等长属性值问题
 一般不把所有属性值都放在符号表项的某个域中，
 而是另辟空间存放属性值（如数组的内情向量）
THSS 44100593 2024 / 6A-216
符号表
◇ 某编译器的符号表实例（处理到第13行时的情形）
(1) class Computer {
(2) int cpu;
(3) void Crash(int nTimes) {
(4) int i;
(5) …
(6) }
(7) }
(8) class Mac extends Computer {
(9) int mouse;
(10) }
(11) void main() {
(12) class Mac powerbook;
(13) powerbook.Crash(2);
(14) …
(15) }
global
function
local
Computer
Mac
class
class
main
powerbook variable class Mac
nil
Computer类的描述
parent
field
nil cpu
crash function
function
variable int
Mac类的描述
parent
mouse variable int field
略
略
作用域栈
local作用域的符号表
global作用域的符号表
Computer类成员符号表
Mac类成员符号表
top
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 运行时存储组织的作用与任务
存储分配策略
◇ 存储分配策略
程序在存储器中的布局
◇ 程序在存储器中的布局
活动记录
◇ 活动记录 垃圾回收 （ 见王欧槿 、 葛冠辰讲解 ）
◇ 垃圾回收（见王欧槿、葛冠辰讲解）
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 运行时存储组织的作用与任务
− 代码生成前如何安排目标机资源的使用
− 几个问题
• 数据表示 如何在目标机中表示每个源语言类型的值
• 存储分配 如何组织不同作用域变量的存储
• 表达式计算 如何组织表达式的计算
• 过程实现 如何以例程实现过程/函数调用，参数传递
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 数据表示
− 源程序中数据对象在内存或寄存器中的表示形式
• 源程序中数据对象的属性
 名字（name），类型（type），值（value）,
成分（component），偏移地址（offset）， ……
• 数据对象在内存或寄存器中的表示形式
 位、字节、字、字节序列、……
• 有些机器要求数据存放时要按某种方式对齐（align）
 如：要求所有数据存放的起始地址为能够被4整除
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 数据表示举例（32位处理器）
− 基本类型数据 
 char 数据 1 byte integer 数据 4 bytes
float 数据 8 bytes boolean 数据 1 bit / 1 byte
指针 4 bytes
数组 一块连续的存储区（按行/列存放）
 结构/记录 所有域（field)存放在一块连续的存储区
 对象 实例变量像结构的域一样存放在一块连续的存储
 区，方法（成员函数）存放在其所属类的代码区
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 程序在存储器中的布局（layout）
− 典型的程序布局
• 代码段
 存放目标代码
• 静态数据段
 静态存放全局数据
• 动态数据段
 运行时动态变化的堆区和栈区
Code
Static Data
Free Space
Heap Space
↓
↑
Stack Space
Lowest address
Highest address
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 存储分配策略
− 静态分配
• 在编译期间为数据对象分配存储
− 动态分配
• 栈式分配
 将数据对象的运行时存储按照栈的方式来管理
• 堆式分配
 从数据段的堆空间分配和释放数据对象的运行时存储
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 静态存储分配
− 在编译期间就可确定数据对象的大小
• 不能处理递归过程或函数
− 某些语言中所有存储都是静态分配
• 如汇编语言，FORTRAN语言
− 多数语言只有部分存储进行静态分配
• 可静态分配的数据对象如大小固定且在程序执行期间
 可全程访问的全局变量，以及程序中的常量（literals，
 constants）
• 如 C 语言中的 static 和 extern 变量
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 栈式存储分配
− 用于有效实现层次嵌套的程序结构
• 如实现过程/函数，块层次结构
− 可以实现递归过程/函数
• 比较：静态分配无法实现递归过程/函数
− 运行栈中的数据单元是活动记录（activation record)
（专门介绍）
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 堆式存储分配
− 从堆空间为数据对象分配/释放存储
• 灵活 数据对象的存储分配和释放不限时间和次序
− 显式的分配或释放（explicit allocation / deallocation）
• 程序员负责应用程序的（堆）存储空间管理（借助于）
 编译器和运行时系统所提供的默认存储管理机制
− 隐式的分配或释放（implicit allocation / deallocation）
• （堆）存储空间的分配或释放不需要程序员负责，由
 编译器和运行时系统自动完成
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 堆式存储分配
− 堆空间的管理
• 分配算法 面对多个可用的存储块，选择哪一个
 如：最佳适应算法（选择浪费最少的存储块）
 最先适应算法（选择最先找到的足够大的存储块）
 循环最先适应算法（起始点不同的最先适应算法）
• 碎片整理算法 压缩合并小的存储块，使其更可用
（ 部分内容可参考数据结构和操作系统课程）
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 活动记录
− 过程活动记录
• 函数/过程调用或返回时，在运行栈上创建或从运行栈
 上消去的栈帧（frame） 
 包含函数实参、局部变量、临时值（用于表达式计算的
 中间单元）等数据信息以及必要的控制信息
控制信息
数据信息
活动记录起始地址
（通常存于某寄存器中）
某个数据对象的地址=
活动记录起始地址
 + 偏移地址(offset)
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 活动记录
− 过程活动记录的栈式分配举例
main 的活动记录
void p( ) { 
…
q( );
} 
void q( ) { 
…
q( );
} 
int main {
p( );
}
p 的活动记录
q 的活动记录
q 的活动记录
函数 q 被第二次激活时运
行栈上活动记录分配情况
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 活动记录
− 典型的过程活动记录形式
过程实际参数
控制信息
固定大小的局部数据区
动态数组区
临时工作单元
TOP_SP（基址寄存器）
TOP（栈顶寄存器）
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 活动记录
− 嵌套过程语言的栈式分配
• 主要问题
 解决对非局部量的引用（存取）
• 解决方案
 采用 Display 寄存器表
 为活动记录增加静态链域
program Main( I,O)；
procedure P;
procedure Q;
procedure R;
begin
… 
end; /*R*/
begin
… R; …
end; /*Q*/
begin
… Q; …
end; /*P*/
procedure S;
begin
… P; …
end; /*S*/
begin
… S; …
end. /*main*/
P
Q
S
R
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 活动记录
− 嵌套过程语言的栈式分配
• 采用 Display 寄存器表
 Display 寄存器表（简称 Display 表） 记录各嵌套层
 当前过程的活动记录在运行栈上的起始位置（基地址）
 当前激活过程的层次为K（主程序的层次设为0），
 则对应的 Display 表含有 K+1 个单元，依次存放着
 现行层，直接外层……直至最外层的每一过程的最新
 活动记录的基地址
 嵌套作用域规则确保每一时刻Display 表内容的唯一性
 Display 表的大小（即最多嵌套的层数）取决于实现
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 活动记录
− 嵌套过程语言的栈式分配
• Display 表方案举例
program Main( I,O)；
procedure P;
procedure Q;
procedure R;
begin
… /*here*/
end; /*R*/
begin
… R; …
end; /*Q*/
begin
… Q; …
end; /*P*/
procedure S;
begin
… P; …
end; /*S*/
begin
… S; …
end. /*main*/ main 的活动记录
P 的活动记录
Q 的活动记录
R 的活动记录
过程 R 被第一次激活后运行栈和
Display 寄存器 D[i] 的情况
S 的活动记录
TOP
D[0]
D[1]
D[2]
D[3]
P
Q
S
R
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 活动记录
− 嵌套过程语言的栈式分配
• Display 表的维护（过程被调用和返回时的保存和恢复）
方法一 极端的方法是把整个 Display 表存入活动记录
 若过程为第 n 层，则需要保存 D[0] ~D[n] 。
 一个过程被调用时，从调用过程的 Display 
表中自下向上抄录 n 个 SP 值，再加上本层
 的 SP 值
方法二 只在活动记录保存一个 Display 表项
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 活动记录
− 嵌套过程语言的栈式分配
• Display 表的维护举例
program Main( I,O)；
procedure P;
procedure Q;
procedure R;
begin
… /*here*/
end; /*R*/
begin
… R; …
end; /*Q*/
begin
… Q; …
end; /*P*/
procedure S;
begin
… P; …
end; /*S*/
begin
… S; …
end. /*main*/ main 的活动记录
P 的活动记录
Q 的活动记录
全局Display 表
保存完整的全局Display 表
S 的活动记录
TOP
D[0]
D[1]
D[2]
D[3]
R 的活动记录 P
Q
S
R
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 活动记录
− 嵌套过程语言的栈式分配
• 采用静态链（static link）
 Display 表的方法要用到多个寄存器，有时并不情愿
 这样做（寄存器资源很宝贵） ，一种可选的方法是采
 用静态链，只保留一个寄存器（即SP）指向当前 AR
所有活动记录都增加一个静态链（如在offset 为 0 处）
 的域，指向定义该过程的直接外过程（或主程序）运
 行时最新的活动记录
 在过程返回时当前 AR 要被撤销。为回卷（unwind）
 到调用过程的AR（恢复SP），还需增加一个动态链
 （静态链/访问链：SL，动态链/控制链：DL ）
THSS 44100593 2024 / 6A-216
运行时存储组织
◇ 活动记录
− 嵌套过程语言的栈式分配
• 采用静态链的方法举例
program Main( I,O)；
procedure P;
procedure Q;
procedure R;
begin
… /*here*/
begin
end; /*R*/
… R; …
end; /*Q*/
begin
… Q; …
end; /*P*/
procedure S;
begin
… P; …
end; /*S*/
begin
… S; …
end. /*main*/
main 的活动记录
P 的活动记录
Q 的活动记录
第一次运行至/*here*/时的栈状态
S 的活动记录
TOP
R 的活动记录 静
态
链
动
态
链
P
Q
S
R
THSS 44100593 2024 / 6A-216
44
Chapter 7. 中间代码生成及优化
Chapter 7.中间代码生成及优化
- 用语法制导定义和翻译方案的方法来展
示程序设计语言的结构怎样被翻译成中
间形式 
语法
分析
器
静态
检查
器
中间
代码
生成
器
中间
代码
记号
流
代码
生成
器
THSS 44100593 2024 / 6A-216
45
Outline
中间代码生成 中间代码 声明语句 赋值语句 布尔表达式 控制语句 拉链与代码回填
◇ 中间代码生成
√ 中间代码
√ 声明语句
√ 赋值语句
√ 布尔表达式
√ 控制语句
√ 拉链与代码回填 代码生成
◇ 代码生成 代码优化基础
◇ 代码优化基础
THSS 44100593 2024 / 6A-216
46
− 源程序的一种内部表示形式
− 作用
• 源语言和目标语言之间的桥梁，避开二者
 之间较大的语义跨度，使编译程序的逻辑
 结构更加简单明确
• 利于编译程序的重定向
• 利于进行与目标机无关的优化
◇ 中间代码
中间语言
THSS 44100593 2024 / 6A-216
47
− 有不同层次不同目的之分
− 中间代码举例
• AST（Abstract syntax tree，抽象语法树）
• DAG（Directed Acyclic Graph,有向无环图）
• Postfix（后缀式，逆波兰式）
• TAC（ Three-address code,三地址码）
• P-code （特别用于 Pascal 语言实现）
◇ 中间代码的形式
中间语言
THSS 44100593 2024 / 6A-216
48
− 顺序的语句序列 其语句一般具有如下形式
 x := y op z
(op 为操作码，y 和 z 为操作符， x 为结果)
◇ 三地址码TAC
− 表达式 x + y * z 翻译成的三地址语句序列是
 t
1
:= y * z
t
2
:= x + t
1
中间语言
THSS 44100593 2024 / 6A-216
49
− 算术表达式 A + B * ( C - D ) + E / ( C - D ) ^N
（中缀形式）
• TAC（ Three-address code,三地址码，
可以用四元式表示）
 (1) ( - C D T1) T1 := C - D
(2) ( * B T1 T2) T2 := B * T1
(3) ( + A T2 T3) T3 := A + T2
(4) ( - C D T4) 或 T4 := C - D
(5) ( ^ T4 N T5) T5 := T4 ^ N
(6) ( / E T5 T6) T6 := E / T5
(7) (+ T3 T6 T7) T7 := T3 + T6
◇ 中间代码举例
中间语言
THSS 44100593 2024 / 6A-216
50
• 为局部名字建立符号表条目
• 为它分配存储单元
• 符号表中包含名字的类型和分配给它的
存储单元的相对地址等信息
声明语句
THSS 44100593 2024 / 6A-216
51
− 语义属性
 id.lexeme : id 的词法名字（符号表中的名字） 
 T.type : 类型属性
 T.width : 数据宽度（字节数）
 offset : 相对于过程数据区基址的下一个可用的相
 对偏移地址（参考运行时存储组织）
− 语义函数/过程
 put (id.lexeme ,T.type, offset) : 将符号表中
 id.lexeme 所对应表项的 type 域置为 T.type,
填入其在过程数据区中的相对地址offset。
◇ 过程中声明语句的语法制导翻译
声明语句
THSS 44100593 2024 / 6A-216
52
◇ 过程中声明语句的语法制导翻译
− 翻译方案
P → { offset := 0 } D ; S
D → D1
; D2
D → id ：T { top.put (id.lexeme ,T.type, offset)；
 offset := offset+T.width } 
T → char { T.type := char ; T.width := 1 } 
T → integer { T.type := integer ; T.width := 4 } 
T → real { T.type := real ; T.width := 8 } 
T → array [ num ] of T1 { T.type := array ( num.val, T1
.type ) ;
T.width := num.val × T1
.width } 
T → ↑ T1 { T.type := pointer ( T1
.type ) ;
T.width := 4 } 
S → …
计算被声明名字的类型和相对地址
声明语句
THSS 44100593 2024 / 6A-216
53
− 语义属性
 id.lexeme : id 的词法名字（符号表中的名字） 
 E.code : 求值 E 的 TAC 语句序列
 E.place : 用来存放 E 的值的名字
− 语义函数/过程
 get ( id.lexeme ) : 从符号表中查找名字为 id.lexeme
的项，返回存放相应值的指针，若无该项，则返回nil
gen : 生成一条 TAC 语句
 newtempt : 返回一个未使用过的名字
◇ 赋值语句的语法制导翻译
赋值语句
THSS 44100593 2024 / 6A-216
54
◇ 赋值语句的语法制导定义（三地址码）
产生式
S → id := E
E → E1 + E2
E → - E1
E → ( E1 ) 
E → id
语义规则
 S.code := E.code || gen (top.get(id.lexeme) 6:=’ E.place)
E.place := newtemp;
E.code := E1
.code || E2
.code || 
gen (E.place 6:〓’ E1
.pIace 6+’ E2
.place) 
E.place := newtemp; E.code := E1
.code || 
gen (E.place 6:〓’ 6uminus’ E1
.place) 
E.place := E1
.place ; E.code := E1
.code 
E.place := top.get(id.lexeme);
E.code :〓 6’ 
赋值语句
THSS 44100593 2024 / 6A-216
55
S → id := E {p := top.get(id.lexeme);
if p ≠ nil then
emit ( p,
‘:=’, E.place)
else error }
E → E1
+ E2
{E.place := newtemp;
emit (E.place,
‘:=’, E1
.place, ‘+’, E2
.place) }
赋值语句
◇ 符号表中的名字
THSS 44100593 2024 / 6A-216
56
E → −E1
{E.place := newtemp;
emit (E.place,
‘:〓’, ‘uminus’, E1
.place) }
E → (E1
) {E.place := E1
.place }
E → id {p := top.get(id.lexeme);
if p ≠ nil then E.place := p else error }
赋值语句
THSS 44100593 2024 / 6A-216
57
一维数组A的第i个元素的地址计算
base + ( i − low ) × w
重写成
i × w + (base − low × w)
减少了运行时的计算
赋值语句
◇ 数组元素的地址计算
THSS 44100593 2024 / 6A-216
58
二维数组
• 列为主
A[1, 1], A[2, 1], A[1, 2], A[2, 2], A[1, 3], A[2, 3]
• 行为主
A[1, 1], A[1, 2], A[1, 3], A[2, 1], A[2, 2], A[2, 3]
base + ( (i
1
− low1
) × n2
+ (i
2
− low2
) ) × w
（其中n2
= high2
− low2
+ 1）
( (i
1
× n2
) + i
2
) × w +
(base − ( (low1
× n2
) + low2
) × w)
赋值语句
THSS 44100593 2024 / 6A-216
59
多维数组
A[i
1
, i
2
, ..., i
k
]的地址表达式
( (… ( (i
1
× n2
+ i
2
) × n3
+ i
3
) … ) × nk
+ i
k
) × w
+ base − ( ( … ( (low1
× n2
+ low2
) × n3
+ low3
) … ) × nk
+
lowk
) × w
赋值语句
THSS 44100593 2024 / 6A-216
60
− 数组的内情向量（dope vector）
 在处理数组时，通常会将数组的有关信息记录在一些单
 元中，称为“内情向量”. 
• 对于静态数组，内情向量可放在符号表中；
• 对于可变数组，运行时建立相应的内情向量.
 例： 对于静态数组说明 A[l
1
:u1
,l
2
:u2
,…,l
n
:un
] ，可以在符
 号表中建立如下形式的内情向量:
l
1
u1
l
2
u2
l
n
un
type a
n C
… …
l
i : 第 i 维的下界
ui : 第 i 维的上界
type: 数组元素的类型
a: 数组首元素的地址
n: 数组维数
C: 随后解释
赋值语句
THSS 44100593 2024 / 6A-216
61
◇ 翻译方案
◇ 符号表
Conclusions
运行时存储组织 活动记录 静态链 动态链
◇ 运行时存储组织
√ 活动记录
√ 静态链
√ 动态链 中间代码生成 中间代码 声明语句 赋值语句
◇ 中间代码生成
√ 中间代码
√ 声明语句
√ 赋值语句
◇ 类型检查
THSS 44100593 2024 / 6A-216
62
Conclusions
THSS 44100593 2024 / 6A-216
63
推荐教学资料
◇ §7.1 - 7.4
◇ §6.1 - 6.4
◇ §5.3 - 5.5
THSS 44100593 2024 / 6A-216
课外学习建议
THSS 44100593 2024 / 6A-216
65
Thank you!
THSS 44100593 2024 / 6A-216
本次课程是
线下教学
请现场的同学们：
打开雨课堂，点击页面右下角喇叭
按钮调至静音状态
THSS 44100593 2024 / 6A-216
Outline
◇ 开关语句的翻译 过程调用的翻译
◇ 过程调用的翻译 拉链与代码回填 **
◇ 拉链与代码回填**
代码生成
◇ 代码生成 流图与基本块 *
◇ 流图与基本块*
代码优化
◇ 代码优化
◇ 赋值语句的翻译
◇ 控制流语句的翻译*
THSS 44100593 2024 / 6A-216
3
− 数组元素的地址计算
 例：对于静态数组 A[l
1
:u1
,l
2
:u2
,…,l
n
:un
] ，若数组布局采
 用行优先的连续布局，数组首元素的地址为 a，则数组
 元素A[i
1
,i
2
,…,i
n
] 的地址 D 可以如下计算:
D = a + (i
1
-l
1
)(u2
-l
2
+1)(u3
-l
3
+1)…(un
-l
n
+1)
+ (i
2
-l
2
)(u3
-l
3
+1)(u4
-l
4
+1) …(un
-l
n
+1)
+…+ (i
n-1
-l
n-1
)(un
-l
n
+1) + (i
n
-l
n
)
重新整理后得: D = a – C + V ，其中
C = (…((l
1 (u2
-l
2
+1) +l
2
)(u3
-l
3
+1) + l
3
)(u4
-l
4
+1) +…+ l
n-1
)(un
-l
n
+1) + l
n
V = (…((i
1 (u2
-l
2
+1) +i2
)(u3
-l
3
+1) + i3
)(u4
-l
4
+1) +…+ i n-1
)(un
-l
n
+1) + in
（这里的 C 即为前述内情向量中的 C）
赋值语句
THSS 44100593 2024 / 6A-216
4
x := y + i * j
（x和y的类型是real，i和j的类型是integer）
中间代码
t
1
:= i int× j
t
2
:= inttoreal t
1
t
3
:= y real+ t
2
x := t
3
赋值语句
◇ 类型转换
THSS 44100593 2024 / 6A-216
5
E → E1
+ E2
E.place := newtemp
if E1
.type = integer and E2
.type = integer then begin
emit (E.place,
‘:=’, E1
.place, ‘int+’, E2
.place);
E.type = integer
end
else if E1
.type = integer and E2
.type = real then begin
u := newtemp;
emit (u,
‘:=’, ‘inttoreal’, E1
.place);
emit (E.place, ‘:=’, u, ‘real+’, E2
.place);
E.type := real
end
. . .
赋值语句
THSS 44100593 2024 / 6A-216
6
− 直接对布尔表达式求值
例如 : 可以用数值“1” 表示 true; 用数值“0” 表示 false;
采用与算术表达式类似的方法对布尔表达式进行求值
− 通过控制流体现布尔表达式的语义
方法：通过转移到程序中的某个位置来表示布尔表达式
的求值结果
优点：方便实现控制流语句中布尔表达式的翻译
常可以得到短路（short-circuit）代码，而避免不必要的
求值
◇ 布尔表达式的语法制导翻译
布尔表达式和控制流语句
E1 or E2 定义成 if E1
then true else E2
E1
and E2 定义成 if E1
then E2
else false
THSS 44100593 2024 / 6A-216
7
E → E or E | E and E | not E | ( E )
| id relop id | true | false
a < b的翻译
100: if a < b goto 103
101: t := 0
102: goto 104
103: t := 1
104:
布尔表达式和控制流语句
◇ 布尔表达式的翻译
THSS 44100593 2024 / 6A-216
8
− 直接对布尔表达式求值
◇ 布尔表达式的翻译方案
E → E1 or E2
E → E1 and E2
E → not E1
E → ( E1 ) 
E → id1
relop
id2
E → true
E → false
{ E.place := newtemp; 
emit (E.place ‘:=’ E1
.place ‘or’ E2
.place) }
{ E.place := newtemp; 
emit (E.place ‘:=’ E1
.place ‘and’ E2
.place) }
{ E.place := newtemp;
emit (E.place ‘:=’ ‘not’ E1
.place) }
{ E.place := E1
.place }
{ E.place := newtemp; emit ( ‘if’ id1
.place 
relop.op id2
.place ‘goto’ nextstat+3);
emit (E.place ‘:=’ ‘0’); emit (‘goto’ nextstat+2);
emit (E.place ‘:=’ ‘1’) }
{ E.place := newtemp; emit(E.place ‘:=’ ‘1’) }
{ E.place := newtemp; emit(E.place ‘:=’ ‘0’) }
nextstat 返回输出代码序列
中下一条 TAC 语句的下标
布尔表达式和控制流语句
THSS 44100593 2024 / 6A-216
9
如果E是a < b的形式，
那么代码是：
if a < b goto E.true
goto E.false
布尔表达式和控制流语句
◇ 布尔表达式的控制流翻译
THSS 44100593 2024 / 6A-216
10
− 通过控制流体现布尔表达式的语义
 例 : 布尔表达式 E = a<b or c<d and e<f 可能翻译为如
 下TAC 语句序列（采用短路代码，E.true 和E.false
分别代表 E 为真和假时对应于程序中的位置，可用
 标号体现）：
 （1）if a<b goto E.true
（2）goto (3) 
（3）if c<d goto (5) 
（4）goto E.false
（5）if e<f goto E.true
（6）goto E.false
◇ 布尔表达式的语法制导翻译
布尔表达式和控制流语句
THSS 44100593 2024 / 6A-216
11
E → E1 or E2
{E1
.true := E.true;
E1
.false := newlabel;
E2
.true := E.true;
E2
.false := E.false;
E.code := E1
.code || gen(E1
.false,
‘:’) || E2
.code }
E → not E1
{E1
.true := E.false;
E1
.false := E.true;
E.code := E1
.code }
布尔表达式和控制流语句
− 三地址码形式（短路代码）
◇ 布尔表达式的语法制导定义
THSS 44100593 2024 / 6A-216
12
E → E1
and E2
{E1
.true := newlabel;
E1
.false := E.false;
E2
.true := E.true;
E2
.false := E.false;
E.code := E1
.code || gen(E1
.true,
‘:’) || E2
.code }
E → (E1
)
{E1
.true := E.true;
E1
.false := E.false;
E.code := E1
.code }
布尔表达式和控制流语句
THSS 44100593 2024 / 6A-216
13
E → id1
relop id2
{E.code := gen(‘if’, id1
.place, relop.op, id2
.place,
‘goto’, E.true) ||
gen(‘goto’, E.false) }
E → true
{E.code := gen(‘goto’, E.true)}
E → false
{E.code := gen(‘goto’, E.false)}
布尔表达式和控制流语句
THSS 44100593 2024 / 6A-216
14
S → if E then S1
| if E then S1
else S2
| while E do S1
| S1
; S2
布尔表达式和控制流语句
◇ 控制流语句的翻译
THSS 44100593 2024 / 6A-216
15
E.code
S1
.code
E.true:
. . .
指向E.true
指向E.false
(a) if-then
E.code
S1
.code
E.true:
. . .
指向E.true
指向E.false
E.false:
goto S.next
S2
.code
(b) if-then-else
E.code
S1
.code
E.true:
. . .
指向E.true
指向E.false
goto S.begin
S.begin:
(c) while-do
S1
.code
S2
.code
S1
.next:
. . .
(d) S1
; S2
布尔表达式和控制流语句
THSS 44100593 2024 / 6A-216
16
◇ 条件语句的语法制导定义
E.code
S1
.code
E.true:
E.false: ……
to E.true
to E.false
newlabel 返回一个新的语句标号
S.next 属性表示 S 之后要执行的
首条 TAC 语句的标号（这里，未
体现对S.next 的初始化）
布尔表达式和控制流语句
− if-then 语句
 S → if E then S1
{
E.true := newlabel;
E.false := S.next;
S1
.next := S.next;
S.code := E.code || 
gen(E.true ‘:’) || 
S1
.code
}
THSS 44100593 2024 / 6A-216
17
◇ 条件语句的语法制导定义
E.code
S1
.code
E.true:
E.false: goto S.next
to E.true
to E.false
……
S2
.code
S.next:
布尔表达式和控制流语句
− if-then-else 语句
 S → if E then S1 else S2
{
E.true := newlabel;
E.false := newlabel;
S1
.next := S.next;
S2
.next := S.next;
S.code := E.code || 
gen(E.true ‘:’) || 
S1
.code || 
gen(‘goto’ S.next) ||
gen(E.false ‘:’) ||
S2
.code
}
THSS 44100593 2024 / 6A-216
18
◇ 循环语句的语法制导定义
E.code
S1
.code
S.begin:
E.false:
goto S.begin
to E.true
to E.false
……
E.true:
布尔表达式和控制流语句
− while 语句
 S → while E do S1
{
S.begin := newlabel;
E.true := newlabel;
E.false := S.next;
S1
.next := S.begin;
S.code := gen(S.begin ‘:’)
|| E.code
|| gen(E.true ‘:’)
|| S1
.code
|| gen(‘goto’ S.begin)
}
THSS 44100593 2024 / 6A-216
19
S → S1
; S2
{
S1
.next := newlabel;
S2
.next := S.next;
S.code := S1
.code || gen(S1
.next,
‘:’) || S2
.code
}
S1
.code
S2
.code
S1
.next:
布尔表达式和控制流语句
… …
− S1
;S2 语句
THSS 44100593 2024 / 6A-216
20
switch ( E )
{
case V1
: S1
case V2
: S2
. . .
case Vn - 1
: Sn - 1
default: Sn
}
布尔表达式和控制流语句
◇ 分支语句的翻译
THSS 44100593 2024 / 6A-216
21
― 分支数较少时
t := E的代码 | Ln-2
: if t ≠ Vn-1 goto Ln-1
if t ≠ V1 goto L1
| Sn -1的代码
S1的代码 | goto next
goto next | Ln-1
: Sn的代码
L1
: if t ≠ V2 goto L2
| next:
S2的代码
goto next
L2
: . . .
. . .
布尔表达式和控制流语句
THSS 44100593 2024 / 6A-216
22
― 分支较多时，将分支测试的代码集中在一起，便于生成较好
的分支测试代码。
t := E的代码 | Ln
: Sn的代码
goto test | goto next
L1
: S1的代码 |test: if t = V1 goto L1
goto next | if t = V2 goto L2
L2
: S2的代码 | . . .
goto next | if t = Vn-1 goto Ln-1
. . . | goto Ln
Ln-1
: Sn -1的代码 | next:
goto next
布尔表达式和控制流语句
THSS 44100593 2024 / 6A-216
23
― 过程调用 id(E1
, E2
, …, En
)
的中间代码结构
E1
.place := E1 的代码
E2
.place := E2 的代码
. . . . . .
En
.place := En 的代码
param E1
.place
param E2
.place
. . . . . .
param En
.place
call id.place, n
布尔表达式和控制流语句
◇ 过程调用的翻译
S → call id (Elist)
Elist → Elist, E
Elist → E
THSS 44100593 2024 / 6A-216
24
S → call id (Elist)
{为长度为n的队列中的每个 E.place，
emit(‘param’, E.place);
emit(‘call’, id.place, n) }
Elist → Elist, E
{把 E.place 放入队列末尾}
Elist → E
{将队列初始化，并让它仅含 E.place}
布尔表达式和控制流语句
THSS 44100593 2024 / 6A-216
25
− 简单过程调用的翻译
• 示例：过程调用 CALL S (A + B, A * B)
将被翻译为：
 计算 A + B 置于 T 中的代码 // T:= A + B
 计算 A * B 置于 Z 中的代码 // Z:= A * B
 param T // 第一个实参地址
 param Z // 第二个实参地址
 call S, 2 // 转子指令
◇ 过程调用的语法制导翻译
布尔表达式和控制流语句
THSS 44100593 2024 / 6A-216
26
中间代码生成
◇ 拉链与代码回填
− 重新审查前面几个和控制流有关的语法制导定义，
 在条件、循环语句及体现布尔表达式语义的控制
 流中，一系列语句标号的属性值计算时可能需要
 多遍扫描分析树。
− 下面介绍一种效率较高的拉链与代码回填
 （backpatching）技术处理此问题，相应于
 上述语法制导定义给出采用此技术的翻译方案。
THSS 44100593 2024 / 6A-216
27
中间代码生成
◇ 拉链与代码回填
− 语义属性
 E.truelist : “真链”，链表中的元素表示 一系列跳转语
 句的地址，这些跳转语句的目标标号是体现布
 尔表达式 E 为“真”的标号
 E. falselist : “假链”，链表中的元素表示 一系列跳转语
 句的地址，这些跳转语句的目标标号是体现布
 尔表达式 E 为“假”的标号
 S. nextlist : “next 链”，链表中的元素表示 一系列跳转
 语句的地址，这些跳转语句的目标标号是在执
 行序列中紧跟在之后的下一条TAC语句的标号
THSS 44100593 2024 / 6A-216
28
中间代码生成
◇ 拉链与代码回填
− 语义函数/过程
 makelist(i) : 创建只有一个结点 i 的表，对应存放目标
 TAC 语句数组的一个下标
 merge(p1
,p2
) : 连接两个链表 p1 和 p2 ，返回结果链表
 backpatch(p,i) : 将链表 p 中每个元素所指向的跳转语句
 的标号置为 i
nextstm : 下一条TAC 语句的地址
 emit (…) : 输出一条TAC 语句，并使 nextstm 加1
THSS 44100593 2024 / 6A-216
29
中间代码生成
◇ 拉链与代码回填
− 处理布尔表达式的翻译方案
E → E1 or M E2
E → E1 and M E2
E → not E1
{ backpatch(E1
.falselist,M.gotostm) ; 
E.truelist := merge(E1
.truelist, E2
.truelist) ; 
E.falselist := E2
.falselist }
{ backpatch(E1
.truelist,M.gotostm) ; 
E.falselist := merge(E1
.falselist, E2
.falselist) ; 
E.truelist := E2
.truelist }
{ E.truelist := E1
.falselist ; 
E.falselist := E1
.truelist }
THSS 44100593 2024 / 6A-216
30
中间代码生成
◇ 拉链与代码回填
− 处理布尔表达式的翻译方案
E → ( E1 ) 
E → id1
rop id2
E → true
E → false
M → ε
{ E.truelist := E1
.truelist ; 
E.falselist := E1
.falselist }
{ E.truelist := makelist ( nextstm);
E.falselist := makelist ( nextstm+1);
emit ( ‘if‘ id1
.place rop.op id2
.place ‘goto _’ ); 
emit (‘goto _’) }
{ E.truelist := makelist ( nextstm);
emit (‘goto _’) }
{ E.falselist := makelist ( nextstm);
emit (‘goto _’) }
{ M.gotostm := nextstm }
THSS 44100593 2024 / 6A-216
31
中间代码生成
◇ 拉链与代码回填
− 布尔表达式 E = a<b or c<d and e<f 的翻译示意
（0）if a<b goto _
or
E.truelist={0,4}
E.falselist={3,5}
and
ε
M.gotostm=2
ε
M.gotostm=4
E.truelist={4}
E.falselist={3,5}
E.truelist={0}
E.falselist={1}
< a b
E.truelist={2}
E.falselist={3}
< c d
E.truelist={4}
E.falselist={5}
< e f
（1）goto _
（3）goto _
（2）if c<d goto _
（4）if e<f goto _
（5）goto _
(4)
(2)
THSS 44100593 2024 / 6A-216
32
中间代码生成
◇ 拉链与代码回填
− 处理条件语句的翻译方案
S → if E then M S1
{ backpatch(E.truelist,M.gotostm) ; 
S.nextlist := merge(E.falselist, S1
.nextlist) }
S → if E then M1 S1 N else M2 S2
{ backpatch(E.truelist, M1
.gotostm) ; 
backpatch(E.falselist, M2
.gotostm) ; 
S.nextlist := merge(S1
.nextlist, merge(N.nextlist, S2
.nextlist) ) }
M → ε
{ M.gotostm := nextstm }
N → ε
{ N.nextlist := makelist(nextstm); emit(‘goto _’) }
THSS 44100593 2024 / 6A-216
33
中间代码生成
◇ 拉链与代码回填
− 处理循环、复合及其它语句的翻译方案
S → while M1 E do M2 S1
{ backpatch(S1
.nextlist, M1
.gotostm) ; 
backpatch(E.truelist, M2
.gotostm) ; 
S.nextlist := E.falselist;
emit(‘goto’, M1
.gotostm)}
S → begin L end { S.nextlist := L.nextlist }
S → A { S.nextlist := nil }
L → L1
; M S
{ backpatch(L1
.nextlist, M.gotostm) ; 
L.nextlist := S.nextlist }
L → S { L.nextlist := S.nextlist }
THSS 44100593 2024 / 6A-216
34
◇ 代码生成在编译程序中的逻辑位置
词法分析
语法分析
语义分析和中间代码生成
机器无关的代码优化
针对机器的代码优化
目标代码生成
字符流
单词流
语法分析树
中间表示
优化的中间表示
目标代码
优化的目标代码
从中间表示
获取的流图
改进的流图
指令调度
寄存器分配
窥孔优化
代码生成
THSS 44100593 2024 / 6A-216
35
代码生成器的设计中的问题
• 可执行目标模块
• 可重定位目标模块
– 允许程序模块分别编译
– 调用其它先前编译好的程序模块
• 汇编语言程序 (Part II)
– 免去编译器重复汇编器的工作
– 从教学角度，增加可读性
◇ 目标程序
THSS 44100593 2024 / 6A-216
36
代码生成要考虑的主要问题
◇ 代码生成要考虑的主要问题
− 指令选择
 目标机指令集的性质决定指令选择的难易
− 寄存器分配和指派
 尽可能高效地使用寄存器
− 指令排序
 选择好计算的次序，充分利用目标机的特点
代码生成器的设计中的问题
THSS 44100593 2024 / 6A-216
37
指令选择
◇ 指令选择
− 任务
为每条中间语言语句选择恰当的目标机指令或指令序列
− 原则
• 首先要保证语义的一致性；若目标机指令系统比较完
 备，为中间语言语句找到语义一致的指令序列模板是
 很直接的（在不考虑执行效率的情形下）
• 其次要权衡所生成代码的效率（考虑时间/空间代价）
 这一点较难做到，因为执行效率往往与该语句的上下
 文以及目标机体系结构（如流水线）有关
代码生成器的设计中的问题
THSS 44100593 2024 / 6A-216
38
若不考虑目标程序的效率，指令的选择是直截了当的。
三地址语句 x := y + z（x，y和z都是静态分配）
 LD R0, y /* 把y装入寄存器R0 */
ADD R0, R0, z /* z加到R0上 */
ST x, R0 /* 把R0存入x中 */
其他算术和逻辑运算的TAC 语句与此类似，只是选择不同的目
标指令，如减运算选择指令SUB，… 
代码生成器的设计中的问题
THSS 44100593 2024 / 6A-216
39
语句序列 a := b + c 
d := a + e
的代码如下
LD R0, b
ADD R0, R0, c
ST a, R0
LD R0, a
ADD R0, R0, e
ST d, R0
代码生成器的设计中的问题
逐个语句地产生代码，常常得到低质量的代码
-- 若a不再使用，第三条也多余
-- 多余的指令
THSS 44100593 2024 / 6A-216
40
怎样为三地址语句序列生成目标代码？
begin |(1) prod := 0
prod := 0; |(2) i := 1
i := 1; |(3) t
1
:= 4* i
do begin |(4) t
2
:= a[t1
]
prod := prod + a[i] * b[i]; |(5 ) t
3
:= 4* i
i := i +1 |(6 ) t
4
:= b[t3
]
end while i <= 20 |(7 ) t
5
:= t
2
* t
4
end |(8 ) t
6
:= prod + t
5
|(9 ) prod := t
6
|(10) t
7
:= i +1
|(11) i := t
7
|(12 ) if i <= 20 goto (3)
基本块和流图
THSS 44100593 2024 / 6A-216
41
基本块 basic block ） （
◇ 基本块（basic block）
− 概念
− 基本块是指程序中一个连续的语句序列，控
制流从它的开始进入，并从它的末尾离开
− 流图
− 用有向边表示基本块之间的控制流信息，就
能得到程序的流图
基本块和流图
THSS 44100593 2024 / 6A-216
42
基本块划分算法
◇ 基本块划分算法
− 针对三地址码（TAC）
− 步骤
• 首先确定所有的入口语句（首指令, leader）
– 序列的第一个语句是入口语句
– 能由条件转移语句或无条件转移语句转到的语句是入口语句
– 紧跟在条件转移语句或无条件转移语句后面的语句是入口语句
• 每个入口语句到下一个入口语句之前的语句序列构成一
个基本块
基本块和流图
THSS 44100593 2024 / 6A-216
43
(1) prod := 0
(2) i := 1
(3) t
1
:= 4* i
(4) t
2
:= a[t1
]
(5 ) t
3
:= 4* i
(6 ) t
4
:= b[t3
]
(7 ) t
5
:= t
2
* t
4
(8 ) t
6
:= prod + t
5
(9 ) prod := t
6
(10) t
7
:= i +1
(11) i := t
7
(12 ) if i <= 20 goto (3)
(1)prod := 0
(2) i := 1
(3) t1
:= 4* i
(4) t2
:= a[t1
]
(5) t3
:= 4* i
(6) t4
:= b[t3
]
(7) t5
:= t2
* t4
(8) t6
:= prod + t5
(9) prod := t6
(10) t7
:= i +1
(11) i := t7
(12) if i <= 20 goto (3)
B1
B2
基本块和流图
基本块划分例 I
◇ 基本块划分例 I
THSS 44100593 2024 / 6A-216
44
基本块划分例 II
◇ 基本块划分例 II
− 针对三地址码（TAC）
− 举例 右边 TAC 程序可划
 分成 __ 个基本块
(1) read x
(2) read y
(3) r:=x mod y
(4) if r=0 goto (8)
(5) x:=y
(6) y:=r
(7) goto(3)
(8) write y
(9) halt
（1）
（2）
（3）
（4）
（5）
（6）
（7）
（8）
（9）
B1 B2
B3
B4
基本块和流图
4
*(1) read x
(2) read y
*(3) r:=x mod y
(4) if r=0 goto (8)
*(5) x:=y
(6) y:=r
(7) goto(3)
*(8) write y
(9) halt
THSS 44100593 2024 / 6A-216
45
流 图 flow graph ） （
◇ 流图（flow graph）
− 概念 可以为构成一个程序的基本块增加控制流信
 息，方法是构造一个有向图，称之为流图
 流图以基本块集为结点集；第一个结点为含有程序
 第一条语句的基本块；从基本块 i 到基本块 j 之间
 存在有向边，当且仅当
• 基本块 j 在程序的位置紧跟在 i 后,且 i 的出口语句不是
 无条件转移或停语句；或者
• i 的出口是 goto(S) 或 if goto(S), 而 (S) 是 j 的入口语句
基本块和流图
THSS 44100593 2024 / 6A-216
46
流 图
◇ 流图
− 举例 *(1) read x
(2) read y
*(3) r:=x mod y
(4) if r=0 goto (8)
*(5) x:=y
(6) y:=r
(7) goto(3)
*(8) write y
(9) halt
(1) read x 
(2) read y
(3) r:=x mod y
(4) if r=0 goto (8)
(5) x:=y
(6) y:=r
(7) goto(3)
(8) write y
(9) halt
B1
B2
B3
B4
基本块和流图
THSS 44100593 2024 / 6A-216
47
代码优化技术
− 依优化范围划分
• 窥孔优化（peephole optimization）
 局部的几条指令范围内的优化
• 局部优化
 基本块范围内的优化
• 全局优化
 流图范围内的优化
• 过程间优化
 整个程序范围内的优化
简单的归类
◇ 简单的归类
THSS 44100593 2024 / 6A-216
48
代码优化技术
− 依优化对象划分
• 目标代码优化
 面向目标代码
• 中间代码优化
 面向程序的中间表示
• 源级优化
 面向源程序
简单的归类
◇ 简单的归类
THSS 44100593 2024 / 6A-216
49
代码优化技术
− 依优化侧面划分
• 指令调度
• 寄存器分配
• 存储层次优化
• 循环优化
• 控制流优化
• 过程优化
• ……
简单的归类
◇ 简单的归类
THSS 44100593 2024 / 6A-216
50
代码优化技术
− 工作方式 在目标指令序列上滑动一个包含几条指令
 的窗口（称为窥孔），发现其中不够优化的指令序列，
 用一段更短或更有效的指令序列来替代它，使整个代
 码得到改进
− 虽然窥孔优化的话题主要针对目标代码的优化，但类
似的技术也可以应用于中间代码的优化
窥孔优化 peephole optimization ） （
◇ 窥孔优化（peephole optimization）
THSS 44100593 2024 / 6A-216
51
代码优化技术
− 举例
• 删除冗余的加载和保存（redundant loads and stores）
 指令序列
 （1） ST a, R0
（2） LD R0, a
可优化为
 （1） ST a, R0
窥孔优化 peephole optimization ） （
◇ 窥孔优化（peephole optimization）
THSS 44100593 2024 / 6A-216
52
代码优化技术
− 举例
• 合并已知量（constants folding）
 代码序列
 （1） r2:=3*2
可优化为
 （1） r2:=6
窥孔优化 peephole optimization ） （
◇ 窥孔优化（peephole optimization）
THSS 44100593 2024 / 6A-216
53
代码优化技术
− 举例
• 常量传播（constants propagating）
 代码序列
 （1） r2:=4
（2） r3:=r1+r2
可优化为
 （1） r2:=4
（2） r3:=r1+ 4
注：虽然条数未少，但若知道是r2不活跃时，可删除（1）
窥孔优化 peephole optimization ） （
◇ 窥孔优化（peephole optimization）
THSS 44100593 2024 / 6A-216
54
代码优化技术
− 举例
• 代数化简（algebraic simplification）
 代码序列
 （1） x:=x+0
（2） ……
（n） y:=y*1
中的（1）,（n）可在窥孔优化时删除
窥孔优化 peephole optimization ） （
◇ 窥孔优化（peephole optimization）
THSS 44100593 2024 / 6A-216
55
代码优化技术
− 举例
• 控制流优化（flow-of-control optimization）
 代码序列
 goto L1
……
L1: goto L2
可替换为
 goto L2
……
L1: goto L2
窥孔优化 peephole optimization ） （
◇ 窥孔优化（peephole optimization）
THSS 44100593 2024 / 6A-216
56
代码优化技术
− 举例
• 死代码删除（dead-code elimination）
 代码序列
 debug := false
if (debug) print …
……
可替换为
 debug := false
……
窥孔优化 peephole optimization ） （
◇ 窥孔优化（peephole optimization）
THSS 44100593 2024 / 6A-216
57
代码优化技术
− 举例
• 强度削弱（reduction in strength）
 x:=2.0*f 可替换为 x:=f+f
窥孔优化 peephole optimization ） （
◇ 窥孔优化（peephole optimization）
THSS 44100593 2024 / 6A-216
58
代码优化技术
− 举例
• 使用目标机惯用指令（use of idioms）
 某个操作数与1 相加，通常用“加1”指令，而不是
 用“加”指令
 某个定点数乘以2 ，可以采用“左移”指令；而除以2 ，
 则可以采用“右移”指令
 …
窥孔优化 peephole optimization ） （
◇ 窥孔优化（peephole optimization）
THSS 44100593 2024 / 6A-216
59
代码优化技术
− 举例
• 合并已知量
 删除多余运算（公共表达式删除）
 删除无用赋值
基本块内的优化
◇ 基本块内的优化
THSS 44100593 2024 / 6A-216
60
代码优化技术
− 借助于针对流图的数据流分析进行的优化
− 举例
• 全局公共表达式删除
 全局死代码删除（删除从流图入口不能到达的代码）
 ……
全局优化 global optimization ） （
◇ 全局优化（global optimization）
THSS 44100593 2024 / 6A-216
61
代码优化技术
− 举例
• 代码外提（code motion）
 while （i< limit/2）{…} // 无改变limit值的语句
等价于 t:=limit/2;
while （i< t）{…} 
• 循环不变量（loop-invariant）代码可以外提
 如对于循环内部的语句 x:=y+z，若 y 和 z 的定值点
 都在循环外 ，则 x:=y+z 为循环不变量
循环优化 loop optimization ） （
◇ 循环优化（loop optimization）
THSS 44100593 2024 / 6A-216
62
Conclusions
中间代码生成 过程调用语句 赋值语句 布尔表达式 条件语句 分支语句 拉链与代码回填
◇ 中间代码生成
√ 赋值语句
√ 布尔表达式
√ 条件语句
√ 分支语句
√过程调用语句
√ 拉链与代码回填 代码生成 基本块 流 图
◇ 代码生成
√ 基本块
√ 流图 代码优化基础 窥孔优化
◇ 代码优化基础
√ 窥孔优化
THSS 44100593 2024 / 6A-216
63
Conclusions
THSS 44100593 2024 / 6A-216
64
推荐教学资料
◇ §6.6–6.9
◇ §8.1, §8.4
◇ §9.1
THSS 44100593 2024 / 6A-216
65
Advanced Compiler Design and Implementation
Steven Muchnick
Morgan Kaufman Publishers, 1997
ISBN 1-55860-320-4
课外学习建议
Modern Compiler Design
Dick Grune, etc.
John Wiley & Sons Press, 2000
ISBN-10: 0-471-97697-0 
THSS 44100593 2024 / 6A-216
66
Thank you!
本次课程是
线下教学
请现场的同学们：
打开雨课堂，点击页面右下角喇叭
按钮调至静音状态
Part II: Assembly 
Language Programming
王朝坤
IISE@Tsinghua
2
CHAPTER 1: BASIC CONCEPTS
3
Chapter Overview
• Welcome to Assembly Language
• Course Information
• Data Representation
• Boolean Operations
4
Questions to Ask
• What is Assembly Language? 
• e.g.~
• Why learn Assembly Language?
• Game and real-time applications
• Optimization
• Reverse Engineering
• Anti-Virus
• Device drivers and embedded programming
• Understanding Hardware
• Mixed language programming
• Other courses: OS, DBS…
• What will I learn?
5
教学目的与重点
• 汇编语言是软件工程/计算机科学与技术专业核心内容。
• 作为理论和实践并重的学习内容，本部分将介绍汇编语
言的基本构成（指令、伪指令等）和汇编程序设计的基
本方法。具体包括
• 汇编语言基础
• 屏幕与键盘操作
• 数据操作
• 高级输入／输出
• 中断与端口
• 运算符与指令
• PC指令系统等
6
教学目的与重点 (II)
• 通过本部分的学习，学生应
• 具有使用汇编语言编写程序的能力
• 对顺序、分支、循环三大程序结构在汇编语言中的实现方
法有较好的掌握
• 对模块化程序设计技术有进一步的了解
• 了解混合程序设计
• 为深入理解计算机及其编程语言的工作原理打下基础。
• 课程实验中用汇编语言实现若干完整的程序。
7
Assembly Language Applications
• Some representative types of applications:
• Business application for single platform
• Hardware device driver
• Business application for multiple platforms
• Embedded systems & computer games
(see next panel)
8
Comparing ASM to High-Level Languages
9
What's Next
• Welcome to Assembly Language
• Course Information (for this Part)
• Data Representation
• Boolean Operations
10
Assembly Language for x86 Processors
Assembly Language for Intel-Based Computers ( < 6th Edition)
Kip Irvine
Prentice-Hall Press, 2006 (5th), 2010 (6th), 
2014 (7th), 2019 (8th) ISBN 978-0135381656
Textbooks
11
Thanks to Kip Irvine!
Slides of this course are based on that provided by Kip Irvine
Modern X86 Assembly Language 
 Programming (3rd Edition) 
Daniel Kusswurm 
APress, 2023
ISBN 978-1-4842-9602-8 
Ref.
12
The Art of Assembly Language 
 (2nd Edition)
Randall Hyde
No Starch Press, 2010
ISBN 1-59327-207-3
X64 Assembly Language Step by Step: 
Programming with Linux. 4th Edition. 2023.
Contents
C1: BASIC CONCEPTS
C2: x86 PROCESSOR ARCHITECTURE
C3: ASSEMBLY LANGUAGE FUNDAMENTALS
C4: DATA TRANSFERS, ADDRESSING, AND ARITHMETIC
C5: PROCEDURES
C6: CONDITIONAL PROCESSING
C7: INTEGER ARITHMETIC
C8: ADVANCED PROCEDURES
C9: STRINGS AND ARRAYS
C10: STRUCTURES AND MACROS
C11: MS-WINDOWS PROGRAMMING
C12: FLOATING-POINT PROCESS AND INSTRUCTION ENCODING
C13: HIGH-LEVEL LANGUAGE INTERFACE
C14: 16-BIT MS-DOS PROGRAMMING
C15: DISK FUNDAMENTALS
C16: BIOS-LEVEL PROGRAMMING
C17: EXPERT MS-DOS PROGRAMMING
13
What's Next
• Welcome to Assembly Language
• Course Information 
• Data Representation
• Boolean Operations
14
Data Representation
• Binary Numbers
• Translating between binary and decimal
• Binary Addition
• Integer Storage Sizes
• Hexadecimal Integers
• Translating between decimal and hexadecimal
• Hexadecimal subtraction
• Signed Integers
• Binary subtraction
• Character Storage
15
16
Binary Numbers
• Digits are 1 and 0
• 1 = true
• 0 = false
• MSB – most significant bit
• LSB – least significant bit
• Bit numbering:
0 15
1 0 1 1 0 0 1 0 1 0 0 1 1 1 0 0
MSB LSB
17
Binary Numbers
• Each digit (bit) is either 1 or 0
• Each bit represents a power of 2:
Every binary 
number is a 
sum of powers 
of 2
1 1 1 1 1 1 1 1
2
7
2
6
2
5
2
4
2
3
2
2
2
1
2
0
18
Translating Binary to Decimal
Weighted positional notation shows how to calculate the 
decimal value of each binary bit:
dec = (Dn-1 × 2
n-1
) + (Dn-2 × 2
n-2
) + ... + (D1 × 2
1
) + (D0 × 2
0
)
D = binary digit
binary 00001001 = decimal 9:
(1 × 2
3
) + (1 × 2
0
) = 9
Translating Unsigned Decimal to Binary
• Repeatedly divide the decimal integer by 2. Each 
remainder is a binary digit in the translated value:
37 = 100101
19
20
Integer Storage Sizes
What is the largest unsigned integer that may be stored in 20 bits?
Standard sizes:
byte
16
8
32
word
doubleword
64 quadword
Translating Binary to Hexadecimal
• Each hexadecimal digit corresponds to 4 binary bits.
• Example: Translate the binary integer 
000101101010011110010100 to hexadecimal:
21
22
Converting Hexadecimal to Decimal
• Multiply each digit by its corresponding power of 16:
dec = (D3 × 163
) + (D2 × 162
) + (D1 × 161
) + (D0 × 160
)
• Hex 1234 equals (1 × 163
) + (2 × 162
) + (3 × 161
) + (4 × 160
), or 
decimal 4,660. 
• Hex 3BA4 equals (3 × 163
) + (11 * 162
) + (10 × 161
) + (4 × 160
), or 
decimal 15,268.
Converting Decimal to Hexadecimal
decimal 422 = 1A6 hexadecimal
23
24
Hexadecimal Addition
• Divide the sum of two digits by the number base (16). The quotient 
becomes the carry value, and the remainder is the sum digit.
36 28 28 6A
42 45 58 4B
78 6D 80 C1
1 1
21 / 16 = 1, rem 5
Important skill: Programmers frequently add and subtract the 
addresses of variables and instructions.
B5
25
Hexadecimal Subtraction
• When a borrow is required from the digit to the left, add 16 
(decimal) to the current digit's value:
C6 75
A2 47
24 2E
−1
16 + 5 = 21
Practice: The address of var1 is 00400020. The address of the next 
variable after var1 is 0040006A. How many bytes are used by var1?
26
Signed Integers
The highest bit indicates the sign. 1 = negative, 
0 = positive
1 1 1 1 0 1 1 0
0 0 0 0 1 0 1 0
sign bit
Negative
Positive
If the highest digit of a hexadecimal integer is > 7, the value is 
negative. Examples: 8A, C5, A2, 9D
Forming the Two’s Complement (补码)
• Negative numbers are stored in two's complement 
notation
• Represents the additive Inverse
Note that 00000001 + 11111111 = 00000000
27
28
Binary Subtraction
• When subtracting A – B, convert B to its two's 
complement
• Add A to (–B)
0 0 0 0 1 1 0 0 0 0 0 0 1 1 0 0
– 0 0 0 0 0 0 1 1 1 1 1 1 1 1 0 1
 0 0 0 0 1 0 0 1
Practice: Subtract 0101 from 1001.
What's Next
• Welcome to Assembly Language
• Course Information
• Data Representation
• Boolean Operations
29
Boolean Operations
• NOT
• AND
• OR
• Operator Precedence
• Truth Tables
30
Boolean Algebra
• Based on symbolic logic, designed by George Boole
• Boolean expressions created from:
• NOT, AND, OR
31
Operator Precedence
• Examples showing the order of operations:
32
Truth Tables
• A Boolean function has one or more Boolean inputs, 
and returns a single Boolean output.
• A truth table shows all the inputs and outputs of a 
Boolean function
Example: →X V Y
33
CHAPTER 2: X86 PROCESSOR 
ARCHITECTURE
1
Chapter Overview
• General Concepts
• 32-Bit x86 Processors
• 64-Bit x86-64 Processors
• Components of a Typical x86 Computer
• Input-Output System
2
General Concepts
• Basic microcomputer design
• Instruction execution cycle
• Reading from memory
• How programs run
3
4
Basic Microcomputer Design
• ALU performs arithmetic and bitwise processing
• clock synchronizes CPU operations
• control unit (CU) coordinates sequence of execution steps
Central Processor Unit
(CPU)
Memory Storage
Unit
registers
ALU clock
I/O
Device
#1
I/O
Device
#2
data bus
control bus
address bus
CU
, I/O bus
Instruction Execution Cycle
• Fetch
• Decode
• Fetch operands
• Execute 
• Store output
5
Cache Memory
• High-speed expensive static RAM both inside and 
outside the CPU.
• Level-1 cache: inside the CPU
• Level-2 cache: outside the CPU
• Cache hit: when data to be read is already in cache 
memory
• Cache miss: when data to be read is not in cache 
memory.
6
What's Next
• General Concepts
• 32-Bit x86 Processors
• 64-Bit x86-64 Processors
• Components of a Typical Computer
• Input-Output System
7
IA-32 Processor Architecture
• Modes of operation
• Basic execution environment
• x86 Memory Management
8
Modes of Operation
• Protected mode
• native mode (Windows, Linux)
• Real-address mode
• native MS-DOS
• System management mode
• power management, system security, diagnostics
• Virtual-8086 mode
• hybrid of Protected
• each program has its own 8086 computer
9
Basic Execution Environment
• Addressable memory
• General-purpose registers
• Index and base registers
• Specialized register uses
• Status flags
• Floating-point, MMX, XMM registers
10
Addressable Memory
• Protected mode
• 4 GB
• 32-bit address
• Real-address and Virtual-8086 modes
• 1 MB space
• 20-bit address
11
X86-64 General-Purpose Registers
12
13
General-Purpose Registers
CS
SS
DS
ES
EIP
EFLAGS
16-bit Segment Registers
EAX
EBX
ECX
EDX
32-bit General-Purpose Registers
FS
GS
EBP
ESP
ESI
EDI
Named storage locations inside the CPU, optimized for 
speed.
14
Accessing Parts of Registers
• Use 8-bit name, 16-bit name, or 32-bit name
• Applies to EAX, EBX, ECX, and EDX
AH AL
16 bits
8
AX
EAX
8
32 bits
8 bits + 8 bits
Index and Base Registers
• Some registers have only a 16-bit name for their 
lower half:
15
16
Some Specialized Register Uses (1 of 2)
• General-Purpose
• EAX – accumulator
• ECX – loop counter
• ESP – stack pointer
• ESI, EDI – index registers
• EBP – extended frame pointer (stack)
• Segment
• CS – code segment
• DS – data segment
• SS – stack segment
• ES, FS, GS - additional segments
17
Some Specialized Register Uses (2 of 2)
• EIP – instruction pointer
• EFLAGS
• status and control flags
• each flag is a single binary bit
Status Flags
• Carry
• unsigned arithmetic out of range
• Overflow
• signed arithmetic out of range
• Sign
• result is negative
• Zero
• result is zero
• Auxiliary Carry
• carry from bit 3 to bit 4
• Parity
• sum of 1 bits is an even number
18
19
Floating-Point, MMX, XMM Registers
• Eight 80-bit floating-point data registers
• ST(0), ST(1), . . . , ST(7)
• arranged in a stack
• used for all floating-point 
arithmetic
• Eight 64-bit MMX registers
• Eight 128-bit XMM registers for single￾instruction multiple-data (SIMD) operations
ST(0)
ST(1)
ST(2)
ST(3)
80-bit Data Registers
FPU Data Pointer
Tag Register
Control Register
Status Register
ST(4)
ST(5)
ST(6)
ST(7)
FPU Instruction Pointer
Opcode Register
16-bit Control Registers
48-bit Pointer Registers
x86 Memory Management
• Real-address mode
• Calculating linear addresses
• Protected mode
• Multi-segment model
• Paging
• (see Chapter 11)
20
Real-Address mode
• 1 MB RAM maximum addressable
• Application programs can access any area 
of memory
• Single tasking
• Supported by MS-DOS operating system
21
22
Segmented Memory
Segmented memory addressing: absolute (linear) address is a 
combination of a 16-bit segment value added to a 16-bit offset 
00000
10000
20000
30000
40000
50000
60000
70000
80000
90000
A0000
B0000
C0000
D0000
E0000
F0000
8000:0000
8000:FFFF
seg ofs
8000:0250
0250
one segment
Calculating Linear Addresses
• Given a segment address, multiply it by 16 (add a 
hexadecimal zero), and add it to the offset
• Example: convert 08F1:0100 to a linear address
Adjusted Segment value: 0 8 F 1 0
Add the offset: 0 1 0 0
Linear address: 0 9 0 1 0
23
24
Protected Mode (1 of 2)
• 4 GB addressable RAM
• (00000000 to FFFFFFFFh)
• Each program assigned a memory partition which 
is protected from other programs
• Designed for multitasking
• Supported by Linux & MS-Windows
25
Protected mode (2 of 2)
• Segment descriptor tables
• Program structure
• code, data, and stack areas
• CS, DS, SS segment descriptors
• global descriptor table (GDT)
• MASM Programs use the Microsoft flat memory 
model
26
Flat Segment Model
• Single global descriptor table (GDT).
• All segments mapped to entire 32-bit address space
00000000
FFFFFFFF
(4GB)
00000000
Segment descriptor, in the
Global Descriptor Table
00040 - - - -
base address limit access
00040000
physical RAM not used
27
Multi-Segment Model
• Each program has a local descriptor table (LDT)
• holds descriptor for each segment used by the program
3000
RAM
00003000
Local Descriptor Table
0002
00008000 000A
00026000 0010
base limit access
8000
26000
Paging
• Supported directly by the CPU
• Divides each segment into 4096-byte blocks called 
pages
• Sum of all programs can be larger than physical 
memory
• Part of running program is in memory, part is on disk
• Virtual memory manager (VMM) – OS utility that 
manages the loading and unloading of pages
• Page fault – issued by CPU when a page must be 
loaded from disk
28
What's Next
• General Concepts
• 32-Bit x86 Processors
• 64-Bit x86-64 Processors
• Components of a Typical x86 Computer
• Input-Output System
29
64-Bit x86-64 Processors
• x86-64
• 64-bit linear address space
• Intel64: Xeon (至强), Core i5, Core i7, and Core i9 ...
• AMD64: Opteron (皓龙), Athlon (速龙) 64, Turion (炫龙) 64 ...
• IA-32e Mode
• Compatibility mode for legacy 16- and 32-bit applications
• 64-bit Mode uses 64-bit addresses and operands
x86-64 Assembly Information
• x86-64: http://en.wikipedia.org/wiki/X86-64
30
64-Bit Processors
• 64-Bit Operation Modes
• Compatibility mode – can run existing 16-bit and 32-bit 
applications (Windows supports only 32-bit apps in this 
mode)
• 64-bit mode – Windows 64 uses this
• Basic Execution Environment
• addresses can be 64 bits (48 bits, in practice)
• 16 64-bit general purpose registers
• 64-bit status flags register named RFLAGS (only the 
lower 32 bits are used)
• 64-bit instruction pointer named RIP
31
64-Bit General Purpose Registers
• 32-bit general purpose registers: 
• EAX, EBX, ECX, EDX, EDI, ESI, EBP, ESP, R8D, 
R9D, R10D, R11D, R12D, R13D, R14D, R15D
• 64-bit general purpose registers: 
• RAX, RBX, RCX, RDX, RDI, RSI, RBP, RSP, R8, R9, 
R10, R11, R12, R13, R14, R15
32
What's Next
• General Concepts
• 32-Bit x86 Processors
• 64-Bit x86-64 Processors
• Components of a Typical Computer
• Input-Output System
33
Components of an IA-32 Microcomputer
• Motherboard
• Video output
• Memory
• Input-output ports
34
What's Next
• General Concepts
• 32-Bit x86 Processors
• 64-Bit x86-64 Processors
• Components of a Typical x86 Computer
• Input-Output System
35
Levels of Input-Output
• Level 3: High-level language function
• examples: C++, Java
• portable, convenient, not always the fastest
• Level 2: Operating system
• Application Programming Interface (API)
• extended capabilities, lots of details to master
• Level 1: BIOS
• drivers that communicate directly with devices
• OS security may prevent application-level code from working 
at this level
36
37
Displaying a String of Characters
When a HLL program 
displays a string of 
characters, the 
following steps take 
place:
Application Program
OS Function
BIOS Function
Hardware Level 0
Level 1
Level 2
Level 3
Programming levels
Assemble language programs can perform 
input-output at each of the following levels:
38
CHAPTER 3: ASSEMBLY 
LANGUAGE FUNDAMENTALS
1
Chapter Overview
• Basic Elements of Assembly Language
• Example: Adding and Subtracting Integers
• Assembling, Linking, and Running Programs
• Defining Data
• Symbolic Constants
• 64-Bit Programming
2
3
Program Template
; Program Template (Template.asm)
; Description:
; Author:
; Creation Date:
; Revisions: 
; Date: 
; Modified by:
.386
.model flat,stdcall
.stack 4096
ExitProcess PROTO, dwExitCode:DWORD
.data
; declare variables here
.code
main PROC
; write your code here
INVOKE ExitProcess,0
main ENDP
; (insert additional procedures here)
END main
Basic Elements of Assembly Language
• Integer constants
• Integer expressions
• Character and string constants
• Reserved words and identifiers
• Directives
• Instructions
• Labels
• Mnemonics 
• Operands
• Comments
• Examples
4
Integer Constants
• Optional leading + or – sign
• binary, decimal, hexadecimal, or octal digits
• Common radix (基数后缀) characters:
• h – hexadecimal
• d – decimal
• b – binary
• o – octal
Examples: 30d, 6Ah, 42, 1101b
Hexadecimal beginning with letter: 0A5h
5
Integer Expressions
• Operators and precedence levels:
• Examples:
6
Character and String Constants
• Enclose character in single or double quotes
• 'A', "x"
• ASCII character = 1 byte
• Enclose strings in single or double quotes
• "ABC"
• 'xyz'
• Each character occupies a single byte
• Embedded quotes:
• 'Say "Goodnight," Gracie'
7
Reserved Words and Identifiers
• Reserved words cannot be used as identifiers
• Instruction mnemonics, directives, type attributes, 
operators, predefined symbols
• See MASM reference in Appendix A
• Identifiers
• 1-247 characters, including digits
• not case sensitive
• -Cp
• first character must be a letter, _, @, ?, or $
8
Directives (伪指令)
• Commands that are recognized and acted 
upon by the assembler
• Not part of the Intel instruction set
• Used to declare code, data areas, select 
memory model, declare procedures, etc.
• not case sensitive
• Different assemblers have different directives
• NASM not the same as MASM, for example
9
10
Instructions
• Assembled into machine code by assembler
• Executed at runtime by the CPU
• We use the Intel IA-32 instruction set
• An instruction contains:
• Label (optional)
• Mnemonic (required)
• Operand (depends on the instruction)
• Comment (optional)
[Label:] Mnemonic Operand(s) [; Comment]
11
Labels
• Act as place markers
• marks the address (offset) of code and data
• Follow identifier rules
• Data label
• must be unique
• example: myArray (not followed by colon)
• Code label
• target of jump and loop instructions
• example: L1: (followed by colon)
Mnemonics and Operands
• Instruction Mnemonics
• memory aid
• examples: MOV, ADD, SUB, MUL, INC, DEC
• Operands
• constant
• constant expression
• memory (data label)
• register
Constants and constant expressions are often called 
immediate values
12
13
Comments
• Comments are good!
• explain the program's purpose
• when it was written, and by whom
• revision information
• tricky coding techniques
• application-specific explanations
• Single-line comments
• begin with semicolon (;)
• Multi-line comments
• begin with COMMENT directive and a programmer￾chosen character
• end with the same programmer-chosen character
COMMENT !
;Here is the comment
 mov ax, bx
 add ax, 7
! 
14
Instruction Format Examples
• No operands
• stc ; set Carry flag
• One operand
• inc eax ; register
• inc myByte ; memory
• Two operands
• add ebx,ecx ; register, register
• sub myByte,25 ; memory, constant
• add eax,36 * 25 ; register, constant-expression
What's Next
• Basic Elements of Assembly Language
• Example: Adding and Subtracting Integers
• Assembling, Linking, and Running Programs
• Defining Data
• Symbolic Constants
• 64-Bit Programming
15
16
TITLE Add and Subtract (AddSubAlt.asm)
; This program adds and subtracts 32-bit integers.
.386
.MODEL flat,stdcall
.STACK 4096
ExitProcess PROTO, dwExitCode:DWORD
DumpRegs PROTO
.code
main PROC
mov eax,10000h ; EAX = 10000h
add eax,40000h ; EAX = 50000h
sub eax,20000h ; EAX = 30000h
call DumpRegs
INVOKE ExitProcess,0
main ENDP
END main
Example: Adding and Subtracting Integers
Example Output
Program output, showing registers and flags:
EAX=00030000 EBX=7FFDF000 ECX=00000101 EDX=FFFFFFFF
ESI=00000000 EDI=00000000 EBP=0012FFF0 ESP=0012FFC4
EIP=00401024 EFL=00000206 CF=0 SF=0 ZF=0 OF=0
17
18
Suggested Coding Standards (1 of 2)
• Some approaches to capitalization
• capitalize nothing
• capitalize everything
• capitalize all reserved words, including instruction 
mnemonics and register names
• capitalize only directives and operators
• Other suggestions
• descriptive identifier names
• spaces surrounding arithmetic operators
• blank lines between procedures
19
Suggested Coding Standards (2 of 2)
• Indentation and spacing
• code and data labels – no indentation
• executable instructions – indent 4-5 spaces
• comments: begin at column 40-45, aligned vertically
• 1-3 spaces between instruction and its operands
• ex: mov ax,bx
• 1-2 blank lines between procedures
20
; Program Template (Template.asm)
; Description:
; Author:
; Creation Date:
; Revisions: 
; Date: 
; Modified by:
.386
.model flat,stdcall
.stack 4096
ExitProcess PROTO, dwExitCode:DWORD
.data
; declare variables here
.code
main PROC
; write your code here
INVOKE ExitProcess,0
main ENDP
; (insert additional procedures here)
END main
Program Template (review)
What's Next
• Basic Elements of Assembly Language
• Example: Adding and Subtracting Integers
• Assembling, Linking, and Running Programs
• Defining Data
• Symbolic Constants
21
22
Assemble-Link Execute Cycle
• The following diagram describes the steps from creating a 
source program through executing the compiled program.
• If the source code is modified, Steps 2 through 4 must be 
repeated.
• The assembler contains a preprocessor to process directives, 
etc.
Source
File
Object
File
Listing
File
Link
Library
Executable
File
Map
File
Output
Step 1: text editor
Step 2:
assembler
Step 3:
linker
Step 4:
OS loader
Listing File
• Use it to see how your program is compiled
• Contains 
• source code
• addresses
• object code (machine language)
• segment names
• symbols (variables, procedures, and constants)
• Example: See §3.3
23
What's Next
• Basic Elements of Assembly Language
• Example: Adding and Subtracting Integers
• Assembling, Linking, and Running Programs
• Defining Data
• Symbolic Constants
• 64-Bit Programming
24
Defining Data
• Intrinsic Data Types (内部数据类型)
• Data Definition Statement
• Defining BYTE and SBYTE Data
• Defining WORD and SWORD Data
• Defining DWORD and SDWORD Data
• Defining QWORD Data
• Defining TBYTE Data
• Defining Real Number Data
• Little Endian Order
• Adding Variables to the AddSub Program
• Declaring Uninitialized Data
25
26
Intrinsic Data Types (1 of 2)
• BYTE, SBYTE
• 8-bit unsigned integer; 8-bit signed integer
• WORD, SWORD
• 16-bit unsigned & signed integer
• DWORD, SDWORD
• 32-bit unsigned & signed integer
• QWORD
• 64-bit integer
• TBYTE
• 80-bit integer
27
Intrinsic Data Types (2 of 2)
• REAL4
• 4-byte IEEE short real
• REAL8
• 8-byte IEEE long real
• REAL10
• 10-byte IEEE extended real
28
Data Definition Statement
• A data definition statement sets aside storage in memory for a 
variable.
• May optionally assign a name (label) to the data
• Syntax:
[name] directive initializer [,initializer] . . .
value1 BYTE 10
• All initializers become binary data in memory
29
Defining BYTE and SBYTE Data
value1 BYTE 'A' ; character constant
value2 BYTE 0 ; smallest unsigned byte
value3 BYTE 255 ; largest unsigned byte
value4 SBYTE -128 ; smallest signed byte
value5 SBYTE +127 ; largest signed byte
value6 BYTE ? ; uninitialized byte
Each of the following defines a single byte of storage:
• MASM does not prevent you from initializing a BYTE with a 
negative value, but it's considered poor style.
• If you declare a SBYTE variable, the Microsoft debugger will 
automatically display its value in decimal with a leading sign.
30
Defining Byte Arrays
list1 BYTE 10,20,30,40
list2 BYTE 10,20,30,40
 BYTE 50,60,70,80
 BYTE 81,82,83,84
list3 BYTE ?,32,41h,00100010b
list4 BYTE 0Ah,20h,‘A’,22h
Examples that use multiple initializers:
31
Defining Strings (1 of 3)
• A string is implemented as an array of characters
• For convenience, it is usually enclosed in quotation marks
• It often will be null-terminated
• Examples:
str1 BYTE "Enter your name",0
str2 BYTE 'Error: halting program',0
str3 BYTE 'A','E','I','O','U'
greeting BYTE "Welcome to the Encryption Demo program "
 BYTE "created by Kip Irvine.",0
32
Defining Strings (2 of 3)
• To continue a single string across multiple lines, end 
each line with a comma:
menu BYTE "Checking Account",0dh,0ah,0dh,0ah,
"1. Create a new account",0dh,0ah,
"2. Open an existing account",0dh,0ah,
"3. Credit the account",0dh,0ah,
"4. Debit the account",0dh,0ah,
"5. Exit",0ah,0ah,
"Choice> ",0
33
Defining Strings (3 of 3)
• End-of-line character sequence:
• 0Dh = carriage return
• 0Ah = line feed
str1 BYTE "Enter your name: ",0Dh,0Ah
 BYTE "Enter your address: ",0
newLine BYTE 0Dh,0Ah,0
Idea: Define all strings used by your program in the same 
area of the data segment.
34
Using the DUP Operator
• Use DUP to allocate (create space for) an array or 
string. Syntax: counter DUP ( argument )
• Counter and argument must be constants or constant 
expressions
var1 BYTE 20 DUP(0) ; 20 bytes, all equal to zero
var2 BYTE 20 DUP(?) ; 20 bytes, uninitialized
var3 BYTE 4 DUP("STACK") ; 20 bytes: "STACKSTACKSTACKSTACK"
var4 BYTE 10, 3 DUP(0), 20 ; 5 bytes
35
Defining WORD and SWORD Data
• Define storage for 16-bit integers
• or double characters
• single value or multiple values
word1 WORD 65535 ; largest unsigned value
word2 SWORD –32768 ; smallest signed value
word3 WORD ? ; uninitialized, unsigned
word4 WORD "AB" ; double characters
myList WORD 1,2,3,4,5 ; array of words
array WORD 5 DUP(?) ; uninitialized array
36
Defining DWORD and SDWORD Data
val1 DWORD 12345678h ; unsigned
val2 SDWORD –2147483648 ; signed
val3 DWORD 20 DUP(?) ; unsigned array
val4 SDWORD –3,–2,–1,0,1 ; signed array
Storage definitions for signed and unsigned 32-bit 
integers:
Defining QWORD, TBYTE, Real Data
Storage definitions for quadwords, tenbyte values, 
and real numbers:
quad1 QWORD 1234567812345678h
val1 TBYTE 1000000000123456789Ah
rVal1 REAL4 -2.1
rVal2 REAL8 3.2E-260
rVal3 REAL10 4.6E+4096
ShortArray REAL4 20 DUP(0.0)
37
38
Little Endian Order (小端)
• All data types larger than a byte store their individual 
bytes in reverse order. The least significant byte occurs 
at the first (lowest) memory address.
• Example:
val1 DWORD 12345678h
39
Big Endian Order
• All data types larger than a byte store their individual 
bytes in “usual” order. The most significant byte occurs 
at the first (lowest) memory address.
• Example:
val1 DWORD 12345678h
40
Adding Variables to AddSub
TITLE Add and Subtract, Version 2 (AddSub2.asm)
; This program adds and subtracts 32-bit unsigned
; integers and stores the sum in a variable.
INCLUDE Irvine32.inc
.data
val1 DWORD 10000h
val2 DWORD 40000h
val3 DWORD 20000h
finalVal DWORD ?
.code
main PROC
mov eax,val1 ; start with 10000h
add eax,val2 ; add 40000h
sub eax,val3 ; subtract 20000h
mov finalVal,eax ; store the result (30000h)
call DumpRegs ; display the registers
exit
main ENDP
END main
41
Declaring Unitialized Data
• Use the .data? directive to declare an uninitialized 
data segment:
.data?
• Within the segment, declare variables with "?" 
initializers:
smallArray DWORD 10 DUP(?)
Advantage: the program's EXE file size is reduced.
What's Next
• Basic Elements of Assembly Language
• Example: Adding and Subtracting Integers
• Assembling, Linking, and Running Programs
• Defining Data
• Symbolic Constants
• Real-Address Mode Programming
• 64-Bit Programming
42
Symbolic Constants
• Equal-Sign Directive
• Calculating the Sizes of Arrays and Strings
• EQU Directive
• TEXTEQU Directive
43
Equal-Sign Directive
• name = expression
• expression is a 32-bit integer (expression or constant)
• may be redefined
• name is called a symbolic constant
• good programming style to use symbols
COUNT = 500
.
.
mov al,COUNT
44
Calculating the Size of a Byte Array
• current location counter: $
• subtract address of list
• difference is the number of bytes
list BYTE 10,20,30,40
ListSize = ($ - list)
45
Calculating the Size of a Word Array
Divide total number of bytes by 2 (the size of a word)
list WORD 1000h,2000h,3000h,4000h
ListSize = ($ - list) / 2
46
Calculating the Size of a Doubleword Array
Divide total number of bytes by 4 (the size of a 
doubleword)
list DWORD 1,2,3,4
ListSize = ($ - list) / 4
47
EQU Directive
• Define a symbol as either a number or text 
expression.
• Cannot be redefined
PI EQU <3.1416>
pressKey EQU <"Press any key to continue...",0>
.data
prompt BYTE pressKey
48
49
TEXTEQU Directive
• Define a symbol as either an integer or text expression.
• Called a text macro
• Can be redefined
continueMsg TEXTEQU <"Do you wish to continue (Y/N)?">
rowSize = 5
.data
prompt1 BYTE continueMsg
count TEXTEQU %(rowSize * 2) ; evaluates the expression
setupAL TEXTEQU <mov al,count>
.code
setupAL ; generates: "mov al,10"
What's Next
• Basic Elements of Assembly Language
• Example: Adding and Subtracting Integers
• Assembling, Linking, and Running Programs
• Defining Data
• Symbolic Constants
• 64-Bit Programming
50
64-Bit Programming
• MASM supports 64-bit programming, although the 
following directives are not permitted:
• INVOKE, ADDR, .model, .386, .stack
• (Other non-permitted directives will be introduced in 
later chapters)
51
64-Bit Version of AddTwoSum
1: ; AddTwoSum_64.asm - Chapter 3 example.
3: ExitProcess PROTO
5: .data
6: sum QWORD 0
8: .code
9: main PROC
10: mov rax,5
11: add rax,6
12: mov sum,rax
13:
14: mov ecx,0
15: call ExitProcess
16: main ENDP
17: END
52
Things to Notice About the Previous Slide
• The following lines are not needed:
.386
.model flat,stdcall
.stack 4096
• INVOKE is not supported. 
• CALL instruction cannot receive arguments
• Use 64-bit registers when possible
53
Summary (Chap 1)
• Assembly language helps you learn how software is 
constructed at the lowest levels
• Assembly language has a one-to-one relationship 
with machine language
• Each layer in a computer's architecture is an 
abstraction of a machine
• layers can be hardware or software
• Boolean expressions are essential to the design of 
computer hardware and software
54
Summary (Chap 2)
• Central Processing Unit (CPU)
• Arithmetic Logic Unit (ALU)
• Instruction execution cycle
• Multitasking
• Floating Point Unit (FPU)
• Complex Instruction Set
• Real mode and Protected mode
• Motherboard components
• Memory types
• Input/Output and access levels
55
Summary (Chap 3)
• Integer expression, character constant
• directive – interpreted by the assembler
• instruction – executes at runtime
• code, data, and stack segments
• source, listing, object, map, executable files
• Data definition directives:
• BYTE, SBYTE, WORD, SWORD, DWORD, SDWORD, 
QWORD, TBYTE, REAL4, REAL8, and REAL10
• DUP operator, location counter ($)
56
Summary
57
Homework
• Reading Chap 1 - 3
• Exercise
• Please familiarize yourself with some development 
tools designed for the assembler programming 
language
58
本次课程是
线下教学
请现场的同学们：
打开雨课堂，点击页面右下角喇叭
按钮调至静音状态
CHAPTER 4: DATA TRANSFERS, 
ADDRESSING, AND ARITHMETIC
2
Chapter Overview
• Data Transfer Instructions
• Addition and Subtraction
• Data-Related Operators and Directives
• Indirect Addressing
• JMP and LOOP Instructions
• 64-Bit Programming
3
Data Transfer Instructions
• Operand Types
• Instruction Operand Notation
• Direct Memory Operands
• MOV Instruction
• Zero & Sign Extension
• XCHG Instruction
• Direct-Offset Instructions
4
Operand Types
• Three basic types of operands:
• Immediate – a constant integer (8, 16, or 32 bits)
• value is encoded within the instruction
• Register – the name of a register
• register name is converted to a number and encoded 
within the instruction
• Memory – reference to a location in memory
• memory address is encoded within the instruction, or a 
register holds the address of a memory location
5
Instruction Operand Notation
6
7
Direct Memory Operands
• A direct memory operand is a named reference to 
storage in memory
• The named reference (label) is automatically 
dereferenced (解引用) by the assembler
.data
var1 BYTE 10h
.code
mov al,var1 ; AL = 10h
mov al,[var1] ; AL = 10h
alternate format
8
MOV Instruction
.data
count BYTE 100
wVal WORD 2
.code
mov bl,count
mov ax,wVal
mov count,al
mov al,wVal ; error
mov ax,count ; error
mov eax,count ; error
mov ax,bl ; error
• Move from source to destination. Syntax:
MOV destination,source
• No more than one memory operand permitted
• CS, IP, EIP, and RIP cannot be the destination
• No immediate to segment moves
9
Zero Extension
mov bl,10001111b
movzx ax,bl ; zero-extension
When you copy a smaller value into a larger destination, the 
MOVZX instruction fills (extends) the upper half of the destination 
with zeros.
1 0 0 0 1 1 1 1
1 0 0 0 1 1 1 1
Source
Destination 0 0 0 0 0 0 0 0
0
• The destination must be a register.
• The source cannot be immediate. 
10
Sign Extension
mov bl,10001111b
movsx ax,bl ; sign extension
The MOVSX instruction fills the upper half of the destination 
with a copy of the source operand's sign bit.
1 0 0 0 1 1 1 1
1 0 0 0 1 1 1 1
Source
Destination 1 1 1 1 1 1 1 1
• The destination must be a register.
• The source cannot be immediate. 
11
XCHG Instruction
.data
var1 WORD 1000h
var2 WORD 2000h
.code
xchg ax,bx ; exchange 16-bit regs
xchg ah,al ; exchange 8-bit regs
xchg var1,bx ; exchange mem, reg
xchg eax,ebx ; exchange 32-bit regs
xchg var1,var2 ; error: two memory operands
XCHG exchanges the values of two operands. At least one 
operand must be a register. No immediate operands are 
permitted.
12
Direct-Offset Operands (直接偏移操作数)
.data
arrayB BYTE 10h,20h,30h,40h
.code
mov al,arrayB+1 ; AL = 20h
mov al,[arrayB+1] ; alternative notation
A constant offset is added to a data label to produce an 
effective address (EA). The address is dereferenced to get the 
value inside its memory location.
Q: Why doesn't arrayB+1 produce 11h?
What's Next
• Data Transfer Instructions
• Addition and Subtraction
• Data-Related Operators and Directives
• Indirect Addressing
• JMP and LOOP Instructions
13
Addition and Subtraction
• INC and DEC Instructions
• ADD and SUB Instructions
• NEG Instruction
• Implementing Arithmetic Expressions
• Flags Affected by Arithmetic
• Zero
• Sign
• Carry
• Overflow
14
INC and DEC Instructions
• Add 1, subtract 1 from destination operand
• operand may be register or memory
• INC destination
• Logic: destination ← destination + 1
• DEC destination
• Logic: destination ← destination – 1
15
16
INC and DEC Examples
.data
myWord WORD 1000h
myDword DWORD 10000000h
.code
inc myWord ; 1001h
dec myWord ; 1000h
inc myDword ; 10000001h
mov ax,00FFh
inc ax ; AX = 0100h
mov ax,00FFh
inc al ; AX = 0000h
ADD and SUB Instructions
• ADD destination, source
• Logic: destination ← destination + source
• SUB destination, source
• Logic: destination ← destination – source
• Same operand rules as for the MOV 
instruction
17
18
ADD and SUB Examples
.data
var1 DWORD 10000h
var2 DWORD 20000h
.code ; ---EAX---
mov eax,var1 ; 00010000h
add eax,var2 ; 00030000h
add ax,0FFFFh ; 0003FFFFh
add eax,1 ; 00040000h
sub ax,1 ; 0004FFFFh
19
NEG (negate) Instruction
.data
valB BYTE -1
valW WORD +32767
.code
mov al,valB ; AL = -1
neg al ; AL = +1
neg valW ; valW = -32767
Reverses the sign of an operand. Operand can be a register or 
memory operand.
20
Implementing Arithmetic Expressions
Rval DWORD ?
Xval DWORD 26
Yval DWORD 30
Zval DWORD 40
.code
mov eax,Xval
neg eax ; EAX = -26
mov ebx,Yval
sub ebx,Zval ; EBX = -10
add eax,ebx
mov Rval,eax ; -36
HLL compilers translate mathematical expressions into 
assembly language. You can do it also. For example: 
Rval = -Xval + (Yval – Zval)
Flags Affected by Arithmetic
• The ALU has a number of status flags that reflect the 
outcome of arithmetic (and bitwise) operations
• based on the contents of the destination operand
• Essential flags:
• Zero flag – set when destination equals zero
• Sign flag – set when destination is negative
• Carry flag – set when unsigned value is out of range
• Overflow flag – set when signed value is out of range
• The MOV instruction never affects the flags.
21
22
Zero Flag (ZF)
mov cx,1
sub cx,1 ; CX = 0, ZF = 1
mov ax,0FFFFh
inc ax ; AX = 0, ZF = 1
inc ax ; AX = 1, ZF = 0
The Zero flag is set when the result of an operation produces 
zero in the destination operand. 
Remember...
• A flag is set when it equals 1. 
• A flag is clear when it equals 0.
23
Sign Flag (SF)
mov cx,0
sub cx,1 ; CX = -1, SF = 1
add cx,2 ; CX = 1, SF = 0
The Sign flag is set when the destination operand is negative. 
The flag is clear when the destination is positive. 
The sign flag is a copy of the destination's highest bit:
mov al,0
sub al,1 ; AL = 11111111b, SF = 1
add al,2 ; AL = 00000001b, SF = 0
Signed and Unsigned Integers
A Hardware Viewpoint
• All CPU instructions operate exactly the same on 
signed and unsigned integers
• The CPU cannot distinguish between signed and 
unsigned integers
• YOU, the programmer, are solely responsible for 
using the correct data type with each instruction
24
25
Carry Flag (CF)
The Carry flag is set when the result of an operation generates an 
unsigned value that is out of range (too big or too small for the 
destination operand).
mov al,0FFh
add al,1 ; CF = 1, AL = 00
; Try to go below zero:
mov al,0
sub al,1 ; CF = 1, AL = FF
26
Overflow Flag (OF)
The Overflow flag is set when the signed result of an operation is 
invalid or out of range.
; Example 1
mov al,+127
add al,1 ; OF = 1, AL = ??
; Example 2
mov al,7Fh ; OF = 1, AL = 80h
add al,1
The two examples are identical at the binary level because 7Fh 
equals +127. To determine the value of the destination operand, 
it is often easier to calculate in hexadecimal.
27
A Rule of Thumb
• When adding two integers, remember that the 
Overflow flag is only set when . . .
• Two positive operands are added and their sum is 
negative
• Two negative operands are added and their sum is 
positive
What will be the values of the Overflow flag?
mov al,80h
add al,92h ; OF =
mov al,-2
add al,+127 ; OF =
1
0
What's Next
• Data Transfer Instructions
• Addition and Subtraction
• Data-Related Operators and Directives
• Indirect Addressing
• JMP and LOOP Instructions
• 64-Bit Programming
28
Data-Related Operators and Directives
• OFFSET Operator
• PTR Operator
• TYPE Operator
• LENGTHOF Operator
• SIZEOF Operator
• LABEL Directive
29
OFFSET Operator
• OFFSET returns the distance in bytes, of a label from the 
beginning of its enclosing segment
• Protected mode: 32 bits
• Real mode: 16 bits
offset
data segment:
myByte
The Protected-mode programs we write only have a single 
segment (we use the flat memory model).
30
31
OFFSET Examples
.data
bVal BYTE ?
wVal WORD ?
dVal DWORD ?
dVal2 DWORD ?
.code
mov esi,OFFSET bVal ; ESI = 00404000
mov esi,OFFSET wVal ; ESI = 00404001
mov esi,OFFSET dVal ; ESI = 00404003
mov esi,OFFSET dVal2 ; ESI = 00404007
Let's assume that bVal is located at offset 00404000h:
32
PTR Operator
.data
myDouble DWORD 12345678h
.code
mov ax,myDouble ; error – why?
mov ax,WORD PTR myDouble ; loads 5678h
mov WORD PTR myDouble,4321h ; saves 4321h
Overrides the default type of a label (variable). Provides the 
flexibility to access part of a variable.
Recall that little endian order is used when storing data in 
memory (see Section 3.4.11 in the 7th Ed ).
33
Little Endian Order
• Little endian order refers to the way Intel stores 
integers in memory.
• Multi-byte integers are stored in reverse order, with 
the least significant byte stored at the lowest address
• For example, the doubleword 12345678h would be 
stored as:
12345678 0000 5678
1234
78
56
34
12
0001
0002
0003
offset doubleword word byte
myDouble
myDouble + 1
myDouble + 2
myDouble + 3
When integers are loaded from 
memory into registers, the bytes 
are automatically re-reversed into 
their correct positions.
34
PTR Operator Examples
.data
myDouble DWORD 12345678h
mov al,BYTE PTR myDouble ; AL = 78h
mov al,BYTE PTR [myDouble+1] ; AL = 56h
mov al,BYTE PTR [myDouble+2] ; AL = 34h
mov ax,WORD PTR myDouble ; AX = 5678h
mov ax,WORD PTR [myDouble+2] ; AX = 1234h
12345678 0000 5678
1234
78
56
34
12
0001
0002
0003
offset doubleword word byte
myDouble
myDouble + 1
myDouble + 2
myDouble + 3
35
PTR Operator (cont)
.data
myBytes BYTE 12h,34h,56h,78h
.code
mov ax,WORD PTR [myBytes] ; AX = 3412h
mov ax,WORD PTR [myBytes+2] ; AX = 7856h
mov eax,DWORD PTR myBytes ; EAX = 78563412h
PTR can also be used to combine elements of a smaller data 
type and move them into a larger operand. The CPU will 
automatically reverse the bytes.
36
TYPE Operator
The TYPE operator returns the size, in bytes, of a single 
element of a data declaration.
.data
var1 BYTE ?
var2 WORD ?
var3 DWORD ?
var4 QWORD ?
.code
mov eax,TYPE var1 ; 1
mov eax,TYPE var2 ; 2
mov eax,TYPE var3 ; 4
mov eax,TYPE var4 ; 8
37
LENGTHOF Operator
.data LENGTHOF
byte1 BYTE 10,20,30 ; 3
array1 WORD 30 DUP(?),0,0 ; 32
array2 WORD 5 DUP(3 DUP(?)) ; 15
array3 DWORD 1,2,3,4 ; 4
digitStr BYTE "12345678",0 ; 9
.code
mov ecx,LENGTHOF array1 ; 32
The LENGTHOF operator counts the number of 
elements in a single data declaration.
38
SIZEOF Operator
.data SIZEOF
byte1 BYTE 10,20,30 ; 3
array1 WORD 30 DUP(?),0,0 ; 64
array2 WORD 5 DUP(3 DUP(?)) ; 30
array3 DWORD 1,2,3,4 ; 16
digitStr BYTE "12345678",0 ; 9
.code
mov ecx,SIZEOF array1 ; 64
The SIZEOF operator returns a value that is equivalent to 
multiplying LENGTHOF by TYPE.
39
Spanning Multiple Lines (1 of 2)
.data
array WORD 10,20,
30,40,
50,60
.code
mov eax,LENGTHOF array ; 6
mov ebx,SIZEOF array ; 12
A data declaration spans multiple lines if each line (except the 
last) ends with a comma. The LENGTHOF and SIZEOF 
operators include all lines belonging to the declaration:
40
Spanning Multiple Lines (2 of 2)
.data
array WORD 10,20
WORD 30,40
WORD 50,60
.code
mov eax,LENGTHOF array ; 2
mov ebx,SIZEOF array ; 4
In the following example, array identifies only the first WORD 
declaration. Compare the values returned by LENGTHOF 
and SIZEOF here to those in the previous slide:
41
LABEL Directive
• Assigns an alternate label name and type to an 
existing storage location
• LABEL does not allocate any storage of its own
• Removes the need for the PTR operator
.data
dwList LABEL DWORD
wordList LABEL WORD
intList BYTE 00h,10h,00h,20h
.code
mov eax,dwList ; 20001000h
mov cx,wordList ; 1000h
mov dl,intList ; 00h
What's Next
• Data Transfer Instructions
• Addition and Subtraction
• Data-Related Operators and Directives
• Indirect Addressing
• JMP and LOOP Instructions
• 64-Bit Programming
42
Indirect Addressing (间接寻址)
• Indirect Operands
• Array Sum Example
• Indexed Operands
• Pointers
43
44
Indirect Operands (1 of 2)
.data
val1 BYTE 10h,20h,30h
.code
mov esi,OFFSET val1
mov al,[esi] ; dereference ESI (AL = 10h)
inc esi
mov al,[esi] ; AL = 20h
inc esi
mov al,[esi] ; AL = 30h
An indirect operand holds the address of a variable, usually an 
array or string. It can be dereferenced (just like a pointer).
45
Indirect Operands (2 of 2)
.data
myCount WORD 0
.code
mov esi,OFFSET myCount
inc [esi] ; error: ambiguous
inc WORD PTR [esi] ; ok
Use PTR to clarify the size attribute of a memory operand.
46
Array Sum Example
.data
arrayW WORD 1000h,2000h,3000h
.code
mov esi,OFFSET arrayW
mov ax,[esi]
add esi,2 ; or: add esi,TYPE arrayW
add ax,[esi]
add esi,2
add ax,[esi] ; AX = sum of the array
Indirect operands are ideal for traversing an array. Note that the 
register in brackets must be incremented by a value that 
matches the array type.
ToDo: Modify this example for an array of doublewords.
47
Indexed Operands (变址操作数)
.data
arrayW WORD 1000h,2000h,3000h
.code
mov esi,0
mov ax,[arrayW + esi] ; AX = 1000h
mov ax,arrayW[esi] ; alternate format
add esi,2
add ax,[arrayW + esi]
etc.
An indexed operand adds a constant to a register to generate 
an effective address. There are different notational forms:
[label + reg] label[reg]
ToDo: Modify this example for an array of doublewords.
48
Adding Displacements
.data
arrayW WORD 1000h,2000h,3000h
.code
mov esi,OFFSET arrayW
mov ax,[esi] ; AX = 1000h
add ax,[esi+2] ; AX = 3000h
add ax,[esi+4] ; AX = 6000h
etc.
The indexed addressing combines a register with a constant offset. 
The index register holds the base address of an array or structure.
The constant identifies offsets of various array elements.
ToDo: Modify this example for an array of doublewords.
Index Scaling (索引比例)
You can scale an indirect or indexed operand to the offset of an 
array element. This is done by multiplying the index by the 
array's TYPE: 
.data
arrayB BYTE 0,1,2,3,4,5
arrayW WORD 0,1,2,3,4,5
arrayD DWORD 0,1,2,3,4,5
.code
mov esi,4
mov al,arrayB[esi * TYPE arrayB] ; 04
mov bx,arrayW[esi * TYPE arrayW] ; 0004
mov edx,arrayD[esi * TYPE arrayD] ; 00000004
49
50
Pointers
.data
arrayW WORD 1000h,2000h,3000h
ptrW DWORD arrayW
.code
mov esi,ptrW
mov ax,[esi] ; AX = 1000h
You can declare a pointer variable that contains the offset of 
another variable.
Alternate format:
ptrW DWORD OFFSET arrayW
What's Next
• Data Transfer Instructions
• Addition and Subtraction
• Data-Related Operators and Directives
• Indirect Addressing
• JMP and LOOP Instructions
• 64-Bit Programming
51
JMP and LOOP Instructions
• JMP Instruction
• LOOP Instruction
• LOOP Example
• Summing an Integer Array
• Copying a String
52
53
JMP Instruction
top:
.
.
jmp top
• JMP is an unconditional jump to a label that is usually within 
the same procedure.
• Syntax: JMP target
• Logic: EIP ← target
• Example:
A jump outside the current procedure must be to a special type of 
label called a global label (see the textbook for details, ::).
LOOP Instruction
• The LOOP instruction creates a counting loop
• Syntax: LOOP target
• Logic:
• ECX ← ECX – 1
• if ECX != 0, jump to target
• Implementation: 
• The assembler calculates the distance, in bytes, between 
the offset of the following instruction and the offset of the 
target label. It is called the relative offset.
• The relative offset is added to EIP.
54
55
LOOP Example
00000000 66 B8 00 00 mov ax,0 
00000004 B9 05 00 00 00 mov ecx,5
00000009 66 03 C1 L1: add ax,cx
0000000C E2 FB loop L1
0000000E
The following loop calculates the sum of the integers 
5 + 4 + 3 +2 + 1:
When LOOP is assembled, the current location = 0000000E (offset of 
the next instruction). -5 (FBh) is added to the the current location, 
causing a jump to location 00000009:
00000009 ← 0000000E + FB
offset machine code source code
56
Nested Loop
If you need to code a loop within a loop, you must save the 
outer loop counter's ECX value. In the following example, the 
outer loop executes 100 times, and the inner loop 20 times.
.data
count DWORD ?
.code
mov ecx,100 ; set outer loop count
L1:
mov count,ecx ; save outer loop count
mov ecx,20 ; set inner loop count
L2: .
.
loop L2 ; repeat the inner loop
mov ecx,count ; restore outer loop count
loop L1 ; repeat the outer loop
What's Next
• Data Transfer Instructions
• Addition and Subtraction
• Data-Related Operators and Directives
• Indirect Addressing
• JMP and LOOP Instructions
• 64-Bit Programming
57
64-Bit Programming
• MOV instruction in 64-bit mode accepts operands of 
8, 16, 32, or 64 bits
• When you move a 8, 16, or 32-bit constant to a 64-bit 
register, the upper bits of the destination are cleared.
• When you move a memory operand into a 64-bit 
register, the results vary:
• 32-bit move clears high bits in destination
• 8-bit or 16-bit move does not affect high bits in 
destination
58
More 64-Bit Programming
• MOVSXD sign extends a 32-bit value into a 64-bit 
destination register
• The OFFSET operator generates a 64-bit address
• LOOP uses the 64-bit RCX register as a counter
• RSI and RDI are the most common 64-bit index 
registers for accessing arrays.
59
Other 64-Bit Notes
• ADD and SUB affect the flags in the same way as in 
32-bit mode
• You can use scale factors with indexed operands.
60
CHAPTER 5: PROCEDURES
1
Chapter Overview
• Stack Operations
• Defining and Using Procedures
• Linking to an External Library
• The Irvine32 Library
• Program Design Using Procedures
• 64-Bit Assembly Programming
2
Stack Operations
• Runtime Stack
• PUSH Operation
• POP Operation
• PUSH and POP Instructions
• Using PUSH and POP
• Related Instructions
3
4
Runtime Stack
• Imagine a stack of plates . . .
• plates are only added to the top
• plates are only removed from the top
• LIFO structure
1
2
3
4
5
6
7
8
9
10 top
bottom
5
Runtime Stack
• Managed by the CPU, using two registers
• SS (stack segment)
• ESP (stack pointer) *
* SP in Real-address mode 00000006 ESP 00001000
Offset
00000FF8
00000FF4
00000FF0
00000FFC
6
PUSH Operation (1 of 2)
• A 32-bit push operation decrements the stack pointer 
by 4 and copies a value into the location pointed to 
by the stack pointer.
00000006 00000006
ESP
00001000
00000FFC
00000FF8
00000FF4
00000FF0
000000A5
ESP 00001000
BEFORE
00000FFC
00000FF8
00000FF4
00000FF0
AFTER
7
PUSH Operation (2 of 2)
• Same stack after pushing two more integers:
00000006
ESP
00001000
Offset
00000FFC
00000FF8
00000FF4
00000FF0
000000A5
00000001
00000002
The stack grows downward. The area below ESP is always 
available (unless the stack has overflowed).
8
POP Operation
• Copies value at stack[ESP] into a register or variable.
• Adds n to ESP, where n is either 2 or 4.
• value of n depends on the attribute of the operand receiving the 
data
BEFORE AFTER
00000006
000000A5
00000001
00000002 ESP
00000006
000000A5
00000001 ESP
00001000
00000FFC
00000FF8
00000FF4
00000FF0
00001000
00000FFC
00000FF8
00000FF4
00000FF0
9
PUSH and POP Instructions
• PUSH syntax:
• PUSH r/m16
• PUSH r/m32
• PUSH imm32
• POP syntax:
• POP r/m16
• POP r/m32
10
Using PUSH and POP
push esi ; push registers
push ecx
push ebx
mov esi, OFFSET dwordVal ; display some memory
mov ecx, LENGTHOF dwordVal
mov ebx, TYPE dwordVal
call DumpMem
pop ebx ; restore registers
pop ecx
pop esi
Save and restore registers when they contain important values. 
PUSH and POP instructions occur in the opposite order.
Related Instructions
• PUSHFD and POPFD
• push and pop the EFLAGS register
• PUSHAD pushes the 32-bit general-purpose 
registers on the stack 
• order: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI
• POPAD pops the same registers off the stack in 
reverse order
• PUSHA and POPA do the same for 16-bit registers
11
What's Next
• Stack Operations
• Defining and Using Procedures
• Linking to an External Library
• The Irvine32 Library
• Program Design Using Procedures
• 64-Bit Assembly Programming
12
Defining and Using Procedures
• Creating Procedures
• Documenting Procedures
• Example: SumOf Procedure
• CALL and RET Instructions
• Nested Procedure Calls
• Local and Global Labels
• Procedure Parameters
• USES Operator
13
Creating Procedures
• Large problems can be divided into smaller tasks to 
make them more manageable
• A procedure is the ASM equivalent of a Java or C++ 
function
• Following is an assembly language procedure named 
sample:
sample PROC
.
.
ret
sample ENDP
14
Documenting Procedures
Suggested documentation for each procedure:
• A description of all tasks accomplished by the procedure.
• Receives: A list of input parameters; state their usage and 
requirements.
• Returns: A description of values returned by the procedure.
• Requires: Optional list of requirements called preconditions that 
must be satisfied before the procedure is called.
If a procedure is called without its preconditions satisfied, it will 
probably not produce the expected output.
15
16
Example: SumOf Procedure
;---------------------------------------------------------
SumOf PROC
;
; Calculates and returns the sum of three 32-bit integers.
; Receives: EAX, EBX, ECX, the three integers. May be
; signed or unsigned.
; Returns: EAX = sum, and the status flags (Carry,
; Overflow, etc.) are changed.
; Requires: nothing
;---------------------------------------------------------
add eax,ebx
add eax,ecx
ret
SumOf ENDP
To call SumOf, prepare arguments: EAX, EBX, ECX
mov eax,10
mov ebx,20
mov ecx,30
call SumOf
WriteDec
CALL and RET Instructions
• The CALL instruction calls a procedure 
• pushes offset of next instruction on the stack
• copies the address of the called procedure into EIP
• The RET instruction returns from a procedure
• pops top of stack into EIP
17
18
CALL-RET Example (1 of 2)
main PROC
00000020 call MySub
00000025 mov eax,ebx
.
.
main ENDP
MySub PROC
00000040 mov eax,edx
.
.
ret
MySub ENDP
0000025 is the offset of the 
instruction immediately 
following the CALL 
instruction
00000040 is the offset of 
the first instruction inside 
MySub
19
CALL-RET Example (2 of 2)
The CALL instruction 
pushes 00000025 onto 
the stack, and loads 
00000040 into EIP
00000025 ESP
EIP
00000025
The RET instruction 
pops 00000025 from the 
stack into EIP
(stack shown before RET executes)
00000025 ESP
EIP
00000040
20
Procedure Parameters (1 of 3)
• A good procedure might be usable in many 
different programs
• but not if it refers to specific variable names
• Parameters help to make procedures flexible 
because parameter values can change at runtime
21
Procedure Parameters (2 of 3)
ArraySum PROC
mov esi,0 ; array index
mov eax,0 ; set the sum to zero
mov ecx,LENGTHOF myarray ; set number of elements
L1: add eax,myArray[esi] ; add each integer to sum
add esi,4 ; point to next integer
loop L1 ; repeat for array size
mov theSum,eax ; store the sum
ret
ArraySum ENDP
The ArraySum procedure calculates the sum of an array. It 
makes two references to specific variable names:
What if you wanted to calculate the sum of two or three arrays 
within the same program?
22
Procedure Parameters (3 of 3)
ArraySum PROC
; Receives: ESI points to an array of doublewords, 
; ECX = number of array elements.
; Returns: EAX = sum
;-----------------------------------------------------
mov eax,0 ; set the sum to zero
L1: add eax,[esi] ; add each integer to sum
add esi,4 ; point to next integer
loop L1 ; repeat for array size
ret
ArraySum ENDP
This version of ArraySum returns the sum of any doubleword 
array whose address is in ESI. The sum is returned in EAX:
23
USES Operator
• Lists the registers that will be preserved 
ArraySum PROC USES esi ecx
mov eax,0 ; set the sum to zero
etc.
MASM generates the code shown in gold:
ArraySum PROC
push esi
push ecx
.
.
pop ecx
pop esi
ret
ArraySum ENDP
24
When not to push a register
SumOf PROC ; sum of three integers
push eax ; 1
add eax,ebx ; 2
add eax,ecx ; 3
pop eax ; 4
ret
SumOf ENDP
The sum of the three registers is stored in EAX on line (3), but 
the POP instruction replaces it with the starting value of EAX on 
line (4):
What's Next
• Stack Operations
• Defining and Using Procedures
• Linking to an External Library
• The Irvine32 Library
• Program Design Using Procedures
• 64-Bit Assembly Programming
25
What is a Link Library?
• A file containing procedures that have been compiled 
into machine code
• constructed from one or more OBJ files
• To build a library, . . .
• start with one or more ASM source files
• assemble each into an OBJ file
• create an empty library file (extension .LIB)
• add the OBJ file(s) to the library file, using the 
Microsoft LIB utility
Take a quick look at Irvine32.asm
26
27
• Your programs link to Irvine32.lib using the linker command 
inside a batch file named make32.bat.
• Notice the two LIB files: Irvine32.lib, and kernel32.lib
• the latter is part of the Microsoft Win32 Software 
Development Kit (SDK)
Your program
kernel32.lib
kernel32.dll
Irvine32.lib links
executes
to
links to
can link to
How The Linker Works
28
Calling Irvine32 Library Procedure
INCLUDE Irvine32.inc
.code
mov eax,1234h ; input argument
call WriteHex ; show hex number
call Crlf ; end of line
• Call each procedure using the CALL instruction. 
• Some procedures require input arguments. 
• The INCLUDE directive copies in the procedure 
prototypes (declarations).
• The following example displays "1234" on the console:
What's Next
• Stack Operations
• Defining and Using Procedures
• Linking to an External Library
• The Irvine32 Library
• Program Design Using Procedures
• 64-Bit Assembly Programming
29
Program Design Using Procedures
• Top-Down Design (functional decomposition) 
involves the following:
• design your program before starting to code
• break large tasks into smaller ones
• use a hierarchical structure based on procedure calls
• test individual procedures separately
30
What's Next
• Stack Operations
• Defining and Using Procedures
• Linking to an External Library
• The Irvine32 Library
• Program Design Using Procedures
• 64-Bit Assembly Programming
31
64-Bit Assembly Programming
• The Irvine64 Library
• Calling 64-Bit Subroutines
• The x64 Calling Convention
32
Calling 64-Bit Subroutines
• Place the first four parameters in registers
• Add PROTO directives at the top of your program
• examples:
ExitProcess PROTO ; located in the Windows API
WriteHex64 PROTO ; located in the Irvine64 library
33
The x64 Calling Convention
• Must use this with the 64-bit Windows API
• CALL instruction subtracts 8 from RSP
• First four parameters must be placed in RCX, RDX, 
R8, and R9
• Caller must allocate at least 32 bytes of shadow 
space on the stack
• When calling a subroutine, the stack pointer must be 
aligned on a 16-byte boundary.
See the CallProc_64.asm example program.
34
CHAPTER 6: CONDITIONAL 
PROCESSING
1
Chapter Overview
• Boolean and Comparison Instructions
• Conditional Jumps
• Conditional Loop Instructions
• Conditional Structures
• Application: Finite-State Machines
• Conditional Control Flow Directives
2
Boolean and Comparison Instructions
• CPU Status Flags
• AND Instruction
• OR Instruction
• XOR Instruction
• NOT Instruction
• Applications
• TEST Instruction 
• CMP Instruction
3
Status Flags - Review
• The Zero flag is set when the result of an operation equals zero.
• The Carry flag is set when an instruction generates a result that is 
too large (or too small) for the destination operand.
• The Sign flag is set if the destination operand is negative, and it is 
clear if the destination operand is positive.
• The Overflow flag is set when an instruction generates an invalid 
signed result.
• The Parity flag is set when an instruction generates an even 
number of 1 bits in the low byte of the destination operand.
• The Auxiliary Carry flag is set when an operation produces a carry 
out from bit 3 to bit 4
4
5
AND Instruction
• Performs a Boolean AND operation between each 
pair of matching bits in two operands
• Syntax:
AND destination, source
(same operand types as MOV)
0 0 1 1 1 0 1 1
0 0 0 0 1 1 1 1
0 0 0 0 1 0 1 1
AND
unchanged cleared
AND
6
OR Instruction
• Performs a Boolean OR operation between each pair 
of matching bits in two operands
• Syntax:
OR destination, source
OR
0 0 1 1 1 0 1 1
0 0 0 0 1 1 1 1
0 0 1 1 1 1 1 1
OR
set unchanged
7
NOT Instruction
• Performs a Boolean NOT operation on a single 
destination operand
• Syntax:
NOT destination NOT
0 0 1 1 1 0 1 1
1 1 0 0 0 1 0 0
NOT
inverted
8
XOR Instruction
• Performs a Boolean exclusive-OR operation between 
each pair of matching bits in two operands
• Syntax:
XOR destination, source XOR
0 0 1 1 1 0 1 1
0 0 0 0 1 1 1 1
0 0 1 1 0 1 0 0
XOR
inverted unchanged
XOR is a useful way to toggle (invert) the bits in an operand.
Bit-Mapped Sets
• Binary bits indicate set membership
• Efficient use of storage
• Also known as bit vectors
9
Bit-Mapped Set Operations
• Set Intersection
• mov eax,setX
• and eax,setY
• Set Union
• mov eax,setX
• or eax,setY
• Set Complement
• mov eax,setX
• not eax
10
TEST Instruction
• Performs a nondestructive (非破坏性的) AND operation between 
each pair of matching bits in two operands
• No operands are modified, but the Zero flag is affected.
• Example: jump to a label if neither bit 0 nor bit 1 in AL is set.
test al,00000011b
jz ValueNotFound
• Example: jump to a label if either bit 0 or bit 1 in AL is set.
test al,00000011b
jnz ValueFound
11
12
CMP Instruction
• Compares the destination operand to the source operand
• Nondestructive subtraction of source from destination (destination 
operand is not changed)
• Syntax: CMP destination, source
• Example: destination == source
mov al,5
cmp al,5 ; Zero flag set
• Example: destination < source
mov al,4
cmp al,5 ; Carry flag set
What's Next
• Boolean and Comparison Instructions
• Conditional Jumps
• Conditional Loop Instructions
• Conditional Structures
• Application: Finite-State Machines
• Conditional Control Flow Directives
13
Conditional Jumps
• Jumps Based On . . .
• Specific flags
• Equality
• Unsigned comparisons
• Signed Comparisons
• Applications
• Encrypting a String
• Bit Test (BT) Instruction
14
Jcond Instruction
• A conditional jump instruction branches to a label 
when specific register or flag conditions are met
• Examples:
• JC, JB jump to a label if the Carry flag is set
• JZ, JE jump to a label if the Zero flag is set
• JS jumps to a label if the Sign flag is set
• JNZ, JNE jump to a label if the Zero flag is clear
• JECXZ jumps to a label if ECX equals 0
15
16
Jcond Ranges
• Prior to the 386:
• jump must be within –128 to +127 bytes from current 
location counter
• x86 processors:
• 32-bit offset permits jump anywhere in memory
Offset Encoding ASM Source
0040101A B0 80 mov al,80h L1: mov al, -128
0040101C 3C 0A cmp al,0Ah cmp al, 10
0040101E 74 FA je L1 (40101Ah) jz L1
00401020 8A D8 mov bl,al mov bl, al
FA: -6 00401020
 + FFFFFFFA
 ------------
0040101A
Jumps Based on Specific Flags
17
Jumps Based on Equality
18
Jumps Based on Unsigned Comparisons
19
Jumps Based on Signed Comparisons
20
Applications
• Task: Jump to label Larger if unsigned EAX is greater than EBX
• Solution: Use CMP, followed by JA
cmp eax,ebx
ja Larger
• Task: Jump to label Greater if signed EAX is greater than EBX
• Solution: Use CMP, followed by JG
cmp eax,ebx
jg Greater
21
22
BT (Bit Test) Instruction
• Copies bit n from an operand into the Carry flag
• Syntax: BT bitBase, n
• bitBase may be r/m16 or r/m32
• n may be r16, r32, or imm8
• Example: jump to label L1 if bit 9 is set in the AX 
register:
bt AX,9 ; CF = bit 9
jc L1 ; jump if Carry
What's Next
• Boolean and Comparison Instructions
• Conditional Jumps
• Conditional Loop Instructions
• Conditional Structures
• Application: Finite-State Machines
• Conditional Control Flow Directives
23
Conditional Loop Instructions
• LOOPZ and LOOPE
• LOOPNZ and LOOPNE
24
25
LOOPNE and LOOPNZ
• LOOPNE (LOOPNZ) is a 
conditional loop instruction
• Syntax: 
LOOPNE destination
LOOPNZ destination
• Logic: 
• ECX ← ECX – 1; 
• if ECX > 0 and ZF=0, jump to destination
• Useful when scanning an array for the first element 
that matches a given value.
In 32-bit mode, ECX is the loop counter register. In 16-bit real￾address mode, CX is the counter, and in 64-bit mode, RCX is the 
counter.
26
LOOPZ and LOOPE
• Syntax: 
LOOPE destination
LOOPZ destination
• Logic: 
• ECX ← ECX – 1
• if ECX > 0 and ZF=1, jump to destination
• Useful when scanning an array for the first element 
that does not match a given value.
In 32-bit mode, ECX is the loop counter register. In 16-bit real￾address mode, CX is the counter, and in 64-bit mode, RCX is the 
counter.
27
LOOPNZ Example
.data
array SWORD -3,-6,-1,-10,10,30,40,4
sentinel SWORD 0
.code
mov esi,OFFSET array
mov ecx,LENGTHOF array
next:
test WORD PTR [esi],8000h ; test sign bit
pushfd ; push flags on stack
add esi,TYPE array
popfd ; pop flags from stack
loopnz next ; continue loop
jnz quit ; none found
sub esi,TYPE array ; ESI points to value
quit:
The following code finds the first positive value in an array:
What's Next
• Boolean and Comparison Instructions
• Conditional Jumps
• Conditional Loop Instructions
• Conditional Structures
• Application: Finite-State Machines
• Conditional Control Flow Directives
28
Conditional Structures
• Block-Structured IF Statements
• Compound Expressions with AND
• Compound Expressions with OR
• WHILE Loops
29
30
Block-Structured IF Statements
Assembly language programmers can easily translate logical 
statements written in C++/Java into assembly language. For 
example:
mov eax,op1
cmp eax,op2
jne L1
mov X,1
jmp L2
L1: mov X,2
L2:
if( op1 == op2 )
 X = 1;
else
 X = 2;
31
Compound Expression with AND (1 of 3)
• When implementing the logical AND operator, consider that HLLs 
use short-circuit evaluation
• In the following example, if the first expression is false, the second 
expression is skipped:
if (al > bl) AND (bl > cl)
 X = 1;
32
Compound Expression with AND (2 of 3)
cmp al,bl ; first expression...
ja L1
jmp next
L1:
cmp bl,cl ; second expression...
ja L2
jmp next
L2: ; both are true
mov X,1 ; set X to 1
next:
if (al > bl) AND (bl > cl)
 X = 1;
This is one possible implementation . . .
33
Compound Expression with AND (3 of 3)
cmp al,bl ; first expression...
jbe next ; quit if false
cmp bl,cl ; second expression...
jbe next ; quit if false
mov X,1 ; both are true
next:
if (al > bl) AND (bl > cl)
 X = 1;
But the following implementation uses 29% less code by 
reversing the first relational operator. We allow the program to 
"fall through" to the second expression:
What's Next
• Boolean and Comparison Instructions
• Conditional Jumps
• Conditional Loop Instructions
• Conditional Structures
• Application: Finite-State Machines
• Reading material
• Conditional Control Flow Directives
34
What's Next
• Boolean and Comparison Instructions
• Conditional Jumps
• Conditional Loop Instructions
• Conditional Structures
• Application: Finite-State Machines
• Conditional Control Flow Directives
35
Creating IF Statements
• Runtime Expressions
• Relational and Logical Operators
• MASM-Generated Code
• .REPEAT Directive
• .WHILE Directive
36
37
Runtime Expressions
.IF eax > ebx
mov edx,1
.ELSE
mov edx,2
.ENDIF
• .IF, .ELSE, .ELSEIF, and .ENDIF can be used to evaluate 
runtime expressions and create block-structured IF 
statements.
• Examples:
• MASM generates "hidden" code for you, consisting of 
code labels, CMP and conditional jump instructions.
.IF eax > ebx && eax > ecx
mov edx,1
.ELSE
mov edx,2
.ENDIF
Relational and Logical Operators
38
39
MASM-Generated Code
mov eax,6
cmp eax,val1
jbe @C0001 
mov result,1
@C0001:
.data
val1 DWORD 5
result DWORD ?
.code
mov eax,6
.IF eax > val1
 mov result,1
.ENDIF
Generated code:
MASM automatically generates an unsigned jump (JBE) 
because val1 is unsigned.
.IF 2 > eaxX
40
MASM-Generated Code
mov eax,6
cmp eax,val1
jle @C0001 
mov result,1
@C0001:
.data
val1 SDWORD 5
result SDWORD ?
.code
mov eax,6
.IF eax > val1
 mov result,1
.ENDIF
Generated code:
MASM automatically generates a signed jump (JLE) because 
val1 is signed.
41
MASM-Generated Code
mov ebx,5
mov eax,6
cmp eax,ebx
jbe @C0001 
mov result,1
@C0001:
.data
result DWORD ?
.code
mov ebx,5
mov eax,6
.IF eax > ebx
 mov result,1
.ENDIF
Generated code:
MASM automatically generates an unsigned jump (JBE) when 
both operands are registers . . .
42
MASM-Generated Code
mov ebx,5
mov eax,6
cmp eax,ebx
jle @C0001 
mov result,1
@C0001:
.data
result SDWORD ?
.code
mov ebx,5
mov eax,6
.IF SDWORD PTR eax > ebx
 mov result,1
.ENDIF
Generated code:
. . . unless you prefix one of the register operands with the 
SDWORD PTR operator. Then a signed jump is generated.
43
.REPEAT Directive
; Display integers 1 – 10:
mov eax,0
.REPEAT
inc eax
call WriteDec
call Crlf
.UNTIL eax == 10
Executes the loop body before testing the loop condition 
associated with the .UNTIL directive. 
Example:
44
.WHILE Directive
; Display integers 1 – 10:
mov eax,0
.WHILE eax < 10
inc eax
call WriteDec
call Crlf
.ENDW
Tests the loop condition before executing the loop body 
The .ENDW directive marks the end of the loop. 
Example:
Summary (Chap 4)
• Data Transfer
• MOV – data transfer from source to destination
• MOVSX, MOVZX, XCHG
• Operand types
• direct, direct-offset, indirect, indexed
• Arithmetic
• INC, DEC, ADD, SUB, NEG
• Sign, Carry, Zero, Overflow flags
• Operators
• OFFSET, PTR, TYPE, LENGTHOF, SIZEOF, TYPEDEF
• JMP and LOOP – branching instructions
45
Summary (Chap 5)
• Procedure – named block of executable code
• Runtime stack – LIFO structure
• holds return addresses, parameters, local variables
• PUSH – add value to stack
• POP – remove value from stack
• Use the Irvine32 library for all standard I/O and data 
conversion
• Want to learn more? Study the library source code
46
Summary (Chap 6)
• Bitwise instructions (AND, OR, XOR, NOT, TEST) 
• manipulate individual bits in operands
• CMP – compares operands using implied subtraction
• sets condition flags
• Conditional Jumps & Loops
• equality: JE, JNE
• flag values: JC, JZ, JNC, JP, ...
• signed: JG, JL, JNG, ...
• unsigned: JA, JB, JNA, ...
• LOOPZ, LOOPNZ, LOOPE, LOOPNE
47
Summary
48
Summary
49
Homework
• Reading Chap 4 - 6
• Homework
• Coding Exercises
50
本次课程是
线下教学
请现场的同学们：
打开雨课堂，点击页面右下角喇叭
按钮调至静音状态
CHAPTER 7: 
 INTEGER ARITHMETIC
2
Chapter Overview
• Shift and Rotate Instructions
• Shift and Rotate Applications
• Multiplication and Division Instructions
• Extended Addition and Subtraction
• ASCII and Unpacked Decimal Arithmetic
• Packed Decimal Arithmetic
3
7.1 Shift and Rotate Instructions
• Logical vs Arithmetic Shifts
• SHL Instruction 
• SHR Instruction 
• SAL and SAR Instructions 
• ROL Instruction 
• ROR Instruction 
• RCL and RCR Instructions 
• SHLD/SHRD Instructions
4
Logical Shift
• A logical shift fills the newly created bit position with 
zero:
0
CF
5
Arithmetic Shift
• An arithmetic shift fills the newly created bit position 
with a copy of the number’s sign bit:
CF
6
7
SHL Instruction
• The SHL (shift left) instruction performs a logical left 
shift on the destination operand, filling the lowest bit 
with 0.
• Operand types for SHL:
SHL reg,imm8
SHL mem,imm8
SHL reg,CL
SHL mem,CL
(Same for all shift and 
rotate instructions)
8
Fast Multiplication
mov dl,5
shl dl,1
Shifting left 1 bit multiplies a number by 2
mov dl,5
shl dl,2 ; DL = 20
Shifting left n bits multiplies the operand by 2n
For example, 5 * 22 = 20
0 0 0 0 1 0 1 0
0 0 0 0 0 1 0 1 = 5
= 10
Before:
After:
9
SHR Instruction
• The SHR (shift right) instruction performs a logical 
right shift on the destination operand. The highest bit 
position is filled with a zero.
CF
0
mov dl,80
shr dl,1 ; DL = 40
shr dl,2 ; DL = 10
Shifting right n bits divides the operand by 2n
10
SAL and SAR Instructions
• SAL (shift arithmetic left) is identical to SHL.
• SAR (shift arithmetic right) performs a right arithmetic 
shift on the destination operand.
CF
An arithmetic shift preserves the number's sign.
mov dl,-80
sar dl,1 ; DL = -40
sar dl,2 ; DL = -10
11
ROL Instruction
• ROL (rotate) shifts each bit to the left
• The highest bit is copied into both the Carry flag 
and into the lowest bit
• No bits are lost
CF
mov al,11110000b
rol al,1 ; AL = 11100001b
mov dl,3Fh
rol dl,4 ; DL = F3h
12
ROR Instruction
• ROR (rotate right) shifts each bit to the right
• The lowest bit is copied into both the Carry flag and 
into the highest bit
• No bits are lost
CF
mov al,11110000b
ror al,1 ; AL = 01111000b
mov dl,3Fh
ror dl,4 ; DL = F3h
13
RCL Instruction
• RCL (rotate carry left) shifts each bit to the left
• Copies the most significant bit to the Carry flag
• Copies the Carry flag to the least significant bit
CF
clc ; CF = 0
mov bl,88h ; CF,BL = 0 10001000b
rcl bl,1 ; CF,BL = 1 00010000b
rcl bl,1 ; CF,BL = 0 00100001b
14
RCR Instruction
• RCR (rotate carry right) shifts each bit to the right
• Copies the least significant bit to the Carry flag
• Copies the Carry flag to the most significant bit
stc ; CF = 1
mov ah,10h ; CF,AH = 1 00010000b
rcr ah,1 ; CF,AH = 0 10001000b
CF
15
SHLD Instruction (Shift Left Double)
• Shifts a destination operand a given number of bits to 
the left 
• The bit positions opened up by the shift are filled by 
the most significant bits of the source operand
• The source operand is not affected
• Syntax:
SHLD destination, source, count
• Operand types:
SHLD reg16/32, reg16/32, imm8/CL
SHLD mem16/32, reg16/32, imm8/CL
16
SHLD Example
Shift count of 1:
mov al,11100000b
mov bl,10011101b
shld al,bl,1
17
Another SHLD Example
.data
wval WORD 9BA6h
.code
mov ax,0AC36h
shld wval,ax,4
Shift wval 4 bits to the left and replace its lowest 4 bits with 
the high 4 bits of AX:
Before:
After:
9BA6 AC36
BA6A AC36
wval AX
18
SHRD Instruction
• Shifts a destination operand a given number of bits to 
the right
• The bit positions opened up by the shift are filled by 
the least significant bits of the source operand
• The source operand is not affected
• Syntax:
SHRD destination, source, count
• Operand types:
SHRD reg16/32, reg16/32, imm8/CL
SHRD mem16/32, reg16/32, imm8/CL
19
SHRD Example
Shift count of 1:
mov al,11000001b
mov bl,00011101b
shrd al,bl,1
20
Another SHRD Example
mov ax,234Bh
mov dx,7654h
shrd ax,dx,4
Shift AX 4 bits to the right and replace its highest 4 bits with 
the low 4 bits of DX:
Before:
After:
7654 234B
7654 4234
DX AX
What's Next
• Shift and Rotate Instructions
• Shift and Rotate Applications
• Multiplication and Division Instructions
• Extended Addition and Subtraction
• ASCII and Unpacked Decimal Arithmetic
• Packed Decimal Arithmetic
21
7.2 Multiplication and Division Instructions
• MUL Instruction 
• IMUL Instruction 
• DIV Instruction 
• Signed Integer Division
• CBW, CWD, CDQ Instructions
• IDIV Instruction 
• Implementing Arithmetic Expressions 
22
MUL Instruction
• In 32-bit mode, MUL (unsigned multiply) instruction multiplies an 
8-, 16-, or 32-bit operand by either AL, AX, or EAX. 
• The instruction formats are:
MUL r/m8
MUL r/m16
MUL r/m32
Implied operands:
23
24
64-Bit MUL Instruction
• In 64-bit mode, MUL (unsigned multiply) instruction multiplies a 
64-bit operand by RAX, producing a 128-bit product.
• The instruction formats are:
MUL r/m64
Example:
mov rax,0FFFF0000FFFF0000h
mov rbx,2
mul rbx ; RDX:RAX = 0000000000000001FFFE0001FFFE0000
25
MUL Examples
100h * 2000h, using 16-bit operands:
.data
val1 WORD 2000h
val2 WORD 100h
.code
mov ax,val1
mul val2 ; DX:AX = 00200000h, CF=1
The Carry flag 
indicates whether or 
not the upper half of 
the product contains 
significant digits.
mov eax,12345h
mov ebx,1000h
mul ebx ; EDX:EAX = 0000000012345000h, CF=0
12345h * 1000h, using 32-bit operands:
MUL Examples
• After calling mult_by_MUL in the same manner, the 
resulting timings on a legacy 4-GHz Pentium 4 
showed 
• the SHL approach executed in 6.078 seconds
• the MUL approach executed in 20.718 seconds
• using MUL instruction was 241 percent slower. 
• When running the same program on a more recent 
processor
• the timings of both function calls were exactly the 
same. 
• This example shows that Intel has managed to 
greatly optimize the MUL and IMUL instructions in 
recent processors
26
27
IMUL Instruction
• IMUL (signed integer multiply ) multiplies an 8-, 16-, 
or 32-bit signed operand by either AL, AX, or EAX
• Preserves the sign of the product by sign-extending it 
into the upper half of the destination register
Example: multiply 48 * 4, using 8-bit operands:
mov al,48
mov bl,4
imul bl ; AX = 00C0h, OF=1
OF=1 because AH is not a sign extension of AL.
IMUL Instruction
• Two-Operand Formats (32-Bit Mode)
IMUL reg32,reg/mem32
IMUL reg32,imm8
IMUL reg32,imm32
• Three-Operand Formats (32-Bit Mode)
IMUL reg32,reg/mem32,imm8
IMUL reg32,reg/mem32,imm32
See 16-Bit Modes in Section 7.3.2. 
28
29
DIV Instruction
• The DIV (unsigned divide) instruction performs 8-bit, 
16-bit, and 32-bit division on unsigned integers
• A single operand is supplied (register or memory 
operand), which is assumed to be the divisor 
• Instruction formats:
DIV r/m8
DIV r/m16
DIV r/m32
Default Operands:
30
DIV Examples
Divide 8003h by 100h, using 16-bit operands:
mov dx,0 ; clear dividend, high
mov ax,8003h ; dividend, low
mov cx,100h ; divisor
div cx ; AX = 0080h, DX = 3
Same division, using 32-bit operands:
mov edx,0 ; clear dividend, high
mov eax,8003h ; dividend, low
mov ecx,100h ; divisor
div ecx ; EAX = 00000080h, EDX = 3
31
64-Bit DIV Example
Divide 000001080000000033300020h by 00010000h:
.data
dividend_hi QWORD 00000108h
dividend_lo QWORD 33300020h
divisor QWORD 00010000h
.code
mov rdx, dividend_hi
mov rax, dividend_lo
div divisor ; RAX = quotient
; RDX = remainder
RAX (quotient): 0108000000003330h 
RDX (remainder): 0000000000000020h
32
Signed Integer Division (IDIV)
• Signed integers must be sign-extended before
division takes place
• fill high byte/word/doubleword with a copy of the low 
byte/word/doubleword's sign bit
• For example, the high byte contains a copy of the 
sign bit from the low byte:
1 0 0 0 1 1 1 1
1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1
33
CBW, CWD, CDQ Instructions
• The CBW, CWD, and CDQ instructions 
provide important sign-extension operations:
• CBW (convert byte to word) extends AL into AH
• CWD (convert word to doubleword) extends AX into DX
• CDQ (convert doubleword to quadword) extends EAX into 
EDX
• Example: 
mov eax,0FFFFFF9Bh ; (-101)
cdq ; EDX:EAX = FFFFFFFFFFFFFF9Bh
34
IDIV Instruction
• IDIV (signed divide) performs signed integer division
• Same syntax and operands as DIV instruction
Example: 8-bit division of –48 by 5
mov al,-48
cbw ; extend AL into AH
mov bl,5
idiv bl ; AL = -9, AH = -3
What's Next
• Shift and Rotate Instructions
• Shift and Rotate Applications
• Multiplication and Division Instructions
• Extended Addition and Subtraction
• ASCII and UnPacked Decimal Arithmetic
• Packed Decimal Arithmetic
35
7.3 Extended Addition and Subtraction
• ADC Instruction 
• Extended Precision Addition
• SBB Instruction
• Extended Precision Subtraction
The instructions in this section do not 
apply to 64-bit mode programming.
36
CHAPTER 8: ADVANCED 
PROCEDURES
1
Chapter Overview
• Stack Frames
• Recursion
• INVOKE, ADDR, PROC, and PROTO
• Creating Multimodule Programs
• Advanced Use of Parameters (optional)
• Java Bytecodes (optional)
2
Stack Frames
• Stack Parameters
• Local Variables
• ENTER and LEAVE Instructions
• LOCAL Directive
3
Stack Frame (堆栈框架, 栈帧)
• Also known as an activation record (活动记录)
• Area of the stack set aside for a procedure's passed 
parameters, return address, saved registers, and 
local variables
• Created by the following steps:
• Calling program pushes arguments on the stack and 
calls the procedure.
• The called procedure pushes EBP on the stack, and 
sets EBP to ESP.
• If local variables are needed, a constant is subtracted 
from ESP to make room on the stack.
4
5
Stack Parameters
• More convenient than register parameters
• Two possible ways of calling DumpMem. Which is 
easier?
pushad
mov esi,OFFSET array
mov ecx,LENGTHOF array
mov ebx,TYPE array
call DumpMem
popad
push TYPE array
push LENGTHOF array
push OFFSET array
call DumpMem
Passing Arguments by Value
• Push argument values on stack
• (Use only 32-bit values in protected mode to keep the 
stack aligned)
• Call the called-procedure
• Accept a return value in EAX, if any
• Remove arguments from the stack if the called￾procedure did not remove them
6
7
Example
.data
val1 DWORD 5
val2 DWORD 6
.code
push val2
push val1
(val2) 6
(val1) 5 ESP
Stack prior to CALL 
8
Passing Arguments by Value: AddTwo
.data
sum DWORD ?
.code
push 6 ; second argument
push 5 ; first argument
call AddTwo ; EAX = sum
mov sum,eax ; save the sum
AddTwo PROC
push ebp
mov ebp,esp
.
.
00000006
00000005
return address
EBP, ESP
[EBP + 4]
[EBP + 8]
[EBP + 12]
EBP
int n = AddTwo( 5, 6 );
Passing by Reference
• Push the offsets of arguments on the stack
• Call the procedure
• Accept a return value in EAX, if any
• Remove arguments from the stack if the called 
procedure did not remove them
9
10
Example
.data
val1 DWORD 5
val2 DWORD 6
.code
push OFFSET val2
push OFFSET val1
(offset val2) 00000004
(offset val1) 00000000 ESP
 Stack prior to CALL 
11
Stack after the CALL
value or addr of val2
value or addr of val1
return address 
EBP
[EBP+12]
[EBP+8]
[EBP+4]
ESP, EBP
Accessing Stack Parameters (C/C++)
• C and C++ functions access stack parameters using 
constant offsets from EBP1
.
• Example: [ebp + 8]
• EBP is called the base pointer or frame pointer
because it holds the base address of the stack frame.
• EBP does not change value during the function.
• EBP must be restored to its original value when a 
function returns.
1 BP in Real-address mode
12
RET Instruction
• Return from subroutine
• Pops stack into the instruction pointer (EIP or IP). 
Control transfers to the target address.
• Syntax:
• RET
• RET n
• Optional operand n causes n bytes to be added to 
the stack pointer after EIP (or IP) is assigned a value.
13
14
Who removes parameters from the stack?
Caller (C) ...... or ...... Called-procedure (STDCALL): 
 AddTwo PROC
push val2 push ebp
push val1 mov ebp,esp
call AddTwo mov eax,[ebp+12]
add esp,8 add eax,[ebp+8]
 pop ebp
 ret 8
( Covered later: The MODEL directive specifies calling conventions )
15
C Call : Caller releases stack
RET does not clean up the stack.
AddTwo_C PROC
 push ebp
 mov ebp,esp
 mov eax,[ebp + 12] ; second parameter
 add eax,[ebp + 8] ; first parameter
 pop ebp
 ret ; caller cleans up the stack
AddTwo_C ENDP
_Example1 PROC
push 6
push 5
call AddTwo_C
add esp,8 ; clean up the stack
call DumpRegs ; sum is in EAX
ret
_Example1 ENDP
16
STDCall : Procedure releases stack
The RET n instruction cleans up the stack.
AddTwo PROC
 push ebp
 mov ebp,esp
 mov eax,[ebp + 12] ; second parameter
 add eax,[ebp + 8] ; first parameter
 pop ebp
 ret 8 ; clean up the stack
AddTwo ENDP
_Example2 PROC
push 6
push 5
call AddTwo
call DumpRegs ; sum is in EAX
ret
_Example2 ENDP
Local Variables
• Only statements within subroutine can view or modify 
local variables
• Storage used by local variables is released when 
subroutine ends
• local variable name can have the same name as a 
local variable in another function without creating a 
name clash
• Essential when writing recursive procedures, as well 
as procedures executed by multiple execution 
threads
17
18
Local Variables
To explicitly create local variables, subtract total size from ESP.
void MySub()
{
 int X=10;
 int Y=20;
}
MySub PROC
push ebp
mov ebp,esp
sub esp,8 ; create variables
mov DWORD PTR [ebp-4],10 ; X
mov DWORD PTR [ebp-8],20 ; Y
; ... Do something
mov esp,ebp ; remove locals from stack
pop ebp
ret
MySub ENDP LocalVars.asm
ENTER and LEAVE
• ENTER instruction creates stack frame for a called 
procedure
• pushes EBP on the stack (push ebp)
• sets EBP to the base of the stack frame (mov ebp, esp)
• reserves space for local variables (sub esp, n)
• Syntax: ENTER numBytesReserved, nestingLevel (=0)
• LEAVE instruction terminates the stack frame for a 
called procedure
• restores ESP to release local variables (mov esp, ebp)
• pops EBP for the caller (pop ebp)
19
20
LEAVE Instruction
Terminates the stack frame for a procedure. 
MySub PROC
enter 8,0
...
...
...
leave
ret
MySub ENDP
push ebp
mov ebp,esp
sub esp,8 ; 2 local DWORDs
mov esp,ebp ; free local space
pop ebp
Equivalent operations
21
LOCAL Directive
• The LOCAL directive declares a list of local 
variables
• immediately follows the PROC directive
• each variable is assigned a type
• Syntax:
LOCAL varlist
Example:
MySub PROC
LOCAL var1:BYTE, var2:WORD, var3:SDWORD
22
Using LOCAL
LOCAL flagVals[20]:BYTE ; array of bytes
LOCAL pArray:PTR WORD ; pointer to an array
myProc PROC ; procedure
LOCAL t1:BYTE, ; local variables
Examples:
23
LOCAL Example
BubbleSort PROC
LOCAL temp:DWORD, 
 SwapFlag:BYTE
. . .
ret
BubbleSort ENDP
BubbleSort PROC
push ebp ; enter 8, 0
mov ebp,esp
add esp,0FFFFFFF8h ; add -8 to ESP
. . .
mov esp,ebp ; leave
pop ebp
ret
BubbleSort ENDP See LocalExample.asm
MASM generates:
24
LEA Instruction
• LEA returns offsets of direct and indirect operands
• OFFSET operator only returns constant offsets
• LEA required when obtaining offsets of stack 
parameters & local variables
• Example
CopyString PROC,
count:DWORD
LOCAL temp[20]:BYTE
mov edi,OFFSET count ; invalid operand
mov esi,OFFSET temp ; invalid operand
lea edi,count ; ok
lea esi,temp ; ok
25
LEA Example
Suppose you have a Local variable at [ebp-8]
And you need the address of that local variable in ESI
You cannot use this: 
mov esi, OFFSET [ebp-8] ; error
Use this instead:
lea esi,[ebp-8]
What's Next
• Stack Frames
• Recursion
• Reading material
• INVOKE, ADDR, PROC, and PROTO
• Creating Multimodule Programs
• Advanced Use of Parameters (optional)
• Java Bytecodes (optional)
26
What's Next
• Stack Frames
• Recursion
• INVOKE, ADDR, PROC, and PROTO
• Creating Multimodule Programs
• Advanced Use of Parameters (optional)
• Java Bytecodes (optional)
27
INVOKE, ADDR, PROC, and PROTO
• INVOKE Directive
• ADDR Operator
• PROC Directive
• PROTO Directive
• Parameter Classifications
• Example: Exchanging Two Integers
• Debugging Tips
28
29
INVOKE Directive
• In 32-bit mode, the INVOKE directive is a powerful 
replacement for Intel’s CALL instruction that lets you 
pass multiple arguments 
• Syntax:
INVOKE procedureName [, argumentList]
• ArgumentList is an optional comma-delimited list of 
procedure arguments
• Arguments can be:
• immediate values and integer expressions
• variable names
• address and ADDR expressions
• register names
Not in 64-bit 
mode!
30
INVOKE Examples
.data
byteVal BYTE 10
wordVal WORD 1000h
.code
; direct operands:
INVOKE Sub1,byteVal,wordVal
; address of variable:
INVOKE Sub2,ADDR byteVal
; register name, integer expression:
INVOKE Sub3,eax,(10 * 20)
; address expression (indirect operand):
INVOKE Sub4,[ebx]
31
ADDR Operator
.data
myWord WORD ?
.code
INVOKE mySub,ADDR myWord
• Returns a near or far pointer to a variable, depending on 
which memory model your program uses:
• Small model: returns 16-bit offset
• Large model: returns 32-bit segment/offset
• Flat model: returns 32-bit offset
• Simple example:
Not in 64-bit 
mode!
32
PROC Directive (1 of 2) Not in 64-bit 
mode!
• The PROC directive declares a procedure
• Syntax:
label PROC [attributes] [USES regList], paramList
• The USES clause must be on the same line as PROC.
• Attributes: distance, language type, visibility
• ParamList is a list of parameters separated by commas.
label PROC, parameter1, parameter2, …, parameterN
• Each parameter has the following syntax:
paramName : type
type must either be one of the standard ASM types 
(BYTE, SBYTE, WORD, etc.), or it can be a pointer to 
one of these types. 
33
PROC Directive (2 of 2)
• Alternate format permits parameter list to be on one or 
more separate lines:
label PROC,
paramList
• The parameters can be on the same line . . .
param-1:type-1, param-2:type-2, . . ., param-n:type-n
• Or they can be on separate lines:
param-1:type-1, 
param-2:type-2,
. . ., 
param-n:type-n
comma required
34
AddTwo Procedure
AddTwo PROC,
val1:DWORD, val2:DWORD
mov eax,val1
add eax,val2
ret
AddTwo ENDP
• The AddTwo procedure receives two integers and returns 
their sum in EAX.
PROTO Directive
• Creates a procedure prototype
• Syntax:
• label PROTO paramList
• Every procedure called by the INVOKE directive must 
have a prototype
• A complete procedure definition can also serve as its 
own prototype
35
36
PROTO Directive
• Standard configuration: PROTO appears at top of the program 
listing, INVOKE appears in the code segment, and the procedure 
implementation occurs later in the program:
MySub PROTO ; procedure prototype
.code
INVOKE MySub ; procedure call
MySub PROC ; procedure implementation
.
.
MySub ENDP
37
PROTO Example
• Prototype for the ArraySum procedure, showing its 
parameter list:
ArraySum PROTO,
ptrArray:PTR DWORD, ; points to the array
szArray:DWORD ; array size
Parameter Classifications
• An input parameter is data passed by a calling program to a 
procedure. 
• The called procedure is not expected to modify the 
corresponding parameter variable, and even if it does, the 
modification is confined to the procedure itself.
• An output parameter is created by passing a pointer to a variable 
when a procedure is called. 
• The procedure does not use any existing data from the variable, 
but it fills in a new value before it returns.
• An input-output parameter is a pointer to a variable containing input 
that will be both used and modified by the procedure. 
• The variable passed by the calling program is modified.
38
Multimodule Programs
• A multimodule program is a program whose source 
code has been divided up into separate ASM files.
• Each ASM file (module) is assembled into a separate 
OBJ file.
• All OBJ files belonging to the same program are 
linked using the link utility into a single EXE file.
• This process is called static linking
39
Creating a Multimodule Program
• Here are some basic steps to follow when 
creating a multimodule program:
• Create the main module
• Create a separate source code module for each 
procedure or set of related procedures
• Create an include file that contains procedure 
prototypes for external procedures (ones that are 
called between modules)
• Use the INCLUDE directive to make your 
procedure prototypes available to each module
40
CHAPTER 9: 
STRINGS AND ARRAYS
1
Chapter Overview
• String Primitive Instructions
• Selected String Procedures
• Two-Dimensional Arrays
• Searching and Sorting Integer Arrays
• Java Bytecodes: String Processing 
(optional topic)
2
String Primitive Instructions
• MOVSB, MOVSW, and MOVSD
• CMPSB, CMPSW, and CMPSD
• SCASB, SCASW, and SCASD
• STOSB, STOSW, and STOSD
• LODSB, LODSW, and LODSD
3
4
MOVSB, MOVSW, and MOVSD (1 of 2)
• The MOVSB, MOVSW, and MOVSD instructions 
copy data from the memory location pointed to by 
ESI to the memory location pointed to by EDI.
.data
source DWORD 0FFFFFFFFh
target DWORD ?
.code
mov esi,OFFSET source
mov edi,OFFSET target
movsd
5
MOVSB, MOVSW, and MOVSD (2 of 2)
• ESI and EDI are automatically incremented or 
decremented:
• MOVSB increments/decrements by 1
• MOVSW increments/decrements by 2
• MOVSD increments/decrements by 4
6
Direction Flag
• The Direction flag controls the incrementing or 
decrementing of ESI and EDI.
• DF = clear (0): increment ESI and EDI
• DF = set (1): decrement ESI and EDI
The Direction flag can be explicitly changed using the 
CLD and STD instructions:
CLD ; clear Direction flag
STD ; set Direction flag
7
Using a Repeat Prefix
• REP (a repeat prefix) can be inserted just before 
MOVSB, MOVSW, or MOVSD. 
• ECX controls the number of repetitions
• Example: Copy 20 doublewords from source to target
.data
source DWORD 20 DUP('
z
')
target DWORD 20 DUP(?)
.code
cld ; direction = forward
mov ecx,LENGTHOF source ; set REP counter
mov esi,OFFSET source
mov edi,OFFSET target
rep movsd
CMPSB, CMPSW, and CMPSD
• The CMPSB, CMPSW, and CMPSD instructions 
each compare a memory operand pointed to by ESI 
to a memory operand pointed to by EDI.
• CMPSB compares bytes
• CMPSW compares words
• CMPSD compares doublewords
• Repeat prefix often used
• REPE (REPZ)
• REPNE (REPNZ)
8
9
Comparing a Pair of Doublewords
.data
source DWORD 1234h
target DWORD 5678h
.code
mov esi,OFFSET source
mov edi,OFFSET target
cmpsd ; compare doublewords
ja L1 ; jump if source > target
jmp L2 ; jump if source <= target
If source > target, the code jumps to label L1; otherwise, 
it jumps to label L2
10
Comparing Arrays
.data
source DWORD COUNT DUP(?)
target DWORD COUNT DUP(?)
.code
mov ecx,COUNT ; repetition count
mov esi,OFFSET source
mov edi,OFFSET target
cld ; direction = forward
repe cmpsd ; repeat while equal
Use a REPE (repeat while equal) prefix to compare 
corresponding elements of two arrays.
SCASB, SCASW, and SCASD
• The SCASB, SCASW, and SCASD instructions 
compare a value in AL/AX/EAX to a byte, word, or 
doubleword, respectively, addressed by EDI.
• Useful types of searches:
• Search for a specific element in a long string or array.
• Search for the first element that does not match a 
given value.
11
12
SCASB Example
.data
alpha BYTE "ABCDEFGH",0
.code
mov edi,OFFSET alpha
mov al,'F' ; search for 'F'
mov ecx,LENGTHOF alpha
cld
repne scasb ; repeat while not equal
jnz quit
dec edi ; EDI points to 'F'
Search for the letter 'F' in a string named alpha:
What is the purpose of the JNZ instruction?
Summary (Chap 7)
• Shift and rotate instructions are some of the best 
tools of assembly language
• finer control than in high-level languages
• SHL, SHR, SAR, ROL, ROR, RCL, RCR
• MUL and DIV – integer operations
• close relatives of SHL and SHR
• CBW, CDQ, CWD: preparation for division
13
Summary (Chap 8)
• Stack parameters
• more convenient than register parameters
• passed by value or reference
• ENTER and LEAVE instructions
• Local variables
• created on the stack below stack pointer
• LOCAL directive
• Recursive procedure calls itself
• Calling conventions (C, stdcall)
• MASM procedure-related directives
• INVOKE, PROC, PROTO
14
Summary (Chap 9)
• String primitives are optimized for efficiency
15
Summary
16
Homework
• Reading Chap 7 – 9.2
• Exercises
17
本次课程是
线下教学
请现场的同学们：
打开雨课堂，点击页面右下角喇叭
按钮调至静音状态
CHAPTER 9: 
 STRINGS AND ARRAYS
2
Chapter Overview
• String Primitive Instructions
• Selected String Procedures
• Two-Dimensional Arrays
• Searching and Sorting Integer Arrays
• Java Bytecodes: String Processing 
(optional topic)
3
4
STOSB, STOSW, and STOSD
• The STOSB, STOSW, and STOSD instructions store 
the contents of AL/AX/EAX, respectively, in memory 
at the offset pointed to by EDI.
• Example: fill an array with 0FFh
.data
Count = 100
string1 BYTE Count DUP(?)
.code
mov al,0FFh ; value to be stored
mov edi,OFFSET string1 ; ES:DI points to target
mov ecx,Count ; character count
cld ; direction = forward
rep stosb ; fill with contents of AL
5
LODSB, LODSW, and LODSD
• LODSB, LODSW, and LODSD load a byte or word from 
memory at ESI into AL/AX/EAX, respectively. 
• Example:
.data
array BYTE 1,2,3,4,5,6,7,8,9
.code
mov esi,OFFSET array
mov ecx,LENGTHOF array
cld
L1: lodsb ; load byte into AL
or al,30h ; convert to ASCII
call WriteChar ; display it
loop L1
What's Next
• String Primitive Instructions
• Selected String Procedures
• Two-Dimensional Arrays
• Searching and Sorting Integer Arrays
• Java Bytecodes: String Processing 
(optional topic)
6
Selected String Procedures
The following string procedures may be found in the 
Irvine32 and Irvine16 libraries:
• Str_compare Procedure
• Str_length Procedure
• Str_copy Procedure
• Str_trim Procedure
• Str_ucase Procedure
7
What's Next
• String Primitive Instructions
• Selected String Procedures
• Two-Dimensional Arrays
• Searching and Sorting Integer Arrays
• Java Bytecodes: String Processing 
(optional topic)
8
Two-Dimensional Arrays
• Base-Index Operands
• Base-Index Displacement
9
Base-Index Operand
• A base-index (基址变址) operand adds the values of 
two registers (called base and index), producing an 
effective address. Any two 32-bit general-purpose 
registers may be used.
• Base-index operands are great for accessing arrays of 
structures. (A structure groups together data under a 
single name. )
10
11
Structure Application
A common application of base-index addressing has to 
do with addressing arrays of structures (Chapter 10). 
The following definds a structure named COORD 
containing X and Y screen coordinates:
COORD STRUCT
 X WORD ? ; offset 00
 Y WORD ? ; offset 02
COORD ENDS
.data
setOfCoordinates COORD 10 DUP(<>)
Then we can define an array of COORD objects:
12
Structure Application
The following code loops through the array and displays 
each Y-coordinate:
mov ebx,OFFSET setOfCoordinates
mov esi,2 ; offset of Y value
mov eax,0
 mov ecx,lengthof setOfCoordinates
L1:mov ax,[ebx+esi]
call WriteDec
add ebx,SIZEOF COORD
loop L1
Base-Index-Displacement Operand
• A base-index-displacement (相对基址变址) operand 
adds base and index registers to a constant, producing 
an effective address. Any two 32-bit general-purpose 
registers may be used. 
• Common formats: 
[ base + index + displacement ]
displacement [ base + index ]
13
64-bit Base-Index-Displacement Operand
• A 64-bit base-index-displacement operand adds base 
and index registers to a constant, producing a 64-bit 
effective address. Any two 64-bit general-purpose 
registers can be used. 
• Common formats: 
[ base + index + displacement ]
displacement [ base + index ]
14
15
Two-Dimensional Table Example
Imagine a table with three rows and five columns. The 
data can be arranged in any format on the page:
table BYTE 10h, 20h, 30h, 40h, 50h
 BYTE 60h, 70h, 80h, 90h, 0A0h
 BYTE 0B0h, 0C0h, 0D0h, 0E0h, 0F0h
NumCols = 5
table BYTE 10h,20h,30h,40h,50h,60h,70h,
 80h,90h,0A0h,
 0B0h,0C0h,0D0h, 
 0E0h,0F0h
NumCols = 5
Alternative format:
16
Two-Dimensional Table Example
The following code loads the table element stored in row 
1, column 2:
RowNumber = 1
ColumnNumber = 2
mov ebx,NumCols * RowNumber
mov esi,ColumnNumber
mov al,table[ebx + esi]
10 20 30 40 50 60 70 80 90 A0
150 155
table[ebx]
B0 C0 D0 E0 F0
table[ebx + esi]
157
table
17
Two-Dimensional Table Example (64-bit)
The following 64-bit code loads the table element stored 
in row 1, column 2:
RowNumber = 1
ColumnNumber = 2
mov rbx,NumCols * RowNumber
mov rsi,ColumnNumber
mov al,table[rbx + rsi]
10 20 30 40 50 60 70 80 90 A0
150 155
table[ebx]
B0 C0 D0 E0 F0
table[ebx + esi]
157
table
table[rbx] table[rbx + rsi]
What's Next
• String Primitive Instructions
• Selected String Procedures
• Two-Dimensional Arrays
• Searching and Sorting Integer Arrays
• Java Bytecodes: String Processing 
(optional topic)
18
Searching and Sorting Integer Arrays
• Bubble Sort
• A simple sorting algorithm that works well for small 
arrays
• Binary Search
• A simple searching algorithm that works well for 
large arrays of values that have been placed in 
either ascending or descending order
19
20
Bubble Sort
Each pair of adjacent values is compared, and exchanged if the 
values are not ordered correctly:
3
1
7
5
2
9
4
3
1
3
7
5
2
9
4
3
1
3
7
5
2
9
4
3
1
3
5
7
2
9
4
3
1
3
5
2
7
9
4
3
1
3
5
2
7
4
9
3
1
3
5
7
2
4
3
9
One Pass (Bubble Sort)
1
3
5
2
7
9
4
3
(shaded values have been exchanged)
21
Bubble Sort Pseudocode
N = array size, cx1 = outer loop counter, cx2 = inner loop 
counter:
cx1 = N - 1
while( cx1 > 0 )
{
 esi = addr(array)
 cx2 = cx1
 while( cx2 > 0 )
 {
 if( array[esi] < array[esi+4] )
 exchange( array[esi], array[esi+4] )
 add esi,4
 dec cx2
 }
 dec cx1
}
22
Bubble Sort Implementation
BubbleSort PROC USES eax ecx esi,
pArray:PTR DWORD,Count:DWORD
mov ecx,Count
dec ecx ; decrement count by 1
L1: push ecx ; save outer loop count
mov esi,pArray ; point to first value
L2: mov eax,[esi] ; get array value
cmp [esi+4],eax ; compare a pair of values
jge L3 ; if [esi] <= [esi+4], skip
xchg eax,[esi+4] ; else exchange the pair
mov [esi],eax
L3: add esi,4 ; move both pointers forward
loop L2 ; inner loop
pop ecx ; retrieve outer loop count
loop L1 ; else repeat outer loop
L4: ret
BubbleSort ENDP
CHAPTER 10: 
STRUCTURES AND MACROS
1
Chapter Overview
• Structures
• Macros
• Conditional-Assembly Directives
• Defining Repeat Blocks
2
Structures - Overview
• Defining Structures
• Declaring Structure Variables
• Referencing Structure Variables
• Example: Displaying the System Time
• Nested Structures
• Example: Drunkard's Walk
• Declaring and Using Unions
3
Structure
• A template or pattern given to a logically related 
group of variables. 
• field - structure member containing data
• Program access to a structure:
• entire structure as a complete unit
• individual fields
• Useful way to pass multiple related arguments to a 
procedure
• example: file directory information
4
Using a Structure
Using a structure involves three sequential steps: ？ 
1. Define the structure.
2. Declare one or more variables of the structure type, 
called structure variables.
3. Write runtime instructions that access the structure.
5
6
Structure Definition Syntax
name STRUCT
field-declarations
name ENDS
• Field-declarations are identical to variable 
declarations
7
COORD Structure
• The COORD structure used by the MS-Windows 
programming library identifies X and Y screen 
coordinates
COORD STRUCT
X WORD ? ; offset 00
Y WORD ? ; offset 02
COORD ENDS
8
Employee Structure
Employee STRUCT
IdNum BYTE "000000000"
LastName BYTE 30 DUP(0)
Years WORD 0
SalaryHistory DWORD 0,0,0,0
Employee ENDS
A structure is ideal for combining fields of different types:
"000000000" (null) 0 0 0 0 0
SalaryHistory Lastname
Years
Idnum
9
Declaring Structure Variables
• Structure name is a user-defined type
• Insert replacement initializers between brackets:
< . . . >
• Empty brackets <> retain the structure's default 
field initializers
• Examples:
.data
point1 COORD <5,10>
point2 COORD <>
worker Employee <>
Initializing Array Fields
• Use the DUP operator to initialize one or more 
elements of an array field:
.data
emp Employee <,,,2 DUP(20000)>
10
Array of Structures
• An array of structure objects can be defined using 
the DUP operator.
• Initializers can be used
NumPoints = 3
AllPoints COORD NumPoints DUP(<0,0>)
RD_Dept Employee 20 DUP(<>)
accounting Employee 10 DUP(<,,,4 DUP(20000) >)
11
12
Referencing Structure Variables
.data
worker Employee <>
mov eax,TYPE Employee ; 57
mov eax,SIZEOF Employee ; 57
mov eax,SIZEOF worker ; 57
mov eax,TYPE Employee.SalaryHistory ; 4
mov eax,LENGTHOF Employee.SalaryHistory ; 4
mov eax,SIZEOF Employee.SalaryHistory ; 16
Employee STRUCT ; bytes
IdNum BYTE "000000000" ; 9
LastName BYTE 30 DUP(0) ; 30
Years WORD 0 ; 2
SalaryHistory DWORD 0,0,0,0 ; 16
Employee ENDS ; 57
13
. . . continued
mov dx,worker.Years
mov worker.SalaryHistory,20000 ; first salary
mov worker.SalaryHistory+4,30000 ; second salary
mov edx,OFFSET worker.LastName ; 00404009
mov esi,OFFSET worker ; 00404000
mov ax,(Employee PTR [esi]).Years
mov ax,[esi].Years ; invalid operand (ambiguous)
14
Nested Structures (1 of 2)
Rectangle STRUCT
UpperLeft COORD <>
LowerRight COORD <>
Rectangle ENDS
.data
rect1 Rectangle { {10,10}, {50,20} }
rect2 Rectangle < <10,10>, <50,20> >
• Define a structure that contains other structures.
• Used nested braces (or brackets) to initialize each 
COORD structure.
COORD STRUCT
X WORD ? 
Y WORD ? 
COORD ENDS
15
Nested Structures (2 of 2)
mov rect1.UpperLeft.X, 10
mov esi,OFFSET rect1
mov (Rectangle PTR [esi]).UpperLeft.Y, 10
// use the OFFSET operator
mov edi,OFFSET rect2.LowerRight
mov (COORD PTR [edi]).X, 50
mov edi,OFFSET rect2.LowerRight.X
mov WORD PTR [edi], 50
• Use the dot (.) qualifier to access nested fields.
• Use indirect addressing to access the overall 
structure or one of its fields
16
Declaring and Using Unions
• A union is similar to a structure in that it contains 
multiple fields
• All of the fields in a union begin at the same offset
• (differs from a structure)
• Provides alternate ways to access the same data
• Syntax:
unionname UNION
union-fields
unionname ENDS
17
Integer Union Example
Integer UNION
D DWORD 0
W WORD 0
B BYTE 0
Integer ENDS
The Integer union consumes 4 bytes (equal to the largest field)
.data
val1 Integer <12345678h>
val2 Integer <100h>
val3 Integer <>
D, W, and B are often called variant fields. 
Integer can be used to define data:
Integer Union Example
The variant field name is required when accessing 
the union:
mov val3.B, al
mov ax,val3.W
add val3.D, eax
18
What's Next
• Structures
• Macros
• Conditional-Assembly Directives
• Defining Repeat Blocks
19
Macros
• Introducing Macros
• Defining Macros
• Invoking Macros
• Macro Examples
• Nested Macros
• Example Program: Wrappers
20
21
Introducing Macros
• A macro1
is a named block of assembly language 
statements. 
• Once defined, it can be invoked (called) one or more 
times.
• During the assembler's preprocessing step, each 
macro call is expanded into a copy of the macro.
• The expanded code is passed to the assembly step, 
where it is checked for correctness.
1Also called a macro procedure.
22
Defining Macros
• A macro must be defined before it can be used.
• Parameters are optional.
• Each parameter follows the rules for identifiers. It is 
a string that is assigned a value when the macro is 
invoked. 
• Syntax:
macroname MACRO [parameter-1, parameter-2,...]
statement-list
ENDM
23
mNewLine Macro Example
mNewLine MACRO ; define the macro
call Crlf
ENDM
.data
.code
mNewLine ; invoke the macro
This is how you define and invoke a simple macro.
The assembler will substitute "call crlf" for "mNewLine".
24
mPutChar Macro
mPutchar MACRO char
push eax
mov al,char
call WriteChar
pop eax
ENDM
Writes a single character to standard output.
Definition:
.code
mPutchar 'A' Invocation:
1 push eax
1 mov al,'A'
1 call WriteChar
1 pop eax
Expansion:
viewed in the 
listing file
25
Invoking Macros (1 of 2)
• When you invoke a macro, each argument you pass 
matches a declared parameter.
• Each parameter is replaced by its corresponding 
argument when the macro is expanded. 
• When a macro expands, it generates assembly 
language source code.
• Arguments are treated as simple text by the 
preprocessor.
26
Invoking Macros (2 of 2)
parameter macro
text
argument
replaces
declared
inside
consists
o f passes
macro
invocation
statement
generates
assembly
code
Relationships between macros, arguments, and parameters:
27
mWriteStr Macro (1 of 2)
mWriteStr MACRO buffer
push edx
mov edx,OFFSET buffer
call WriteString
pop edx
ENDM
.data
str1 BYTE "Welcome!",0
.code
mWriteStr str1
Provides a convenient way to display a string, by 
passing the string name as an argument.
28
mWriteStr Macro (2 of 2)
1 push edx
1 mov edx,OFFSET str1
1 call WriteString
1 pop edx
The expanded code shows how the str1 argument 
replaced the parameter named buffer:
mWriteStr MACRO buffer
push edx
mov edx,OFFSET buffer
call WriteString
pop edx
ENDM
29
Invalid Argument
• If you pass an invalid argument, the error is caught 
when the expanded code is assembled.
• Example:
.code
mPutchar 1234h
1 push eax
1 mov al,1234h ; error!
1 call WriteChar
1 pop eax
30
Blank Argument
• If you pass a blank argument, the error is also caught 
when the expanded code is assembled.
• Example:
.code
mPutchar
1 push eax
1 mov al,
1 call WriteChar
1 pop eax
What's Next
• Structures
• Macros
• Conditional-Assembly Directives
• Defining Repeat Blocks
31
Conditional-Assembly Directives
• Checking for Missing Arguments
• Default Argument Initializers
• Boolean Expressions
• IF, ELSE, and ENDIF Directives
• The IFIDN and IFIDNI Directives
• Special Operators
• Macro Functions
32
33
Checking for Missing Arguments
• The IFB directive returns true if its argument is blank. 
For example:
IFB <row> ;; if row is blank,
 EXITM ;; exit the macro
ENDIF
mWriteString Example
Display a message during assembly if the string parameter is 
empty:
mWriteStr MACRO string
IFB <string>
ECHO -----------------------------------------
ECHO * Error: parameter missing in mWriteStr
ECHO * (no code generated)
ECHO -----------------------------------------
EXITM
ENDIF
push edx
mov edx,OFFSET string
call WriteString
pop edx
ENDM
34
35
Default Argument Initializers
• A default argument initializer automatically assigns a 
value to a parameter when a macro argument is left 
blank. For example, mWriteln can be invoked either 
with or without a string argument:
mWriteLn MACRO text:=<" ">
mWrite text
call Crlf
ENDM
.code
mWriteln "Line one"
mWriteln
mWriteln "Line three"
Line one
Line three
Sample output:
Boolean Expressions
A boolean expression can be formed using the 
following operators:
• LT - Less than
• GT - Greater than
• EQ - Equal to
• NE - Not equal to
• LE - Less than or equal to
• GE - Greater than or equal to
Only assembly-time constants may be compared using these 
operators.
36
37
IF, ELSE, and ENDIF Directives
IF boolean-expression
statements
[ELSE
statements]
ENDIF
A block of statements is assembled if the boolean expression 
evaluates to true. An alternate block of statements can be 
assembled if the expression is false.
38
Simple Example
IF RealMode EQ 1
 mov ax,@data
 mov ds,ax
ENDIF
The following IF directive permits two MOV instructions to be 
assembled if a constant named RealMode is equal to 1:
RealMode can be defined in the source code any of the following 
ways:
RealMode = 1
RealMode EQU 1
RealMode TEXTEQU 1
The IFIDN and IFIDNI Directives
• IFIDN compares two symbols and returns true if they 
are equal (case-sensitive)
• IFIDNI also compares two symbols, using a case￾insensitive comparison
• Syntax:
IFIDNI <symbol>, <symbol>
statements
ENDIF
Can be used to prevent the caller of a macro from passing an 
argument that would conflict with register usage inside the macro.
39
IFIDNI Example
Prevents the user from passing EDX as the second argument 
to the mReadBuf macro:
mReadBuf MACRO bufferPtr, maxChars
IFIDNI <maxChars>,<EDX>
ECHO Warning: Second argument cannot be EDX
ECHO **************************************
EXITM
ENDIF
. 
.
ENDM
40
Special Operators
• The substitution (&) operator resolves ambiguous 
references to parameter names within a macro.
• The expansion operator (%) expands text macros or 
converts constant expressions into their text 
representations.
• The literal-text operator (<>) groups one or more 
characters and symbols into a single text literal. It 
prevents the preprocessor from interpreting members 
of the list as separate arguments.
• The literal-character operator (!) forces the 
preprocessor to treat a predefined operator as an 
ordinary character.
41
42
替换操作符 Substitution (&)
ShowRegister MACRO regName
.data
tempStr BYTE " &regName=",0
. 
.
.code
ShowRegister EDX ; invoke the macro
Text passed as regName is substituted into the literal string 
definition:
tempStr BYTE " EDX=",0
Macro expansion:
展开操作符 Expansion (%)
Forces the evaluation of an integer expression. After the 
expression has been evaluated, its value is passed as a macro 
argument:
mGotoXY %(5 * 10),%(3 + 4)
The preprocessor generates the following code:
1 push edx
1 mov dl,50
1 mov dh,7
1 call Gotoxy
1 pop edx
43
文本操作符 Literal-Text (<>)
The first macro call passes three arguments. The second call 
passes a single argument:
mWrite "Line three", 0dh, 0ah
mWrite <"Line three", 0dh, 0ah>
44
特殊文本字符操作符 Literal-Character (!)
The following declaration prematurely ends the text definition 
when the first > character is reached.
BadYValue TEXTEQU Warning: <Y-coordinate is > 24>
The following declaration continues the text definition until 
the final > character is reached.
BadYValue TEXTEQU <Warning: Y-coordinate is !> 24>
45
46
Macro Functions (1 of 2)
• A macro function returns an integer or string constant 
• The value is returned by the EXITM directive
• Example: The IsDefined macro acts as a wrapper for 
the IFDEF directive.
IsDefined MACRO symbol
IFDEF symbol
EXITM <-1> ;; True
ELSE
EXITM <0> ;; False
ENDIF
ENDM
Notice how the assembler defines True and False.
47
Macro Functions (2 of 2)
• When calling a macro function, the argument(s) must 
be enclosed in parentheses
• The following code permits the two MOV statements 
to be assembled only if the RealMode symbol has 
been defined:
IF IsDefined( RealMode )
mov ax,@data
mov ds,ax
ENDIF
What's Next
• Structures
• Macros
• Conditional-Assembly Directives
• Defining Repeat Blocks
48
Defining Repeat Blocks
• WHILE Directive
• REPEAT Directive
• FOR Directive
• FORC Directive
• Example: Linked List
49
50
WHILE Directive
• The WHILE directive repeats a statement block as 
long as a particular constant expression is true. 
• Syntax:
WHILE constExpression
statements
ENDM
51
WHILE Example
.data
val1 = 1
val2 = 1
DWORD val1 ; first two values
DWORD val2
val3 = val1 + val2
WHILE val3 LT 0F0000000h
DWORD val3
val1 = val2
val2 = val3
val3 = val1 + val2
ENDM
Generates Fibonacci integers between 1 and F0000000h at 
assembly time:
52
REPEAT Directive
• The REPEAT directive repeats a statement block a 
fixed number of times.
• Syntax:
REPEAT constExpression
statements
ENDM
ConstExpression, an unsigned constant integer expression, 
determines the number of repetitions.
53
REPEAT Example
iVal = 10
REPEAT 100
DWORD iVal
iVal = iVal + 10
ENDM
The following code generates 100 integer data definitions in the 
sequence 10, 20, 30, . . . 
54
FOR Directive
• The FOR directive repeats a statement block by 
iterating over a comma-delimited list of symbols.
• Each symbol in the list causes one iteration of the 
loop.
• Syntax:
FOR parameter,<arg1,arg2,arg3,...>
statements
ENDM
55
FOR Example
Window STRUCT
FOR color,<frame,titlebar,background,foreground>
color DWORD ?
ENDM
Window ENDS
The following Window structure contains frame, title bar, 
background, and foreground colors. The field definitions are 
created using a FOR directive:
Generated code:
Window STRUCT
 frame DWORD ?
 titlebar DWORD ?
background DWORD ?
foreground DWORD ?
Window ENDS
56
FORC Directive
• The FORC directive repeats a statement block by 
iterating over a string of characters. Each character in 
the string causes one iteration of the loop.
• Syntax:
FORC parameter, <string>
statements
ENDM
57
FORC Example
FORC code,<ABCDEFG>
Group_&code WORD ?
ENDM
Suppose we need to accumulate seven sets of integer data for 
an experiment. Their label names are to be Group_A, Group_B, 
Group_C, and so on. The FORC directive creates the variables:
Generated code:
Group_A WORD ?
Group_B WORD ?
Group_C WORD ?
Group_D WORD ?
Group_E WORD ?
Group_F WORD ?
Group_G WORD ?
CHAPTER 11: MS-WINDOWS 
PROGRAMMING
1
Chapter Overview
• Win32 Console Programming
• Writing a Graphical Windows Application
• Dynamic Memory Allocation
• x86 Memory Management
2
Win32 Console Programming
• Background Information
• Win32 Console Programs
• API and SDK
• Windows Data Types
• Standard Console Handles
• Console Input
• Console Output
• Reading and Writing Files
• Console Window Manipulation
• Controlling the Cursor
• Controlling the Text Color
• Time and Date Functions
3
Win32 Console Programs
• Run in Protected mode
• Emulate MS-DOS
• Standard text-based input and output
• Linker option : /SUBSYSTEM:CONSOLE
• The console input buffer contains a queue of input 
records, each containing data about an input event. 
• A console screen buffer is a two-dimensional array of 
character and color data that affects the appearance 
of text in the console window.
4
Classifying Console Functions
• Text-oriented (high-level) console functions
• Read character streams from input buffer
• Write character streams to screen buffer
• Redirect input and output
• Event-oriented (low-level) console functions
• Retrieve keyboard and mouse events
• Detect user interactions with the console window
• Control window size & position, text colors
5
6
Translating Windows Data Types
Windows Type(s) MASM Type
BOOL DWORD
LONG SDWORD
COLORREF, HANDLE, LPARAM, LPCTSTR, 
LPTSTR, LPVOID, LRESULT, UINT, WNDPROC, 
WPARAM
DWORD
BSTR, LPCSTR, LPSTR PTR BYTE
WORD WORD
LPCRECT PTR RECT
Standard Console Handles
A handle is an unsigned 32-bit integer. The 
following MS-Windows constants are predefined 
to specify the type of handle requested:
• STD_INPUT_HANDLE
• standard input
• STD_OUTPUT_HANDLE
• standard output
• STD_ERROR_HANDLE
• standard error output
• HANDLE TEXTEQU <DWORD>
7
8
GetStdHandle
• GetStdHandle returns a handle to a console stream
• Specify the type of handle (see previous slide)
• The handle is returned in EAX
• Prototype:
• Sample call:
GetStdHandle PROTO,
 nStdHandle:HANDLE ; handle type
.data
outputHandle HANDLE ?
.code
 INVOKE GetStdHandle, STD_OUTPUT_HANDLE
 mov outputHandle, eax
9
Console Input
• The ReadConsole function provides a convenient 
way to read text input and put it in a buffer. 
• Prototype:
ReadConsole PROTO,
hConsoleInput:HANDLE, ; input handle
lpBuffer:PTR BYTE, ; pointer to buffer
nNumberOfCharsToRead:DWORD, ; number of chars to read
lpNumberOfCharsRead:PTR DWORD, ; ptr to num bytes read
notUsed:DWORD ; (not used)
Single-Character Input
Here's how to input single characters:
• Get a copy of the current console flags by calling 
GetConsoleMode. Save the flags in a variable.
• Change the console flags by calling 
SetConsoleMode.
• Input a character by calling ReadConsole.
• Restore the previous values of the console flags by 
calling SetConsoleMode.
10
11
COORD and SMALL_RECT
• The COORD structure specifies X and Y screen 
coordinates in character measurements, which default to 
0-79 and 0-24. 
• The SMALL_RECT structure specifies a window’s 
location in character measurements.
COORD STRUCT
X WORD ?
Y WORD ?
COORD ENDS
SMALL_RECT STRUCT
 Left WORD ?
 Top WORD ?
 Right WORD ?
 Bottom WORD ?
SMALL_RECT ENDS
12
WriteConsole
• The WriteConsole function writes a string to the 
screen, using the console output handle. It acts upon 
standard ASCII control characters such as tab, 
carriage return, and line feed. 
• Prototype:
WriteConsole PROTO,
hConsoleOutput:HANDLE, ; output handle
lpBuffer:PTR BYTE, ; pointer to buffer
nNumberOfCharsToWrite:DWORD, ; size of buffer
lpNumberOfCharsWritten:PTR DWORD, ; output count
lpReserved:DWORD ; (not used)
Example: Console1.asm
13
mainc1 PROC
; Get the console output handle:
INVOKE GetStdHandle, STD_OUTPUT_HANDLE
mov consoleHandle,eax
mov ebx, messageSize
 ; Write a string to the console:
INVOKE WriteConsole,
 consoleHandle, ; console output handle
 ADDR message, ; string pointer
 ebx, ; string length
 ADDR bytesWritten, ; ret num bytes written
 0 ; not used
INVOKE ExitProcess,0
mainc1 ENDP
Console Window Manipulation
• Screen buffer
• Console window
• Controlling the cursor
• Controlling the text color
14
15
Screen Buffer and Console Window
• The active screen buffer (屏幕缓冲区) includes data 
displayed by the console window (控制台窗口).
text text text text text text text text text
text text text text text text text text text
text text text text text text text text text
text text text text text text text text text
text text text text text text text text text
text text text text text text text text text
text text text text text text text text text
text text text text text text text text text
text text text text text text text text text
text text text text text text text text text
text text text text text text text text text
text text text text text text text text text
text text text text text text text text text
text text text text text text text text text
text text text text text text text text text
text text text text text text text text text
text text text text text text text text text
text text text text text text text text text
text text text text text text text text text
text text text text text
text text text text text
text text text text text
text text text text text
text text text text text
text text text text text
active screen
buffer
console window
SetConsoleTitle
SetConsoleTitle changes the console window's title. 
Pass it a null-terminated string:
.data
titleStr BYTE "Console title",0
.code
INVOKE SetConsoleTitle, ADDR titleStr
16
17
GetConsoleScreenBufferInfo
.data
outHandle DWORD ?
consoleInfo CONSOLE_SCREEN_BUFFER_INFO <>
.code
INVOKE GetConsoleScreenBufferInfo,
outHandle,
ADDR consoleInfo
GetConsoleScreenBufferInfo returns information about the 
current state of the console window. It has two parameters: a 
handle to the console screen, and a pointer to a structure that 
is filled in by the function:
18
CONSOLE_SCREEN_BUFFER_INFO
CONSOLE_SCREEN_BUFFER_INFO STRUCT
 dwSize COORD <>
 dwCursorPosition COORD <>
 wAttributes WORD ?
 srWindow SMALL_RECT <>
 dwMaximumWindowSize COORD <>
CONSOLE_SCREEN_BUFFER_INFO ENDS
• dwSize - size of the screen buffer (char columns and rows)
• dwCursorPosition - cursor location
• wAttributes - colors of characters in console buffer
• srWindow - coords of console window relative to screen buffer
• dwMaximumWindowSize - maximum size of the console window
19
SetConsoleWindowInfo
• SetConsoleWindowInfo lets you set the size and 
position of the console window relative to its screen 
buffer.
• If bAbsolute is true, the coordinates specify the new 
upper left and lower right corners of the console window. 
• If bAbsolute is false, the coordinates will be added to the 
current window coordinates.
• Prototype:
SetConsoleWindowInfo PROTO,
hConsoleOutput:HANDLE, ; screen buffer handle
bAbsolute:DWORD, ; coordinate type.绝/相对
lpConsoleWindow:PTR SMALL_RECT; ptr to window rectangle
20
SetConsoleScreenBufferSize 
• SetConsoleScreenBufferSize lets you set the screen 
buffer size to X columns by Y rows. 
• Prototype:
SetConsoleScreenBufferSize PROTO,
 hConsoleOutput:HANDLE, ; handle to screen buffer
 dwSize:COORD ; new screen buffer size
Controlling the Cursor
• GetConsoleCursorInfo
• returns the size and visibility of the console cursor 
• SetConsoleCursorInfo
• sets the size and visibility of the cursor
• SetConsoleCursorPosition
• sets the X, Y position of the cursor 
21
22
CONSOLE_CURSOR_INFO 
CONSOLE_CURSOR_INFO STRUCT
 dwSize DWORD ?
 bVisible DWORD ?
CONSOLE_CURSOR_INFO ENDS
• Structure containing information about the console’s 
cursor size and visibility
• dwSize: Percentage 1 to 100 of the character cell
• bVisible: TRUE(1) or FALSE(0)
100 50 25
23
SetConsoleTextAttribute
• Sets the foreground and background colors of all 
subsequent text written to the console.
• Prototype:
SetConsoleTextAttribute PROTO,
hConsoleOutput:HANDLE, ; console output handle
wAttributes:WORD ; color attribute
24
WriteConsoleOutputAttribute
• Copies an array of attribute values to consecutive 
cells of the console screen buffer, beginning at a 
specified location.
• Prototype:
WriteConsoleOutputAttribute PROTO,
hConsoleOutput:HANDLE, ; output handle
lpAttribute:PTR WORD, ; write attributes颜色属性数组
nLength:DWORD, ; number of cells 颜色属性数量
dwWriteCoord:COORD, ; first cell coordinates
lpNumberOfAttrsWritten:PTR DWORD ; output count
25
WriteConsoleOutputCharacter
• The WriteConsoleOutputCharacter function copies an 
array of characters to consecutive cells of the 
console screen buffer, beginning at a specified 
location. 
• Prototype:
WriteConsoleOutputCharacter PROTO,
 hConsoleOutput:HANDLE, ; console output handle
 lpCharacter:PTR BYTE, ; pointer to buffer
 nLength:DWORD, ; size of buffer
 dwWriteCoord:COORD, ; first cell coordinates
 lpNumberOfCharsWritten:PTR DWORD ; output count
WriteColors Program
• Creates an array of characters and an array of 
attributes, one for each character
• Copies the attributes to the screen buffer
• Copies the characters to the same screen buffer cells 
as the attributes
• Sample output:
(starts in row 2, column 10)
View the source code
26
File Manipulation
• Win32 API Functions that create, read, and 
write to files:
• CreateFile
• ReadFile
• WriteFile
• SetFilePointer
27
28
CreateFile
• CreateFile either creates a new file or opens an 
existing file. If successful, it returns a handle to the 
open file; otherwise, it returns a special constant 
named INVALID_HANDLE_VALUE. 
• Prototype:
CreateFile PROTO, ; create new file
 pFilename:PTR BYTE, ; ptr to filename
 dwDesiredAccess:DWORD, ; access mode
 dwShareMode:DWORD, ; share mode
 lpSecurityAttributes:DWORD, ; ptr to security attribs
 dwCreationDisposition:DWORD, ; file creation options
 dwFlagsAndAttributes:DWORD, ; file attributes
 htemplate:DWORD ; handle to template file
29
CreateFile Examples (1 of 3)
INVOKE CreateFile,
ADDR filename, ; ptr to filename
GENERIC_READ, ; access mode
DO_NOT_SHARE, ; share mode
NULL, ; ptr to security attributes
OPEN_EXISTING, ; file creation options
FILE_ATTRIBUTE_NORMAL, ; file attributes
0 ; handle to template file
Opens an existing file for reading:
30
CreateFile Examples (2 of 3)
INVOKE CreateFile,
ADDR filename,
GENERIC_WRITE, ; access mode
DO_NOT_SHARE,
NULL,
OPEN_EXISTING,
FILE_ATTRIBUTE_NORMAL,
0
Opens an existing file for writing:
31
CreateFile Examples (3 of 3)
INVOKE CreateFile,
ADDR filename,
GENERIC_WRITE,
DO_NOT_SHARE,
NULL,
CREATE_ALWAYS, ; overwrite existing file
FILE_ATTRIBUTE_NORMAL,
0
Creates a new file with normal attributes, erasing any 
existing file by the same name:
32
ReadFile
• ReadFile reads text from an input file
• Prototype:
ReadFile PROTO,
hFile:HANDLE, ; handle to file
pBuffer:PTR BYTE, ; ptr to buffer
nNumberOfBytesToRead:DWORD, ; num bytes to read
lpNumberOfBytesRead:PTR DWORD, ; bytes actually read
lpOverlapped:PTR DWORD ; ptr to asynch info
33
WriteFile
• WriteFile writes data to a file, using an output handle. 
The handle can be the screen buffer handle, or it can 
be one assigned to a text file.
• Prototype:
WriteFile PROTO,
hFile:HANDLE, ; output handle
lpBuffer:PTR BYTE, ; pointer to buffer
nNumberOfBytesToWrite:DWORD, ; size of buffer
lpNumberOfBytesWritten:PTR DWORD, ; num bytes written
lpOverlapped:PTR DWORD ; ptr to asynch info
34
SetFilePointer
SetFilePointer moves the position pointer of an open file. 
You can use it to append data to a file, and to perform 
random-access record processing:
; Move to end of file:
INVOKE SetFilePointer,
 fileHandle,0,0,FILE_END
Example:
SetFilePointer PROTO,
 hFile:HANDLE, ; file handle
 lDistanceToMove:SDWORD, ; bytes to move pointer
 lpDistanceToMoveHigh:PTR SDWORD, ; ptr to bytes to move
 moveMethod:DWORD ; starting point
Time and Date Functions
• GetLocalTime, SetLocalTime
• GetTickCount, Sleep
• GetDateTime
• SYSTEMTIME Structure
• Creating a Stopwatch Timer
35
36
GetLocalTime, SetLocalTime
• GetLocalTime returns the date and current time of 
day, according to the system clock.
• SetLocalTime sets the system’s local date and time.
GetLocalTime PROTO,
 lpSystemTime:PTR SYSTEMTIME
SetLocalTime PROTO,
 lpSystemTime:PTR SYSTEMTIME
37
SYSTEMTIME Structure
• SYSTEMTIME is used by date and time-related 
Windows API functions:
SYSTEMTIME STRUCT
wYear WORD ? ; year (4 digits)
wMonth WORD ? ; month (1-12)
wDayOfWeek WORD ? ; day of week (0-6)
wDay WORD ? ; day (1-31)
wHour WORD ? ; hours (0-23)
wMinute WORD ? ; minutes (0-59)
wSecond WORD ? ; seconds (0-59)
wMilliseconds WORD ? ; milliseconds (0-999)
SYSTEMTIME ENDS
38
GetTickCount, Sleep
• GetTickCount function returns the number of 
milliseconds that have elapsed since the system was 
started.
• Sleep pauses the current program for a specified 
number of milliseconds.
GetTickCount PROTO ; return value in EAX
Sleep PROTO,
dwMilliseconds:DWORD
What's Next
• Win32 Console Programming
• Writing a Graphical Windows Application
• Dynamic Memory Allocation
• x86 Memory Management
39
Writing a Graphical Windows Application
• Required Files
• POINT, RECT Structures
• MSGStruct, WNDCLASS Structures
• MessageBox Function
• WinMain, WinProc Procedures
• ErrorHandler Procedure
• Message Loop & Processing Messages
• Program Listing
40
41
MessageBox Function
Displays text in a box that pops up and waits for the 
user to click on a button:
MessageBox PROTO,
hWnd:DWORD,
lpText:PTR BYTE,
lpCaption:PTR BYTE,
uType:DWORD
hWnd is a handle to the current window. 
lpText points to a null-terminated string that will appear inside the box. 
lpCaption points to a null-terminated string that will appear in the box’s 
caption bar. 
uType is an integer that describes both the dialog box’s icon (optional) 
and the buttons (required). 
42
MessageBox Example
.data
hMainWnd DWORD ?
QuestionText BYTE "Register this program now?",0 
QuestionTitle BYTE "Trial Period Has Expired",0
.code
INVOKE MessageBox, 
hMainWnd, 
ADDR QuestionText,
ADDR QuestionTitle, 
MB_OK + MB_ICONQUESTION
Displays a message box that shows a question, 
including an OK button and a question-mark icon:
Required Files
• make32.bat - Batch file specifically for building this 
program
• WinApp.asm - Program source code
• GraphWin.inc - Include file containing structures, 
constants, and function prototypes used by the 
program
• kernel32.lib - Same MS-Windows API library used 
earlier in this chapter
• user32.lib - Additional MS-Windows API functions
When linking the program, use /SUBSYSTEM:WINDOWS 
Not /SUBSYSTEM:CONSOLE
43
44
POINT and RECT Structures
• POINT - X, Y screen coordinates
• RECT - Holds the graphical coordinates of two 
opposing corners of a rectangle
POINT STRUCT
 ptX DWORD ?
 ptY DWORD ?
POINT ENDS
RECT STRUCT
 left DWORD ?
 top DWORD ?
 right DWORD ?
 bottom DWORD ?
RECT ENDS
45
MSGStruct Structure
MSGStruct - holds data for MS-Windows messages 
(usually passed by the system and received by your 
application):
MSGStruct STRUCT
 msgWnd DWORD ?
 msgMessage DWORD ?
 msgWparam DWORD ?
 msgLparam DWORD ?
 msgTime DWORD ?
 msgPt POINT <>
MSGStruct ENDS
46
WNDCLASS Structure (1 of 2)
Each window in a program belongs to a class, and each program 
defines a window class for its main window:
WNDCLASS STRUC
 style DWORD ? ; window style options
 lpfnWndProc DWORD ? ; WinProc function pointer
 cbClsExtra DWORD ? ; shared memory
 cbWndExtra DWORD ? ; number of extra bytes
 hInstance DWORD ? ; handle to current program
 hIcon DWORD ? ; handle to icon
 hCursor DWORD ? ; handle to cursor
 hbrBackground DWORD ? ; handle to background brush
 lpszMenuName DWORD ? ; pointer to menu name
 lpszClassName DWORD ? ; pointer to WinClass name
WNDCLASS ENDS
47
WNDCLASS Structure (2 of 2)
• style is a conglomerate (组合) of different style options, such as 
WS_CAPTION and WS_BORDER, that control the window’s 
appearance and behavior. 
• lpfnWndProc is a pointer to a function (in our program) that receives 
and processes event messages triggered by the user. 
• cbClsExtra refers to shared memory used by all windows belonging to 
the class. Can be null.
• cbWndExtra specifies the number of extra bytes to allocate following 
the window instance. 
• hInstance holds a handle to the current program instance. 
• hIcon and hCursor hold handles to icon and cursor resources for the 
current program. 
• hbrBackground holds a background (color) brush.
• lpszMenuName points to a menu string.
• lpszClassName points to a null-terminated string containing the 
window’s class name.
WinMain Procedure
Every Windows application needs a startup procedure, 
usually named WinMain, which is responsible for the 
following tasks:
• Get a handle to the current program
• Load the program’s icon and mouse cursor
• Register the program’s main window class and identify the 
procedure that will process event messages for the window
• Create the main window
• Show and update the main window
• Begin a loop that receives and dispatches messages
48
49
WinProc Procedure
• WinProc receives and processes all event messages 
relating to a window
• Some events are initiated by clicking and dragging the mouse, 
pressing keyboard keys, and so on 
• WinProc decodes each message, carries out 
application-oriented tasks related to the message
WinProc PROC,
hWnd:DWORD, ; handle to the window
localMsg:DWORD, ; message ID
wParam:DWORD, ; parameter 1 (varies)
lParam:DWORD ; parameter 2 (varies)
(Contents of wParam and lParam vary, depending on the message.)
Sample WinProc Messages
• In the example program from this chapter, the 
WinProc procedure handles three specific messages:
• WM_LBUTTONDOWN, generated when the user 
presses the left mouse button 
• WM_CREATE, indicates that the main window was just 
created 
• WM_CLOSE, indicates that the application’s main 
window is about to close
(many other messages are possible)
50
ErrorHandler Procedure
• The ErrorHandler procedure has several important 
tasks to perform:
• Call GetLastError to retrieve the system error number
• Call FormatMessage to retrieve the appropriate 
system-formatted error message string
• Call MessageBox to display a popup message box 
containing the error message string
• Call LocalFree to free the memory used by the error 
message string
(sample)
51
52
ErrorHandler Sample
INVOKE GetLastError ; Returns message ID in EAX
mov messageID,eax
; Get the corresponding message string.
INVOKE FormatMessage, FORMAT_MESSAGE_ALLOCATE_BUFFER + \
 FORMAT_MESSAGE_FROM_SYSTEM, NULL, messageID, NULL,
 ADDR pErrorMsg, NULL, NULL
; Display the error message.
INVOKE MessageBox, NULL, pErrorMsg, ADDR ErrorTitle,
 MB_ICONERROR + MB_OK
; Free the error message string.
INVOKE LocalFree, pErrorMsg
53
Message Loop
Message_Loop:
; Get next message from the queue.
INVOKE GetMessage, ADDR msg, NULL,NULL,NULL
; Quit if no more messages.
.IF eax == 0
 jmp Exit_Program
.ENDIF
; Relay the message to the program's WinProc.
INVOKE DispatchMessage, ADDR msg
jmp Message_Loop
In WinMain, the message loop receives and dispatches (relays) 
messages:
54
Processing Messages
WinProc PROC, hWnd:DWORD, localMsg:DWORD, 
wParam:DWORD, lParam:DWORD
mov eax, localMsg
.IF eax == WM_LBUTTONDOWN ; mouse button?
 INVOKE MessageBox, hWnd, ADDR PopupText,
 ADDR PopupTitle, MB_OK
 jmp WinProcExit
.ELSEIF eax == WM_CREATE ; create window?
 INVOKE MessageBox, hWnd, ADDR AppLoadMsgText,
 ADDR AppLoadMsgTitle, MB_OK
 jmp WinProcExit
(etc.)
WinProc receives each message and decides what to do with it:
• (WinApp.asm)
Program Listing
• View the program listing (WinApp.asm)
• Run the program
When linking the program, remember to replace
/SUBSYSTEM:CONSOLE 
with: /SUBSYSTEM:WINDOWS
55
What's Next
• Win32 Console Programming
• Writing a Graphical Windows Application
• Dynamic Memory Allocation
• IA-32 Memory Management
56
Dynamic Memory Allocation
• Reserving memory at runtime for objects
• aka heap allocation
• standard in high-level languages (C++, Java)
• Heap manager
• allocates large blocks of memory
• maintains free list of pointers to smaller blocks
• manages requests by programs for storage
57
Windows Heap-Related Functions
58
59
Sample Code
• Get a handle to the program's existing heap
or Create a handle to a private heap.
HEAP_START = 2000000 ; 2 MB
HEAP_MAX = 400000000 ; 400 MB
.data
hHeap HANDLE ?
.code
INVOKE GetProcessHeap
.IF eax == NULL ; cannot get handle
jmp quit
.ELSE
mov hHeap,eax ; handle is OK
.ENDIF
INVOKE HeapCreate, 0, HEAP_START, HEAP_MAX
60
Sample Code
• Allocate block of memory from existing heap:
.data
hHeap HANDLE ? ; heap handle
pArray DWORD ? ; pointer to array
.code
INVOKE HeapAlloc, hHeap, HEAP_ZERO_MEMORY, 1000
.IF eax == NULL
mWrite "HeapAlloc failed"
jmp quit
.ELSE
mov pArray,eax
.ENDIF
61
Sample Code
• Free a block of memory previously created by 
calling HeapAlloc:
.data
hHeap HANDLE ? ; heap handle
pArray DWORD ? ; pointer to array
.code
INVOKE HeapFree, 
hHeap, ; handle to heap
0, ; flags
pArray ; pointer to array
Summary (Chap 9)
• String primitives are optimized for efficiency
• Strings and arrays are essentially the same
• Keep code inside loops simple
• Use base-index operands with two-dimensional 
arrays
• Avoid the bubble sort for large arrays
• Use binary search for large sequentially ordered 
arrays
62
Summary (Chap 10)
• Use a structure to define complex types
• contains fields of different types
• Macro – named block of statements
• substituted by the assembler preprocessor
• Conditional assembly directives
• IF, IFNB, IFIDNI, ...
• Operators: &, %, <>, !
• Repeat block directives (assembly time)
• WHILE, REPEAT, FOR, FORC
63
Summary (Chap 11)
• 32-bit console programs 
• read from the keyboard and write plain text to the 
console window using Win32 API functions
• Important functions
• ReadConsole, WriteConsole, GetStdHandle, ReadFile, 
WriteFile, CreateFile, CloseHandle, SetFilePointer
• Dynamic memory allocation
• HeapAlloc, HeapFree
64
Summary
65
Homework
• Reading Chap 9.2 - 11
• Exercises
66
本次课程是
线下教学
请现场的同学们：
打开雨课堂，点击页面右下角喇叭
按钮调至静音状态
CHAPTER 14: 
16-BIT MS-DOS PROGRAMMING
2
Chapter Overview
• MS-DOS and the IBM-PC
• MS-DOS Function Calls (INT 21h)
• Standard MS-DOS File I/O Services
3
MS-DOS and the IBM-PC
• Real-Address Mode
• MS-DOS Memory Organization
• MS-DOS Memory Map
• Redirecting Input-Output
• Software Interrupts
• INT Instruction
• Interrupt Vectoring Process
• Common Interrupts
4
Real-Address Mode
• Real-address mode (16-bit mode) programs have 
the following characteristics:
• Max 1 megabyte addressable RAM
• Offsets are 16 bits
• No memory boundary protection
• Single tasking
• IBM PC-DOS: first Real-address OS for IBM-PC
• Has roots in Gary Kildall's highly successful Digital 
Research CP/M
• Later renamed to MS-DOS, owned by Microsoft
5
MS-DOS Memory Organization
• Interrupt Vector Table
• BIOS & DOS data
• Software BIOS
• MS-DOS kernel
• Resident command processor
• Transient programs
• Video graphics & text
• Reserved (device controllers)
• ROM BIOS
6
MS-DOS Memory Map
Address
FFFFF
ROM BIOS
F0000
Reserved
C0000
Video Text & Graphics
B8000
VRAM
Video Graphics
A0000
Transient Command Processor
Transient Program Area
(available for application programs)
Resident Command Processor 640K RAM
DOS Kernel, Device Drivers
Software BIOS
BIOS & DOS Data
00400
Interrupt Vector Table
00000
7
8
Redirecting Input-Output (1 of 2)
• Input-output devices and files are interchangeable
• Three primary types of I/O:
• Standard input (console, keyboard)
• Standard output (console, display)
• Standard error (console, display)
• Symbols borrowed from Unix:
• < symbol: get input from
• > symbol: send output to
• | symbol: pipe output from one process to another
• Predefined device names:
• PRN, CON, LPT1, LPT2, NUL, COM1, COM2
9
Redirecting Input-Output (2 of 2)
• Standard input, standard output can both be redirected
• Standard error cannot be redirected
• Suppose we have created a program named 
myprog.exe that reads from standard input and writes 
to standard output. Following are MS-DOS commands 
that demonstrate various types of redirection:
myprog < infile.txt
myprog > outfile.txt
myprog < infile.txt > outfile.txt
INT Instruction
• The INT instruction executes a software interrupt.
• The code that handles the interrupt is called an 
interrupt handler.
• Syntax:
INT number
(number = 0..FFh)
The Interrupt Vector Table (IVT) holds a 32-bit segment￾offset address for each possible interrupt handler.
Interrupt Service Routine (ISR) is another name for interrupt 
handler.
10
11
Interrupt Vectoring Process
mov...
int 10h
add...
F000:F065 3069 F000:AB62
 F000:F065
 F066
 F067
 F068
 .
 .
 sti
 cld
 push es
 .
 .
 IRET
1 2
3
Calling program
(entry for INT 10)
Interrupt Vector Table
Interrupt Handler
4
Common Interrupts
• INT 10h Video Services
• INT 16h Keyboard Services
• INT 17h Printer Services
• INT 1Ah Time of Day
• INT 1Ch User Timer Interrupt
• INT 21h MS-DOS Services
12
What's Next
• MS-DOS and the IBM-PC
• MS-DOS Function Calls (INT 21h)
• Standard MS-DOS File I/O Services
13
MS-DOS Function Calls (INT 21h)
• ASCII Control Characters
• Selected Output Functions
• Selected Input Functions
• Example: String Encryption
• Date/Time Functions
14
15
INT 21h Function 4Ch: Terminate Process
• Ends the current process (program), returns an 
optional 8-bit return code to the calling process.
• A return code of 0 usually indicates successful 
completion.
mov ah,4Ch ; terminate process
mov al,0 ; return code
int 21h
; Same as:
.EXIT 0
Selected Output Functions
• ASCII control characters
• 02h, 06h - Write character to standard output
• 05h - Write character to default printer
• 09h - Write string to standard output
• 40h - Write string to file or device
16
ASCII Control Characters
Many INT 21h functions act upon the following 
control characters:
• 08h - Backspace (moves one column to the left)
• 09h - Horizontal tab (skips forward n columns)
• 0Ah - Line feed (moves to next output line)
• 0Ch - Form feed (moves to next printer page)
• 0Dh - Carriage return (moves to leftmost output column)
• 1Bh - Escape character
Q: What is the meaning of CRLF?
17
18
INT 21h Functions 02h and 06h: 
Write Character to Standard Output
Write the letter 'A' to standard output:
mov ah,02h
mov dl, 'A'
int 21h
Write a backspace to standard output:
mov ah,06h
mov dl,08h
int 21h
or: mov ah,2
INT 21h Function 05h: 
Write Character to Default Printer
Write the letter 'A':
mov ah,05h
mov dl,65
int 21h
Write a horizontal tab:
mov ah,05h
mov dl,09h
int 21h
19
INT 21h Function 09h: 
Write String to Standard Output
• The string must be terminated by a '$' character.
• DS must point to the string's segment, and DX 
must contain the string's offset:
.data
string BYTE "This is a string$"
.code
mov ah,9
mov dx,OFFSET string
int 21h
20
INT 21h Function 40h: 
Write String to File or Device
Input: BX = file or device handle (console = 1), CX = 
number of bytes to write, DS:DX = address of array
.data
message BYTE "Writing a string to the console"
bytesWritten WORD ?
.code
mov ah,40h
mov bx,1
mov cx,LENGTHOF message
mov dx,OFFSET message
int 21h
mov bytesWritten,ax
21
Selected Input Functions
• 01h, 06h - Read character from standard input
• 0Ah - Read array of buffered characters from 
standard input
• 0Bh - Get status of the standard input buffer
• 3Fh - Read from file or device
22
INT 21h Function 01h: 
Read single character from standard input
• Echoes the input character
• Waits for input if the buffer is empty
• Checks for Ctrl-Break (^C)
• Acts on control codes such as horizontal Tab
.data
char BYTE ?
.code
mov ah,01h
int 21h
mov char,al
23
24
INT 21h Function 06h: 
Read character from standard input without waiting
.data
char BYTE ?
.code
L1: mov ah,06h ; keyboard input
mov dl,0FFh ; don't wait for input
int 21h
jz L1 ; no character? repeat loop
mov char,al ; character pressed: save it
call DumpRegs ; display registers
• Does not echo the input character
• Does not wait for input (use the Zero flag to check for 
an input character)
• Example: repeats loop until a character is pressed.
25
INT 21h Function 0Ah: 
Read buffered array from standard input (1 of 2)
count = 80
KEYBOARD STRUCT
maxInput BYTE count ; max chars to input
inputCount BYTE ? ; actual input count
buffer BYTE count DUP(?) ; holds input chars
KEYBOARD ENDS
• Requires a predefined structure to be set up that 
describes the maximum input size and holds the 
input characters. 
• Example:
26
INT 21h Function 0Ah (2 of 2)
.data
kybdData KEYBOARD <>
.code
mov ah,0Ah
mov dx,OFFSET kybdData
int 21h
Executing the interrupt:
27
INT 21h Function 0Bh: 
Get status of standard input buffer
L1: mov ah,0Bh ; get buffer status
int 21h
cmp al,0 ; buffer empty?
je L1 ; yes: loop again
mov ah,1 ; no: input the key
int 21h
mov char,al ; and save it
• Can be interrupted by Ctrl-Break (^C)
• Example: loop until a key is pressed. Save the 
key in a variable:
28
Example: String Encryption
Reads from standard input, encrypts each byte, writes to 
standard output.
XORVAL = 239 ; any value between 0-255
.code
main PROC
mov ax,@data
mov ds,ax
L1: mov ah,6 ; direct console input
mov dl,0FFh ; don't wait for character
int 21h ; AL = character
jz L2 ; quit if ZF = 1 (EOF)
xor al,XORVAL
mov ah,6 ; write to output
mov dl,al
int 21h
jmp L1 ; repeat the loop
L2: exit
29
INT 21h Function 3Fh: 
Read from file or device
.data
inputBuffer BYTE 127 dup(0)
bytesRead WORD ?
.code
mov ah,3Fh
mov bx,0 ; keyboard handle
mov cx,127 ; max bytes to read
mov dx,OFFSET inputBuffer ; target location
int 21h
mov bytesRead,ax ; save character count
• Reads a block of bytes.
• Can be interrupted by Ctrl-Break (^C)
• Example: Read string from keyboard:
Date/Time Functions
• 2Ah - Get system date
• 2Bh - Set system date *
• 2Ch - Get system time
• 2Dh - Set system time *
* may be restricted by your user profile if running a console 
window under Windows NT, 2000, and XP.
30
INT 21h Function 2Ah: 
Get system date
• Returns year in CX, month in DH, day in DL, and 
day of week in AL
mov ah,2Ah
int 21h
mov year,cx
mov month,dh
mov day,dl
mov dayOfWeek,al
31
INT 21h Function 2Bh: 
Set system date
• Sets the system date. AL = 0 if the function was 
successful in modifying the date.
mov ah,2Bh
mov cx,year
mov dh,month
mov dl,day
int 21h
cmp al,0
jne failed
32
INT 21h Function 2Ch: 
Get system time
• Returns hours (0-23) in CH, minutes (0-59) in CL, 
and seconds (0-59) in DH, and hundredths (0-99) 
in DL.
mov ah,2Ch
int 21h
mov hours,ch
mov minutes,cl
mov seconds,dh
33
INT 21h Function 2Dh: 
Set system time
• Sets the system date. AL = 0 if the function was 
successful in modifying the time.
mov ah,2Dh
mov ch,hours
mov cl,minutes
mov dh,seconds
int 21h
cmp al,0
jne failed
34
Example: Displaying the Date and Time
• Displays the system date and time, using INT 21h 
Functions 2Ah and 2Ch.
• Demonstrates simple date formatting
• View the source code
• Sample output:
Date: 12-8-2001, Time: 23:01:23
ToDo: write a procedure named ShowDate that displays any date 
in mm-dd-yyyy format.
35
What's Next
• MS-DOS and the IBM-PC
• MS-DOS Function Calls (INT 21h)
• Standard MS-DOS File I/O Services
36
Standard MS-DOS File I/O Services
• 716Ch - Create or open file
• 3Eh - Close file handle
• 42h - Move file pointer
• 5706h - Get file creation date and time
• Selected Irvine16 Library Procedures
• Example: Read and Copy a Text File
• Reading the MS-DOS Command Tail
• Example: Creating a Binary File
37
38
INT 21h Function 716Ch: 
Create or open file
• AX = 716Ch
• BX = access mode (0 = read, 1 = write, 2 = read/write)
• CX = attributes (0 = normal, 1 = read only, 2 = hidden, 
 3 = system, 8 = volume ID, 20h = archive)
• DX = action (1 = open, 2 = truncate, 10h = create)
• DS:SI = segment/offset of filename
• DI = alias hint (optional)
39
Example: Create a New File
mov ax,716Ch ; extended open/create
mov bx,2 ; read-write
mov cx,0 ; normal attribute
mov dx,10h + 02h ; action: create + truncate
mov si,OFFSET Filename
int 21h
jc failed
mov handle,ax ; file handle
mov actionTaken,cx ; action taken to open file
Example: Open an Existing File
mov ax,716Ch ; extended open/create
mov bx,0 ; read-only
mov cx,0 ; normal attribute
mov dx,1 ; open existing file
mov si,OFFSET Filename
int 21h
jc failed
mov handle,ax ; file handle
mov actionTaken,cx ; action taken to open file
40
41
INT 21h Function 3Eh: 
Close file handle
.data
filehandle WORD ?
.code
mov ah,3Eh
mov bx,filehandle 
int 21h
jc failed
• Use the same file handle that was returned by 
INT 21h when the file was opened.
• Example:
42
INT 21h Function 42h: 
Move file pointer
mov ah,42h
mov al,0 ; offset from beginning
mov bx,handle
mov cx,offsetHi
mov dx,offsetLo
int 21h
AL indicates how the pointer's offset is calculated:
0: Offset from the beginning of the file
1: Offset from the current pointer location 
2: Offset from the end of the file
Permits random access to a file (text or binary).
43
INT 21h Function 5706h: 
Get file creation date and time
mov ax,5706h
mov bx,handle ; handle of open file
int 21h
jc error
mov date,dx
mov time,cx
mov milliseconds,si
• Obtains the date and time when a file was created 
(not necessarily the same date and time when the 
file was last modified or accessed.)
Selected Irvine16 Library Procedures
• 16-Bit ReadString procedure
• 16-Bit WriteString procedure
44
CHAPTER 16: 
BIOS-LEVEL PROGRAMMING
1
Chapter Overview
• Introduction
• Keyboard Input with INT 16h
• VIDEO Programming with INT 10h
• Drawing Graphics Using INT 10h
• Memory-Mapped Graphics
• Mouse Programming
2
PC-BIOS
• The BIOS (Basic Input-Output System) provides low￾level hardware drivers for the operating system.
• accessible to 16-bit applications
• written in assembly language, of course
• source code published by IBM in early 1980's
• Advantages over MS-DOS:
• permits graphics and color programming
• faster I/O speeds
• read mouse, serial port, parallel port
• low-level disk access
3
BIOS Data Area
• Fixed-location data area at address 00400h
• this area is also used by MS-DOS
• this area is accessible under Windows 98 & Windows 
Me, but not under Windows NT, 2000, or XP.
• Contents:
• Serial and parallel port addresses
• Hardware list, memory size
• Keyboard status flags, keyboard buffer pointers, 
keyboard buffer data
• Video hardware configuration
• Timer data
4
What's Next
• Introduction
• Keyboard Input with INT 16h
• VIDEO Programming with INT 10h
• Drawing Graphics Using INT 10h
• Memory-Mapped Graphics
• Mouse Programming
5
Keyboard Input with INT 16h
• How the Keyboard Works
• INT 16h Functions
6
7
How the Keyboard Works
• Keystroke sends a scan code to the keyboard serial 
input port
• Interrupt triggered: INT 9h service routine executes
• Scan code and ASCII code inserted into keyboard 
typeahead buffer
Keyboard
INT 9h handler
INT 16h handler INT 21h handler
typeahead buffer
input port
sc
sc
sc, ac
sc, ac ac
sc = scan code
ac = ASCII code
Keyboard Flags
16-bits, located at 0040:0017h - 0018h.
8
INT 16h Functions
• Provide low-level access to the keyboard, more so 
than MS-DOS. 
• Input-output cannot be redirected at the command 
prompt.
• Function number is always in the AH register
• Important functions:
• set typematic rate
• push key into buffer
• wait for key
• check keyboard buffer
• get keyboard flags
9
Function 10h: Wait for Key
If a key is waiting in the buffer, the function returns it 
immediately. If no key is waiting, the program pauses 
(blocks), waiting for user input.
.data
scanCode BYTE ?
ASCIICode BYTE ?
.code
mov ah,10h
int 16h
mov scanCode,ah
mov ASCIICode,al
10
Function 12h: Get Keyboard Flags
Retrieves a copy of the keyboard status flags from the 
BIOS data area.
.data
keyFlags WORD ?
.code
mov ah,12h
int 16h
mov keyFlags,ax
11
12
Clearing the Keyboard Buffer
L1: mov ah,11h ; check keyboard buffer
int 16h ; any key pressed?
jz noKey ; no: exit now
mov ah,10h ; yes: remove from buffer
int 16h
cmp ah,scanCode ; was it the exit key? ESC_key=1
je quit ; yes: exit now (ZF=1)
jmp L1 ; no: check buffer again
noKey: ; no key pressed
or al,1 ; clear zero flag
quit:
Function 11h clears the Zero flag if a key is waiting in the 
keyboard typeahead buffer.
What's Next
• Introduction
• Keyboard Input with INT 16h
• VIDEO Programming with INT 10h
• Drawing Graphics Using INT 10h
• Memory-Mapped Graphics
• Mouse Programming
13
VIDEO Programming with INT 10h
• Basic Background
• Controlling the Color
• INT 10h Video Functions
14
Video Modes
• Graphics video modes
• draw pixel (像素) by pixel
• multiple colors
• Text video modes
• character output, using hardware or software-based 
font table
• mode 3 (color text) is the default
• default range of 80 columns by 25 rows.
• color attribute byte contains foreground and 
background colors
15
Three Levels of Video Access
• MS-DOS function calls
• slow, but they work on any MS-DOS machine
• I/O can be redirected
• BIOS function calls
• medium-fast, work on nearly all MS-DOS-based 
machines
• I/O cannot be redirected
• Direct memory-mapped video
• fast – works only on 100% IBM-compatible computers
• cannot be redirected
• does not work under Windows NT, 2000, or XP
16
Controlling the Color
• Mix primary colors: red, green, blue
• called subtractive mixing
• add the intensity (亮度) bit for 4th channel
• Examples:
• red + green + blue = light gray (0111)
• intensity + red + green + blue = white (1111)
• green + blue = cyan (0011)
• red + blue = magenta (0101)
• Attribute byte:
• 4 MSB bits = background
• 4 LSB bits = foreground
• Color constants defined in files
17
INT 10h Video Functions
• AH register contains the function number
• 00h: Set video mode
• 01h: Set cursor lines
• 02h: Set cursor position
• 03h: Get cursor position and size
• 06h: Scroll window up
• 07h: Scroll window down 
• 08h: Read character and attribute
18
19
INT 10h Video Functions (cont)
• 09h: Write character and attribute
• 0Ah: Write character
• 10h (AL = 03h): Toggle blinking/intensity (闪烁/亮
度)bit
• 0Fh: Get video mode
• 13h: Write string in teletype mode
20
Displaying a Color String
Write one character and attribute:
mov si,OFFSET string
. . .
mov ah,9 ; write character/attribute
mov al,[si] ; character to display
mov bh,0 ; video page 0
mov bl,color ; attribute
or bl,10000000b ; set blink/intensity bit
mov cx,1 ; display it one time
int 10h
What's Next
• Introduction
• Keyboard Input with INT 16h
• VIDEO Programming with INT 10h
• Drawing Graphics Using INT 10h
• Memory-Mapped Graphics
• Mouse Programming
21
Drawing Graphics Using INT 10h
• INT 10h Pixel-Related Functions
• DrawLine Program
• Cartesian Coordinates Program
• Converting Cartesian Coordinates to Screen 
Coordinates
22
INT 10h Pixel-Related Functions
• Slow performance
• Easy to program
• 0Ch: Write graphics pixel
• 0Dh: Read graphics pixel
23
24
DrawLine Program
• Draws a straight line, using INT 10h function calls
• Saves and restores current video mode
• Excerpt from the DrawLine program (DrawLine.asm):
mov ah,0Ch ; write pixel
mov al,color ; pixel color
mov bh,0 ; video page 0
mov cx,currentX
mov dx,currentY
int 10h
Cartesian Coordinates Program
• Draws the X and Y axes of a Cartesian coordinate 
system
• Uses video mode 12 (640 x 480, 16 colors)
• Name: Pixel2.asm
• Important procedures:
• DrawHorizLine
• DrawVerticalLine
25
Converting Cartesian Coordinates to 
Screen Coordinates
• Screen coordinates place the origin (0,0) at the 
upper-left corner of the screen
• Graphing functions often need to display negative 
values
• move origin point to the middle of the screen
• Let sOrigX and sOrigY be the screen coordinates of 
the origin of the Cartesian coordinate system. 
• For Cartesian coordinates X, Y screen 
coordinates sx and sy are calculated as:
• sx = (sOrigX + X)
• sy = (sOrigY – Y)
26
What's Next
• Introduction
• Keyboard Input with INT 16h
• VIDEO Programming with INT 10h
• Drawing Graphics Using INT 10h
• Memory-Mapped Graphics
• Mouse Programming
27
Memory-Mapped Graphics
• Binary values are written to video RAM
• video adapter must use standard address
• Very fast performance
• no BIOS or DOS routines to get in the way
28
Mode 13h: 320 X 200, 256 Colors
• Mode 13h graphics (320 X 200, 256 colors)
• Fairly easy to program
• read and write video adapter via IN and OUT 
instructions
• pixel-mapping scheme (1 byte per pixel)
29
30
Mode 13h Details
• OUT Instruction
• 16-bit port address assigned to DX register
• output value in AL, AX, or EAX
• Example:
mov dx,3c8h ; port address
mov al,20h ; value to be sent
out dx,al ; send to the port
• Color Indexes
• color integer value is an index into a table of colors 
called a palette (调色板)
Color Indexes in Mode 13h
31
RGB Colors
Additive mixing of light (red, green, blue). Intensities vary 
from 0 to 255. 
Examples:
32
What's Next
• Introduction
• Keyboard Input with INT 16h
• VIDEO Programming with INT 10h
• Drawing Graphics Using INT 10h
• Memory-Mapped Graphics
• Mouse Programming
33
Mouse Programming
• MS-DOS functions for reading the mouse
• Mickey – unit of measurement (200th of an inch)
• mickeys-to-pixels ratio (8 x 16) is variable
• INT 33h functions
• Mouse Tracking Program Example
34
35
Reset Mouse and Get Status
• INT 33h, AX = 0
• Example:
mov ax,0
int 33h
cmp ax,0 ; AX = FFFFh or 0
je MouseNotAvailable
mov numberOfButtons,bx
36
Show/Hide Mouse
• INT 33h, AX = 1 (show), AX = 2 (hide)
• Example:
mov ax,1 ; show
int 33h
mov ax,2 ; hide
int 33h
37
Get Mouse Position & Status
• INT 33h, AX = 3
• Example:
mov ax,3
int 33h
test bx,1
jne Left_Button_Down
test bx,2
jne Right_Button_Down
test bx,4
jne Center_Button_Down
mov xCoord,cx ; X-position
mov yCoord,dx ; Y-position
38
Set Mouse Position
• INT 33h, AX = 4
• Example:
mov ax,4
mov cx,200 ; X-position
mov dx,100 ; Y-position
int 33h
39
Get Button Press Information
• INT 33h, AX = 5
• Example:
mov ax,5
mov bx,0 ; button ID
int 33h
test ax,1 ; left button down?
jz skip ; no - skip
mov X_coord,cx ; yes: save coordinates
mov Y_coord,dx
Other Mouse Functions
• AX = 6: Get Button Release Information
• AX = 7: Set Horizontal Limits
• AX = 8: Set Vertical Limits
40
Mouse Tracking Program
• Tracks the movement of the text mouse cursor
• X and Y coordinates are continually updated in the 
lower-right corner of the screen
• When the user presses the left button, the mouse’s 
position is displayed in the lower left corner of the 
screen
• Source code
41
CHAPTER 17: 
EXPERT MS-DOS PROGRAMMING
1
Chapter Overview
• Defining Segments
• Runtime Program Structure
• Interrupt Handling
• Hardware Control Using I/O Ports
2
Defining Segments
• Simplified Segment Directives
• Explicit Segment Definitions
• Segment Overrides
• Combining Segments
3
Simplified Segment Directives
• .MODEL – program memory model
• .CODE – code segment
• .CONST – define constants
• .DATA – near data segment
• .DATA? – uninitialized data
• .FARDATA – far data segment
• .FARDATA? – far uninitialize data
• .STACK – stack segment
• .STARTUP – initialize DS and ES
• .EXIT – halt program
4
Memory Models
5
NEAR and FAR Segments
• NEAR segment
• requires only a 16-bit offset
• faster execution than FAR
• FAR segment
• 32-bit offset: requires setting both segment and 
offset values
• slower execution than NEAR
6
.MODEL Directive
• The .MODEL directive determines the names and 
grouping of segments
• .model tiny
• code and data belong to same segment (NEAR)
• .com file extension
• .model small
• both code and data are NEAR
• data and stack grouped into DGROUP
• .model medium
• code is FAR, data is NEAR
7
.MODEL Directive
• .model compact
• code is NEAR, data is FAR
• .model huge & .model large
• both code and data are FAR
• .model flat
• both code and data are 32-bit NEAR
8
.MODEL Directive
• Syntax:
.MODEL type, language, stackdistance
• Language can be:
• C, BASIC, FORTRAN, PASCAL, SYSCALL, or 
STDCALL (details in Chapters 8 and 12).
• Stackdistance can be:
• NEARSTACK: (default) places the stack segment in 
the group DGROUP along with the data segment
• FARSTACK: stack and data are not grouped together
9
.STACK Directive
• Syntax:
.STACK [stacksize]
• Stacksize specifies size of stack, in bytes
• default is 1024
• Example: set to 2048 bytes:
• .stack 2048
10
.CODE Directive
• Syntax:
.CODE [segname]
• optional segname overrides the default name
• Small, Compact memory models
• NEAR code segment
• segment is named _TEXT
• Medium, Large, Huge memory models
• FAR code segment
• segment is named modulename_TEXT
Whenever the CPU executes a FAR call or jump, it loads CS with 
the new segment address. 
11
Near Data Segments
• .DATA directive creates a Near segment
• Up to 64K in Real-address mode
• 16-bit offsets are used for all code and data
• automatically creates segment named DGROUP
• can be used in any memory model
• Other types of data:
• .DATA? (uninitialized data)
• .CONST (constant data)
12
13
Far Data Segments
• .FARDATA 
• creates a FAR_DATA segment
• .FARDATA?
• creates a FAR_BSS segment
• Code to access data in a far segment:
.FARDATA
myVar
.CODE
mov ax,SEG myVar
mov ds,ax
The SEG operator returns 
the segment value of a 
label. Similar to @data.
Explicit Segment Definitions
• Use them when you cannot or do not want to use 
simplified segment directives
• All segment attributes must be specified
• The ASSUME directive is required
14
15
SEGMENT Directive
• name identifies the segment; it can either be unique or the 
name of an existing segment.
• align can be BYTE, WORD, DWORD, PARA, or PAGE.
• combine can be PRIVATE, PUBLIC, STACK, COMMON, 
MEMORY, or AT address.
• class is an identifier used when identifying a particular type of 
segment such as CODE or STACK.
name SEGMENT [align] [combine] ['class']
statements
name ENDS
Syntax:
16
Segment Example
ExtraData SEGMENT PARA PUBLIC 'DATA'
var1 BYTE 1
var2 WORD 2
ExtraData ENDS
• name: ExtraData
• paragraph align type (starts on 16-byte boundary)
• public combine type: combine with all other public 
segments having the same name
• 'DATA' class: 'DATA' (load into memory along with other 
segments whose class is 'DATA')
ASSUME Directive
• Tells the assembler how to calculate the offsets 
of labels
• Associates a segment register with a segment 
name
Syntax:
ASSUME segreg:segname [,segreg:segname] ...
Examples:
ASSUME cs:myCode, ds:Data, ss:myStack
ASSUME es:ExtraData
17
18
Multiple Data Segments (1 of 2)
cseg SEGMENT 'CODE'
ASSUME cs:cseg, ds:data1, es:data2, ss:mystack
main PROC
mov ax,data1 ; DS points to data1
mov ds,ax
mov ax,SEG val2 ; ES points to data2
mov es,ax
mov ax,val1 ; data1 segment assumed
mov bx,val2 ; data2 segment assumed
mov ax,4C00h ; (same as .exit)
int 21h
main ENDP
cseg ENDS
19
Multiple Data Segments (2 of 2)
data1 SEGMENT 'DATA'
val1 WORD 1001h
data1 ENDS
data2 SEGMENT 'DATA'
val2 WORD 1002h
data2 ENDS
mystack SEGMENT PARA STACK 'STACK'
BYTE 100h DUP('S')
mystack ENDS
END main
Combining Segments
• Segments can be merged into a single segment by 
the linker, if . . .
• their names are the same, 
• and they both have combine type PUBLIC, 
• . . . even when they appear in different source code 
modules
• Example:
• cseg SEGMENT PUBLIC 'CODE'
20
What's Next
• Defining Segments
• Runtime Program Structure
• Interrupt Handling
• Hardware Control Using I/O Ports
21
Interrupt Handling
• Overview
• Hardware Interrupts
• Interrupt Control Instructions
• Writing a Custom Interrupt Handler
• Terminate and Stay Resident Programs
22
Overview
• Interrupt handler (interrrupt service routine) –
performs common I/O tasks
• can be called as functions
• can be activated by hardware events
• Examples:
• video output handler
• critical error handler
• keyboard handler
• divide by zero handler
• Ctrl-Break handler
• serial port I/O
23
Interrupt Vector Table
• Each entry contains a 32-bit segment/offset address 
that points to an interrupt service routine
• Offset = interruptNumber * 4 
• The following are only examples:
24
Hardware Interrupts
• Generated by the Intel 8259 Programmable Interrupt 
Controller (PIC)
• in response to a hardware signal
• Interrupt Request Levels (IRQ, 中断请求优先级)
• priority-based interrupt scheduler
• brokers simultaneous interrupt requests
• prevents low-priority interrupt from interrupting a high￾priority interrupt
25
26
Common IRQ Assignments
IRQ
0 System timer
1 Keyboard
2 Programmable Interrupt Controller
3 COM2 (serial)
4 COM1 (serial)
5 LPT2 (printer)
6 Floppy disk controller
7 LPT1 (printer)
27
Common IRQ Assignments
8 CMOS real-time clock
9 modem, video, network, sound, and USB 
controllers
10 (available)
11 (available)
12 mouse
13 Math coprocessor
14 Hard disk controller
15 (available)
Interrupt Control Instructions
• STI – set interrupt flag
• enables external interrupts
• always executed at beginning of an interrupt handler
• CLI – clear interrupt flag
• disables external interrupts
• used before critical code sections that cannot be 
interrupted
• suspends the system timer
28
Writing a Custom Interrupt Handler
• Motivations
• Change the behavior of an existing handler
• Fix a bug in an existing handler
• Improve system security by disabling certain keyboard 
commands
• What's Involved
• Write a new handler
• Load it into memory
• Replace entry in interrupt vector table
• Chain to existing interrupt hander (usually)
29
30
Get Interrupt Vector
• INT 21h Function 35h – Get interrupt vector
• returns segment-offset addr of handler in ES:BX
.data
int9Save LABEL WORD
DWORD ? ; store old INT 9 address here
.code
mov ah,35h ; get interrupt vector
mov al,9 ; for INT 9
int 21h ; call MS-DOS
mov int9Save,BX ; store the offset
mov [int9Save+2],ES ; store the segment
31
Set Interrupt Vector
• INT 21h Function 25h – Set interrupt vector
• installs new interrupt handler, pointed to by DS:DX
mov ax,SEG kybd_rtn ; keyboard handler
mov ds,ax ; segment
mov dx,OFFSET kybd_rtn ; offset
mov ah,25h ; set Interrupt vector
mov al,9h ; for INT 9h
int 21h
.
.
kybd_rtn PROC ; (new handler begins here)
See the CtrlBrk.asm program.
32
Keyboard Processing Steps
1. Key pressed, byte sent by hardware to keyboard 
port
2. 8259 controller interrupts the CPU, passing it the 
interrupt number
3. CPU looks up interrupt vector table entry 9h, 
branches to the address found there
10B2:0020
(our program) (Bios INT 9
service routine)
.
.
.
IRET
.
.
.
jmp 0DAD:2BAD
Interrupt
Vector Table
(INT 9)
10B2:0020 0DAD:2BAD
33
Keyboard Processing Steps
4. Our handler executes, intercepting the byte sent by 
the keyboard
5. Our handler jumps to the regular INT 9 handler
6. The INT 9h handler finishes and returns
7. System continues normal processing
10B2:0020
(our program) (Bios INT 9
service routine)
.
.
.
IRET
.
.
.
jmp 0DAD:2BAD
Interrupt
Vector Table
(INT 9)
10B2:0020 0DAD:2BAD
Terminate and Stay Resident Programs
• (TSR): Installed in memory, stays there until removed
• by a removal program, or by rebooting
• Keyboard example
• replace the INT 9 vector so it points to our own handler
• check, or filter certain keystroke combinations, using 
our handler
• forward-chain to the existing INT 9 handler to do 
normal keyboard processing
34
What's Next
• Defining Segments
• Runtime Program Structure
• Interrupt Handling
• Hardware Control Using I/O 
Ports
35
Hardware Control Using I/O Ports
• Two types of hardware I/O
• memory mapped
• program and hardware device share the same memory 
address, as if it were a variable
• port based
• data written to port using the OUT instruction
• data read from port using the IN instruction
36
Input-Ouput Ports
• ports numbered from 0 to FFFFh
• keyboard controller chip sends 8-bit scan code to port 
60h
• triggers a hardware interrupt 9
• IN and OUT instructions:
IN accumulator, port
OUT port, accumulator
• accumulator is AL, AX, or EAX
• port is a constant between 0 and FFh, or a value in DX 
between 0 and FFFFh
37
Summary (Chap 14)
• MS-DOS applications
• 16-bit segments, segmented addressing, running in real￾address mode
• complete access to memory and hardware
• Software interrupts
• processed by interrupt handlers
• INT (call to interrupt procedure) instruction
• pushes flags & return address on the stack
• uses interrupt vector table to find handler
• Program Segment Prefix (PSP)
• BIOS Services (INT 10h, INT 16h, INT 17h, ...)
• MS-DOS Services (INT 21h) 
38
Summary (Chap 16)
• Working at the BIOS level gives you a high level of 
control over hardware
• Use INT 16h for keyboard control
• Use INT 10h for video text
• Use memory-mapped I/O for graphics
• Use INT 33h for the mouse
39
Summary (Chap 17)
• Explicit segment definitions used often in custom 
code libraries
• Directives: SEGMENT, ENDS, ASSUME
• Interrupt handlers, interrupt vector table
• Hardware interrupt, 8259 Programmable Interrupt 
Controller, interrupt flag
• Terminate and Stay Resident (TSR)
• Memory-mapped and port-based I/O
40
Summary
41
Summary
42
Homework
• Reading Chap 14, 16, 17
• Exercises
Thanks!
43
THSS 44100593 2024 / 6A-216
Review of 44100593
THSS 44100593 2024 / 6A-216
45
Scores
• 课堂展示 5
• 小作业 25
• 大作业 30
• 考试 40
• 关于题型
• 关于考试内容
• 关于平时作业
THSS 44100593 2024 / 6A-216
46
Review
• What
• Why
• Course Info.
• PL
• History
• Contents
• Formal Lang.
• Grammar (RE, RG, CFG)
• 二义性
• 句型分析
• 文法化简&推断
• NFA & DFA
• From a RE to a DFA
THSS 44100593 2024 / 6A-216
47
Review
• Lexical Analyzer
• Relating NFAs/DFAs /Conversion to Lexical 
Analysis
• LEX - A Lexical Analyzer Generator
• ANTLR
• 语法分析的基本思想: 带回溯的自顶向下分析, 预
测分析
• LL(1)文法: First, Follow; 递归下降LL(1)分析, 
表驱动LL(1)分析
• 文法变换: 左递归, 左公因子
THSS 44100593 2024 / 6A-216
48
Review
• 预测分析中的错误处理
• 自底向上分析思想
• 移进—规约技术:句柄
• LR分析: 不带符号栈的LR分析模型
• 拓广文法, LR(0)自动机,文法的活前缀, LR分析
算法
• SLR(1) 分析: SLR(1) 分析表, SLR(1) 文法
• LR(1) 分析: LR(1) 项目, LR(1)自动机, LR(1) 分
析表 ,LR(1) 文法
• LALR(1)分析: 同核心, LALR(1) 自动机的构造, 
自生与传播
• 二义文法在LR分析中的应用，LR分析错误处理
• YACC, ANTLR
THSS 44100593 2024 / 6A-216
49
基本思想：从文法的开始符号出发，推
导出句子
 回溯→避免条件 First(x) 
 Follow(u)
 基本问题
 无限循环→消除左递归
递归下降LL(1)分析法
分析方法
表驱动LL(1)分析法
自动产生：ANTLR
自
上
而
下
语
法
分
析
THSS 44100593 2024 / 6A-216
50
基本思想：从输入串开始逐步归约
基本问题：归约的问题
优先分析法* 算符优先
优先函数的构造
分析方法 规范句型活前缀
基础知识 LR(0)项目及项目集
LR(1)项目及项目集
LR分析法 LR分析器 分析栈、分析表
分析方法
LR(0)A,SLR/LR/LALR(1)分析表的构造
二义性文法的分析
出错处理
自动产生：YACC
自
下
而
上
语
法
分
析
THSS 44100593 2024 / 6A-216
51
• 语义处理概述
• 语法制导翻译
• 语法制导定义
– 综合属性
– 继承属性
• 基于语法制导定义的语义处理
– 基于树遍历方法的语义处理
– 单遍的方法:自下而上,自上而下
• 翻译方案
– 自上而下的翻译
– 自下而上的翻译
• 符号表
Review
THSS 44100593 2024 / 6A-216
52
• 运行时存储组织
– 活动记录
– 静态链/访问链
– 动态链/控制链
• 中间代码生成
– 中间代码
– 声明语句
– 赋值语句
– 布尔表达式
– 控制语句
– 拉链
– 代码回填
• 代码生成
• 代码优化基础
Review
THSS 44100593 2024 / 6A-216
53
• 汇编语言程序设计基本概念及X86体系结构
• 汇编语言程序设计模板
• 数据传送、寻址与计算
• 过程
• 条件处理
• 整数运算（移位、乘法、除法）
• 高级过程
• 字符串
• 数组
• 结构
• 宏
• MS-Windows程序设计
• MS-DOS程序设计
• BIOS程序设计
Review
更详尽的内容参见课程
的思维导图
THSS 44100593 2024 / 6A-216
Thanks to everyone 
(speakers)!
Thanks to TA!
THSS 44100593 2024 / 6A-216
55
说明
• 关于考试
– 2025年1月5号（周日）上午 09:00-11:00
– 二教401/402
– 闭卷考试
– 以讲义为主
– 遵守考场纪律
• 答疑时间地点
– 2025年1月2日(周四) 下午13:30-16:00 
– 2025年1月3日(周五) 下午13:30-16:00
– 东配楼11区421室或405室
THSS 44100593 2024 / 6A-216
56
展望
• 汇编与编译原理
–编译原理
–汇编语言程序设计
• IISE
THSS 44100593 2024 / 6A-216
考试顺利！
新年快乐！
预祝
寒假愉快！
